<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面经</title>
    <url>/2020/04/14/%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="oppo"><a href="#oppo" class="headerlink" title="oppo"></a>oppo</h2><ol>
<li>JavaScript的基本数据类型有哪些，基本数据类型和引用数据类型的区别？<br>JavaScript的基本数据类型有六个，<code>Number,String,Boolean,Null,Undefined, Symbol</code>。后面多了一个<code>BigInt</code><br>基本数据类型和引用数据类型<code>（object）</code>的区别：（存储的位置）</li>
</ol>
<ul>
<li>基本数据类型是存放在<strong>栈</strong>中的<strong>简单数据段</strong>，<strong>数据大小确定</strong>，<strong>内存空间大小可以分配</strong>，按值存放，按值访问。</li>
<li>引用数据类型是存放在<strong>堆内存中的对象</strong>，变量其实是保存在栈内存中的一个指针，每个的空间大小不一样。 </li>
</ul>
<p>2.数组和链表的差别？（内存空间上）  </p>
<ul>
<li>数组是一种<strong>线性表数据结构</strong>。它采用的是<strong>一组连续的内存空间</strong>，来存储一组具有<strong>相同类型的数据</strong>。最大的特点是支持随机访问，但插入、删除操作也因此变得低效，平均情况复杂度为O(n)。</li>
<li>链表<strong>并不需要一块连续的内存空间</strong>，它通过指针将一组<strong>零散的内存</strong>，连接起来。空间可扩容。相比于数组，链表更适合插入删除操作频繁的场合，不过查询的时间复杂度比较高</li>
</ul>
<p>3.判断一个对象是数组的方法？</p>
<ul>
<li>instanceOf</li>
<li>Object.prototype.toString.call()  </li>
<li>ES6数组新增方法中的Array.isArray()  </li>
</ul>
<p>4.闭包<br>闭包：一个A函数里面有一个B函数，B函数使用了A函数中声明的参数和变量，（即使B函数被返回，寿命终结之后），而B函数就称为闭包或者闭包函数</p>
<p>特点：</p>
<ul>
<li>让外部访问函数内部变量成为可能</li>
<li>局部变量会常驻在内存中</li>
<li>可以避免使用全局变量，防止全局变量污染</li>
<li>会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</li>
</ul>
<p>一个有用的结论：<strong>闭包找到的是同一个地址中父级函数中对应变量最终的值</strong>   </p>
<p>看几个栗子可能会更明白：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function outerFn()&#123;</span><br><span class="line">  var i &#x3D; 0; </span><br><span class="line">  function innerFn()&#123;</span><br><span class="line">      i++;</span><br><span class="line">      console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return innerFn;</span><br><span class="line">&#125;</span><br><span class="line">var inner &#x3D; outerFn();  &#x2F;&#x2F;每次外部函数执行的时候，外部函数的地址不同，都会重新创建一个新的地址</span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line">var inner2 &#x3D; outerFn();</span><br><span class="line">inner2();</span><br><span class="line">inner2();</span><br><span class="line">inner2();   &#x2F;&#x2F;1 2 3 1 2 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var i &#x3D; 0;</span><br><span class="line">function outerFn()&#123;</span><br><span class="line">  function innnerFn()&#123;</span><br><span class="line">       i++;</span><br><span class="line">       console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return innnerFn;</span><br><span class="line">&#125;</span><br><span class="line">var inner1 &#x3D; outerFn();</span><br><span class="line">var inner2 &#x3D; outerFn();</span><br><span class="line">inner1();</span><br><span class="line">inner2();</span><br><span class="line">inner1();</span><br><span class="line">inner2();  &#x2F;&#x2F;1 2 3 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function outerFn()&#123;</span><br><span class="line">var i &#x3D; 0;</span><br><span class="line">  function innnerFn()&#123;</span><br><span class="line">      i++;</span><br><span class="line">      console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  return innnerFn;</span><br><span class="line">&#125;</span><br><span class="line">var inner1 &#x3D; outerFn();</span><br><span class="line">var inner2 &#x3D; outerFn();</span><br><span class="line">inner1();</span><br><span class="line">inner2();</span><br><span class="line">inner1();</span><br><span class="line">inner2(); &#x2F;&#x2F;1 1 2 2 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(function() &#123; </span><br><span class="line">  var m &#x3D; 0; </span><br><span class="line">  function getM() &#123; return m; &#125; </span><br><span class="line">  function seta(val) &#123; m &#x3D; val; &#125; </span><br><span class="line">  window.g &#x3D; getM; </span><br><span class="line">  window.f &#x3D; seta; </span><br><span class="line">&#125;)(); </span><br><span class="line">f(100);</span><br><span class="line">console.info(g()); &#x2F;&#x2F;100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var lis &#x3D; document.getElementsByTagName(&quot;li&quot;);</span><br><span class="line">for(var i&#x3D;0;i&lt;lis.length;i++)&#123;</span><br><span class="line">  (function(i)&#123;</span><br><span class="line">      lis[i].onclick &#x3D; function()&#123;</span><br><span class="line">           console.log(i);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;)(i);       &#x2F;&#x2F;事件处理函数中闭包的写法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">	var a &#x3D; 2;</span><br><span class="line">	return function fun1() &#123;</span><br><span class="line">		console.log(a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var fun2 &#x3D; foo()</span><br><span class="line">fun2()  &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<p>在最后一个栗子中，fun1能够访问foo的内部作用域，我们把fun1作为一个值返回。在foo()执行后，把foo()的返回值 fun1 赋值给fun2并调用fun2。打印出了结果2.<br>此时，我们可以说fun1记住并访问了所在的词法作用域 或者说 fun2访问了另一个函数作用域中的变量（fun2在全局作用域中声明，访问了foo的内部作用域）<br>由于引擎有自动的垃圾回收机制，<strong>在foo()执行后（不再使用）</strong>，通常foo的整个内部作用域会被销毁，对内存进行回收。闭包的神奇之处正是可以阻止这件事情的发生，<strong>因为fun1依然持有对该作用域的引用，这个引用就叫做闭包</strong>。</p>
<p>也就是说，尽管foo执行后被销毁了，但是foo的执行，返回的fun1，是有着对foo作用域的引用，也即是还是可以访问得到foo的内部变量的。fun1赋值给了fun2，相当于fun2可以一直使用着foo的变量a</p>
<p>5.作用域链和原型链</p>
<ul>
<li>作用域链：是为了访问变量而存在的链。</li>
</ul>
<p><strong>作用域</strong>的概念是，<strong>执行代码的上下文</strong>，也可以说是变量对象，是开始进入一个函数执行环境的时候，形成所有可访问变量，可以说<strong>变量对象是作用域的实体</strong></p>
<p>作用域分类：全局作用域、函数作用域（块级作用域）、eval作用域。ES6之前的块级作用域只指函数作用域，ES6以后，<code>if</code>，<code>while</code>，<code>switch</code>，<code>for</code>语句都可以形成自己的块级作用域（使用非var来声明变量）。<strong>全局作用域是作用域链的最顶层</strong>。</p>
<p>作用域链的概念：是由作用域组成的一个带头结点的单向链表，主要作用域是用来查找变量的。【scope】属性是一个指向这个链表头结点的指针。具体来说形成过程：在定义一个函数的时候，在函数内部会会创建一个scope属性，这个属性指向一个作用域链。在确定其scope属性的时候，js解析器按照一定的规则来确认作用域链：从函数内部向外遍历，每当遇到一个function的时候，就把这个<code>function</code>的变量对象添加到作用域链上，一直到最顶层wind我对象。最后再把作用域链的引用赋给<code>scope</code>属性。</p>
<p>作用域的特点：先在自己的变量范围中查找，如果找不到，就会沿着作用域往上找。</p>
<p>原型链的概念：原型链是通过<strong>proto</strong>属性形成的，任何对象（普通对象和函数对象）都有<strong>proto</strong>属性。查找对象的某个属性的时候，首先在当前对象查找，如果没有去对象的<strong>proto</strong>中去查找，一直到最顶层的null，这样形成的以条查找链就是原型链。</p>
<p>所有对象的 <strong>proto</strong>都指向他的构造函数的prototype</p>
<p>所有函数对象<code>(Number,String,Date，Object</code>等12种内置构造函数，还包括自定义构造函数)的 <code>__proto__</code>都指向<code>Function.prototype</code>(他是一个空函数empty function)</p>
<p>6.箭头函数<br>箭头函数，没有prototype,没有自己的this执行，不可以使用arguments，自然不可以new。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fun &#x3D; (a, s) &#x3D;&gt; &#123; console.log(arguments) &#125;; </span><br><span class="line"> console.dir(fun); &#x2F;&#x2F; --- &gt;没有prototype 没有自己的this指向 不可以使用arguments 不可以new</span><br><span class="line"> &#x2F;&#x2F; fun(1,2) &#x2F;&#x2F; Uncaught ReferenceError: arguments is not defined</span><br><span class="line"></span><br><span class="line"> let func &#x3D; function(a, s) &#123; console.log(arguments) &#125;; </span><br><span class="line"> console.dir(func);</span><br><span class="line"> func(1,2) &#x2F;&#x2F; Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br></pre></td></tr></table></figure>
<p>如果要使用类似于arguments获取参数，可以使用rest参数代替</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fun &#x3D; (...arg) &#x3D;&gt; &#123; console.log(...arg) &#125;; </span><br><span class="line">  fun(1,2)  &#x2F;&#x2F; 1 2</span><br><span class="line">   </span><br><span class="line">  let func &#x3D; function(a, s) &#123; console.log(arguments) &#125;; </span><br><span class="line">  func(1,2) &#x2F;&#x2F; Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br></pre></td></tr></table></figure>
<p>7.Vue中的响应式原理，实现数据的双向绑定，原理(<code>Object.defineProperty</code>)</p>
<p>Vue会使用<code>Object.defineProperty</code>给每个属性增加setter和getter属性，这两个属性对用户来说是不可见的。当Vue中的data属性值被访问和修改时，会触发对应的getter和setter，以实现依赖追踪(<code>dependency-track</code>)和变更通知(<code>change-notification</code>)。<br>因为每个组件实例都有相应的<code>watcher</code>实例对象,它会在组件渲染的过程中把属性(data初始化的值)记录为依赖,之后当依赖项的<code>setter</code>被调用时，会通知<code>watcher</code>重新计算，从而致使它关联的组件得以更新。</p>
<p><img src="/2020/04/14/%E9%9D%A2%E7%BB%8F/vue.png" alt="vue.png"></p>
<p>这是我手动写的object.defineProperty,核心思路就是，通过<code>Object.defineProperty</code>给每个属性加<code>setter</code>和<code>getter</code>属性，然后通过<code>new Watcher</code>实例，<code>watcher</code>实例拿到属性的依赖,并手动触发一个<code>getter</code>属性，并把该watcher实例添加到订阅数组里<br>一旦属性值被改变，就会触发<code>setter</code>，然后会执行，<code>watcher</code>实例对应的<code>update</code>方法，把新的值更新到页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dep &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.subs &#x3D; []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        this.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    notify() &#123;</span><br><span class="line">        this.subs.forEach(sub &#x3D;&gt; &#123;</span><br><span class="line">            sub.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;全局属性，通过该属性配置watcher，每次new一个watcher实例，这个属性就会被赋值为该watcher实例</span><br><span class="line">Dep.target &#x3D; null;</span><br><span class="line"></span><br><span class="line">function update(value) &#123;</span><br><span class="line">    document.querySelector(&#39;div&#39;).innerText &#x3D; value</span><br><span class="line">&#125;</span><br><span class="line">class Watcher &#123;</span><br><span class="line">    constructor(obj, key, cb) &#123;</span><br><span class="line">        &#x2F;&#x2F;将Dep.target指向自己</span><br><span class="line">        &#x2F;&#x2F;然后触发属性的getter添加监听</span><br><span class="line">        &#x2F;&#x2F;最后将Dep.target置空</span><br><span class="line">        Dep.target &#x3D; this;</span><br><span class="line">        this.cb &#x3D; cb;</span><br><span class="line">        this.obj &#x3D; obj;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; obj[key] &#x2F;&#x2F;触发getter属性，这时候把subwatcher实例也即时Dep.target，加进了subs了</span><br><span class="line">        Dep.target &#x3D; null; &#x2F;&#x2F;重新置为空</span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        &#x2F;&#x2F;这是当setter被触发时，会调用的</span><br><span class="line">        &#x2F;&#x2F;获得新值</span><br><span class="line">        this.value &#x3D; this.obj[this.key]</span><br><span class="line">            &#x2F;&#x2F;调用update方法更新Dom</span><br><span class="line">        this.cb(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function observe(obj) &#123;</span><br><span class="line">    if (!obj || typeof(obj) !&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;给每个属性增加setter和getter</span><br><span class="line">    Object.keys(obj).forEach((key) &#x3D;&gt; &#123;</span><br><span class="line">        defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    function defineReactive(obj, key, value) &#123;</span><br><span class="line">        &#x2F;&#x2F;递归子属性，若子属性是object的情况下</span><br><span class="line">        observe(value);</span><br><span class="line">        &#x2F;&#x2F;建立依赖数组</span><br><span class="line">        let dp &#x3D; new Dep()</span><br><span class="line">            &#x2F;&#x2F;真正增加setter和getter的方法</span><br><span class="line">        Object.defineProperty(obj, key, &#123;</span><br><span class="line">            enumerable: true,</span><br><span class="line">            configurable: true,</span><br><span class="line">            get: function() &#123;</span><br><span class="line">                console.log(&#39;get value&#39;);</span><br><span class="line">                &#x2F;&#x2F;添加watcher实例到订阅数组里</span><br><span class="line">                if (Dep.target) &#123;</span><br><span class="line">                    dp.addSub(Dep.target)</span><br><span class="line">                &#125;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;,</span><br><span class="line">            set: function(newval) &#123;</span><br><span class="line">                console.log(&quot;set newval&quot;);</span><br><span class="line">                value &#x3D; newval; &#x2F;&#x2F;这时候obj[key]其实已经时新的值了</span><br><span class="line">                &#x2F;&#x2F;执行watcher的update方法</span><br><span class="line">                dp.notify()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var data &#x3D; &#123; name: &#39;lin&#39; &#125;;</span><br><span class="line">observe(data);</span><br><span class="line">&#x2F;&#x2F;模拟解析到&#123;&#123;name&#125;&#125;触发的操作</span><br><span class="line">new Watcher(data, &#39;name&#39;, update) &#x2F;&#x2F;这时候添加watcher实例，会手动触发了属性的getter,然后把watcher实例</span><br><span class="line">    &#x2F;&#x2F;sub添加进subs订阅数组，当setter触发时，就会对subs每个watcher调用update方法，更新DOM</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新了DOM</span><br><span class="line">data.name &#x3D; &#39;ljt&#39;</span><br></pre></td></tr></table></figure>
<p><code>Proxy</code>与 <code>Object.defineProperty</code>对比</p>
<p><code>Object.defineProperty</code> 虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p>
<ul>
<li>只能对<strong>属性</strong>进行数据劫持，所以需要<strong>深度遍历整个对象</strong></li>
<li>对于<strong>数组不能监听到数据的变化</strong></li>
</ul>
<p>通过proxy我们可以有效解决这个问题,原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 <code>Proxy</code>替换 <code>Object.defineProperty</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let onWatch &#x3D; (obj, setBind, getLogger) &#x3D;&gt; &#123;</span><br><span class="line">    let handler &#x3D; &#123;</span><br><span class="line">        get(target, property, receiver) &#123;</span><br><span class="line">            getLogger(target, property)</span><br><span class="line">            return Reflect.get(target, property, receiver)</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target, property, value, receiver) &#123;</span><br><span class="line">            setBind(value)</span><br><span class="line">            return Reflect.set(target, property, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line">let obj &#x3D; &#123; a: 1 &#125;</span><br><span class="line">let value;</span><br><span class="line">let p &#x3D; onWatch(obj, v &#x3D;&gt; &#123;</span><br><span class="line">        value &#x3D; v;</span><br><span class="line">    &#125;,</span><br><span class="line">    (target, property) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#96;Get &#39;$&#123;property&#125;&#39; &#x3D; $&#123;target[property]&#125;&#96;)</span><br><span class="line">    &#125;)</span><br><span class="line">p.a &#x3D; 2; &#x2F;&#x2F;bind value to 2</span><br><span class="line">p.a &#x2F;&#x2F;Get &#39;a&#39; &#x3D; 2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>解决js0.1+0.2的问题</title>
    <url>/2020/04/10/%E8%A7%A3%E5%86%B3js0-1-0-2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="js为什么0-1-0-2-0-3"><a href="#js为什么0-1-0-2-0-3" class="headerlink" title="js为什么0.1+0.2!=0.3"></a>js为什么0.1+0.2!=0.3</h2><p>因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。<code>number</code>类型中，浮点数的精度远远不如整数。浮点数的数字运算，存在的是<strong>精度缺失</strong>的问题，在<code>0.1+0.2</code>这个式子中，<code>0.1</code>和<code>0.2</code>都是近似表示的。</p>
<p>因为我们都知道计算机表示十进制使用二进制来表示的，0.1在二进制中的表示为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; (0011) 表示循环</span><br><span class="line">0.1 &#x3D; 2^-4 * 1.10011(0011)</span><br></pre></td></tr></table></figure>
<p>如何得到这个二进制的呢，我们可以演算一下<br><img src="/2020/04/10/%E8%A7%A3%E5%86%B3js0-1-0-2%E7%9A%84%E9%97%AE%E9%A2%98/compute.png" alt="compute.png"></p>
<p>小数算二进制和整数不同。乘法计算时，只计算小数位，整数位用作每一位的二进制，并且得到的第一位为最高位。所以我们得出 <code>0.1 = 2^-4 * 1.10011(0011)</code>，那么 <code>0.2</code> 的演算也基本如上所示，只需要去掉第一步乘法，所以得出 <code>0.2 = 2^-3 * 1.10011(0011)。</code></p>
<p>回来继续说 IEEE 754 双精度。六十四位中符号位占一位，整数位占十一位，其余五十二位都为小数位。因为<code>0.1</code> 和<code>0.2</code>都是无限循环的二进制了，所以在小数位末尾处需要判断<strong>是否进位</strong>（就和十进制的四舍五入一样）。</p>
<p>所以<code>2^-4 * 1.10011...001</code>进位后就变成了 <code>2^-4 * 1.10011(0011 * 12次)010</code>。那么把这两个二进制加起来会得出 <code>2^-2 * 1.0011(0011 * 11次)0100</code>, 这个值算成十进制就是<code>0.30000000000000004</code></p>
<p>指数不同的两个浮点数是不能直接相加的，拿<br><code>0.2</code>的有效数位表达和<code>0.1</code>是相同的，但是指数部分比<code>0.1</code>的指数多1，因为恰好<code>0.1x2=0.2</code>，也可以写代码验证一下。</p>
<p><code>0.1</code>的指数部分是<code>-4</code>，<code>0.2</code>指数部分是<code>-3</code>，小阶要向大阶“看齐”，0.1若要表示成指数为-3，就需要将有效数位整体右移，这样一来就能对有效数位相加</p>
<p> 1.100 1100 1100 1100 1100 1101<code>0</code></p>
<p> 0.110 0110 0110 0110 0110 0110 <code>1</code></p>
<hr>
<p>10.011 0011 0011 0011 0011 0011 1</p>
<p>橙色部分不会因为右移而丢失，因为在计算浮点数的时候会运用两个比float位数多的临时变量来计算，double也是</p>
<p>规范化，四舍五入后尾数为</p>
<p>001 1001 1001 1001 1010</p>
<p>指数为-2，表达出来是 0111 1101，<code>0.1+0.2</code>的结果应该表达为</p>
<p>0011 1110 1001 1001 1001 1001 1001 1010（3E99 999A）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(0.1+0.2)&#x2F;&#x2F;0.30000000000000004</span><br></pre></td></tr></table></figure>


<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>原生的解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseFloat((0.1 + 0.2).toFixed(10))</span><br><span class="line">&#x2F;&#x2F;toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。</span><br></pre></td></tr></table></figure>
<p>ES6提供的<code>Number.EPSILON</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function numbersequal(a,b)&#123; return Math.abs(a-b)&lt;Number.EPSILON;</span><br><span class="line">&#125; </span><br><span class="line">var a&#x3D;0.1+0.2， b&#x3D;0.3;</span><br><span class="line">console.log(numbersequal(a,b)); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的一些实现案例</title>
    <url>/2020/04/10/javascript%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>手打了一些可能在面试中会问到的JavaScript功能的一些实现案例</p>
<h2 id="call的实现"><a href="#call的实现" class="headerlink" title="call的实现"></a>call的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(a) &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    b &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    return this.b + a</span><br><span class="line">&#125;&#x2F;&#x2F;测试用的函数</span><br><span class="line"></span><br><span class="line">Function.prototype.mycall &#x3D; function(obj) &#123;</span><br><span class="line">    obj.fn &#x3D; this;&#x2F;&#x2F;绑定this的指向</span><br><span class="line">    &#x2F;&#x2F; console.log(...[...arguments].slice(1))</span><br><span class="line">    return obj.fn(...[...arguments].slice(1)) &#x2F;&#x2F;先把参数整理成一个数组，然后再展开</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#39;mycall&#39;, test.mycall(&#123; b: 2 &#125;, 3))</span><br><span class="line">&#x2F;&#x2F;&#123; b: 2, fn: [Function: test] &#125;</span><br><span class="line">&#x2F;&#x2F;mycall 5</span><br></pre></td></tr></table></figure>
<h2 id="apply的实现"><a href="#apply的实现" class="headerlink" title="apply的实现"></a>apply的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(a) &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    b &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    return this.b + a</span><br><span class="line">&#125; &#x2F;&#x2F;测试用的函数</span><br><span class="line">Function.prototype.myapply &#x3D; function(obj) &#123;</span><br><span class="line">    obj.fn &#x3D; this; &#x2F;&#x2F;将this指向指向了obj，绑定到了obj上</span><br><span class="line">    console.log(obj.fn)</span><br><span class="line">    if (arguments[1]) &#123;</span><br><span class="line">        return obj.fn(...arguments[1]) &#x2F;&#x2F;单独调用的函数的参数，不支持参数数组的，</span><br><span class="line">            &#x2F;&#x2F;需要把参数数组拓展开，用到拓展运算符</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return obj.fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#123; b: 2, fn: [Function: test] &#125;</span><br><span class="line">&#x2F;&#x2F;myapply 5</span><br></pre></td></tr></table></figure>
<h2 id="bind的实现"><a href="#bind的实现" class="headerlink" title="bind的实现"></a>bind的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test(a) &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">    b &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    return this.b + a</span><br><span class="line">&#125; &#x2F;&#x2F;测试用的函数</span><br><span class="line">Function.prototype.mybind &#x3D; function(obj) &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    return function(...args) &#123;</span><br><span class="line">        return _this.apply(obj, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(&#39;mybind&#39;, test.mybind(obj)(3))</span><br><span class="line">&#x2F;&#x2F;&#123; b: 2 &#125;</span><br><span class="line">&#x2F;&#x2F;mybind 5</span><br></pre></td></tr></table></figure>
<h2 id="instance的实现"><a href="#instance的实现" class="headerlink" title="instance的实现"></a>instance的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myinstance(left, right) &#123;</span><br><span class="line"></span><br><span class="line">    left &#x3D; left.__proto__</span><br><span class="line">    let prototype &#x3D; right.prototype;</span><br><span class="line">    while (left !&#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">        if (prototype &#x3D;&#x3D;&#x3D; left) return true;</span><br><span class="line">        left &#x3D; left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a &#x3D; [1, 2];</span><br><span class="line">console.log(myinstance(a, Array))</span><br><span class="line">&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<h2 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;ES5</span><br><span class="line">function mynew() &#123;</span><br><span class="line">    let obj &#x3D; &#123;&#125;; &#x2F;&#x2F;新建一个对象</span><br><span class="line">    let con &#x3D; [].shift.call([...arguments]); &#x2F;&#x2F;拿第一个参数，也就是构造函数</span><br><span class="line">    obj.__proto__ &#x3D; con.prototype;</span><br><span class="line">    let result &#x3D; con.call([...arguments].slice(1))</span><br><span class="line">    return typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES6</span><br><span class="line">function myNew(fn, ...args) &#123;</span><br><span class="line">    let obj &#x3D; Object.create(fn.prototype); &#x2F;&#x2F;创建一个对象，将要实例化对象的原型链指向它</span><br><span class="line">    fn.call(obj, ...args); &#x2F;&#x2F;将函数指向该对象</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fun1() &#123;</span><br><span class="line">    this.name &#x3D; &quot;?&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(myNew(fun1), new fun1()) &#x2F;&#x2F;fun1 &#123; name: &#39;?&#39; &#125; fun1 &#123; name: &#39;?&#39; &#125;</span><br><span class="line"></span><br><span class="line">console.log(JSON.stringify(myNew(fun1)) &#x3D;&#x3D;&#x3D; JSON.stringify(new fun1())) &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node端做代理解决跨域问题获取接口数据</title>
    <url>/2020/04/09/Node%E7%AB%AF%E5%81%9A%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我做一个小demo，利用<code>jsonp</code>调用QQ音乐的接口的时候，发现http请求语法，路径等都没错，但是控制台报了如下错误：<br><img src="/2020/04/09/Node%E7%AB%AF%E5%81%9A%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE/cross.png" alt="cross.png"><br>原来是跨域的问题。我们知道浏览器出于安全考虑，是支持同源策略的。<strong>当协议，域名，端口不同时，就 称为跨域</strong>。跨域的时候,ajax请求就会失败。但是jsonp不就是为了解决跨域的嘛，但是我们要知道，<code>jsonp</code>也是需要服务端允许的情况下，才可以使用<code>jsonp</code>来跨域的，上面这种报错的问题是，服务端不支持<code>jsonp</code>来获取此接口</p>
<p>而跨域资源共享(<code>Cross-Origin-Resource-Sharing</code>)机制，是浏览器为了更安全的处理跨域请求，使其不受同源策略的限制。简单地来说就是在写入<code>response</code>头里的<code>Access-Control-Allow-Origin</code>。对应的源就可以实现跨域资源共享。由此我们知道，这种方法需要<strong>服务端和客户端</strong>同时实现的。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>我们前面知道QQ音乐有些接口因为跨域的限制，不能直接获取到数据。这是因为这个接口指定了特定的源，也就是特定的<code>host</code>和<code>referer</code>，所以我们可以用Node端做一层代理，通过<code>Node server</code>来发送请求，把请求的<code>host</code>和<code>referer</code>改为QQ音乐接口允许的<code>host</code>和<code>referer</code>,来“欺骗”QQ音乐,Node端拿到数据之后，再返回给前端，显示在页面上.</p>
<h3 id="怎么配置Node代理"><a href="#怎么配置Node代理" class="headerlink" title="怎么配置Node代理"></a>怎么配置Node代理</h3><p>首先用 vue-cli脚手架新建一个vue项目。我用的是vue3.0的版本，可能跟2.0的版本有些不同。</p>
<p>在3.0的版本中，是没有<code>webpack.config.js</code>这个文件的，我们需要新建一个<code>vue.config.js</code>文件，来做一些vue项目的配置。</p>
<p>在配置之前我们需要安装一些package，首先要引入<code>express</code>这个包<strong>(注意，vue3.0不会自带<code>express</code>，要自己npm )</strong></p>
<p>除了express还要再装一个<code>axios</code>，这个是基于<code>promise</code>用于浏览器和node.js客户端的一个发送http请求的package</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i express --save-dev</span><br><span class="line">npm i axios --save-dev</span><br></pre></td></tr></table></figure>
<p>然后配置<code>vue.config.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const axios &#x3D; require(&#39;axios&#39;);</span><br><span class="line">var app &#x3D; express();</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;自动打开浏览器</span><br><span class="line">        open: true,</span><br><span class="line">        port: 8888,</span><br><span class="line">        before(app) &#123;</span><br><span class="line">            app.get(&#39;&#x2F;api&#x2F;getDiscList&#39;, function(req, res) &#123;</span><br><span class="line">                const url &#x3D; &#39;https:&#x2F;&#x2F;c.y.qq.com&#x2F;splcloud&#x2F;fcgi-bin&#x2F;fcg_get_diss_by_tag.fcg&#39;; &#x2F;&#x2F;node端要发送HTTP请求的url</span><br><span class="line">                axios.get(url, &#123;</span><br><span class="line">                    headers: &#123;</span><br><span class="line">                        referer: &#39;https:&#x2F;&#x2F;c.y.qq.com&#39;, &#x2F;&#x2F;node端伪造referer和host</span><br><span class="line">                        host: &#39;c.y.qq.com&#39;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    params: req.query &#x2F;&#x2F;请求的参数</span><br><span class="line">                &#125;).then((response) &#x3D;&gt; &#123;</span><br><span class="line">                    res.json(response.data) &#x2F;&#x2F;node端http请求成功后拿到的数据吐给前端调用&#x2F;api&#x2F;getDiscList接口后返回的res</span><br><span class="line">                &#125;).catch((e) &#x3D;&gt; &#123;</span><br><span class="line">                    console.log(e)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>devserver</code>是vue项目中配置的本地服务器，<code>express</code>是node的web开发框架，<code>app</code>是<code>express()</code>返回的对象。<br>这里面方法<code>app.get(url,callback)</code>是一旦前端调用了这个url，node端就会执行callback，我们在<code>callback</code>中写入node端向我们真正要请求的接口的逻辑</p>
<h3 id="前端向node端发送请求"><a href="#前端向node端发送请求" class="headerlink" title="前端向node端发送请求"></a>前端向node端发送请求</h3><p>我们在<code>src</code>目录下，新建一个<code>api</code>文件夹，然后在这个文件夹中新建一个<code>recommend.js</code>和一个<code>config.js</code>文件  </p>
<p><code>recommend.js</code>文件里书写前端向node端发送请求的逻辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;;</span><br><span class="line">import &#123; commonParams, options &#125; from &#39;.&#x2F;config&#39;;</span><br><span class="line"></span><br><span class="line">export function getRecommend() &#123;</span><br><span class="line">    const url &#x3D; &#39;https: &#x2F;&#x2F;c.y.qq.com&#x2F;splcloud&#x2F;fcgi-bin&#x2F;fcg_get_diss_by_tag.fcg&#39;;</span><br><span class="line">    const data &#x3D; Object.assign(&#123;&#125;, commonParams, &#123;</span><br><span class="line">        platform: &#39;h5&#39;,</span><br><span class="line">        uin: 0,</span><br><span class="line">        needNewCode: 1</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export function getDiscList() &#123;</span><br><span class="line">    const url &#x3D; &#39;&#x2F;api&#x2F;getDiscList&#39;;</span><br><span class="line">    const data &#x3D; Object.assign(&#123;&#125;, commonParams, &#123;</span><br><span class="line">        platform: &#39;yqq&#39;,</span><br><span class="line">        hostUin: 0,</span><br><span class="line">        sin: 0,</span><br><span class="line">        ein: 29,</span><br><span class="line">        sortId: 5,</span><br><span class="line">        needNewCode: 0,</span><br><span class="line">        categoryId: 10000000,</span><br><span class="line">        rnd: Math.random(),</span><br><span class="line">        format: &#39;json&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    return axios.get(url, &#123;</span><br><span class="line">        params: data</span><br><span class="line">    &#125;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F;这里的res,是之前前端调用&#x2F;api&#x2F;getDiscList接口返回的res</span><br><span class="line">        return Promise.resolve(res.data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>config.js</code>文件里主要写一些配置相关的东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const commonParams &#x3D; &#123;</span><br><span class="line">    g_tk: 5381,</span><br><span class="line">    inCharset: &#39;utf-8&#39;,</span><br><span class="line">    outCharset: &#39;utf-8&#39;,</span><br><span class="line">    notice: 0,</span><br><span class="line">    format: &#39;jsonp&#39;</span><br><span class="line">&#125;&#x2F;&#x2F;暴露出一个通用的参数对象</span><br><span class="line">export const options &#x3D; &#123;</span><br><span class="line">    params: &#39;jsonpCallback&#39;</span><br><span class="line">&#125;</span><br><span class="line">export const ERR_OK &#x3D; 0</span><br></pre></td></tr></table></figure>

<h3 id="组件中的配置"><a href="#组件中的配置" class="headerlink" title="组件中的配置"></a>组件中的配置</h3><p>我们前端调用node端接口的方法已经写好了，现在我们只需要在我们想要实现这个功能的组件中引入这个方法便可。</p>
<p>因为我是新建的一个vue项目，我就直接在<code>about.vue</code>中引入这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;about&quot;&gt;</span><br><span class="line">    &lt;h1&gt;This is an about page&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;getDiscList&#125; from &#39;..&#x2F;api&#x2F;recommend&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;About&#39;,</span><br><span class="line">  created()&#123;</span><br><span class="line">this._getDiscList()</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    _getDiscList()&#123;</span><br><span class="line">      getDiscList().then((res)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(res.data.list)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>在终端输入<code>npm  run serve</code>,vue2.0的朋友是<code>npm run dev</code><br>项目运行成功之后，我们打开谷歌的开发者工具，在控制台可以看到:<br><img src="/2020/04/09/Node%E7%AB%AF%E5%81%9A%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE/result.png" alt="result.png"><br>我们的demo就拿到了接口的数据了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后归纳一下，有些接口，如果服务端不支持<code>Jsonp</code>的话，我们只能采用node代理服务器的方式,因为<code>nodeServer</code>可以加入header，配置<code>host</code>和<code>referer</code>,来达到”欺骗”的效果</p>
<p>最后，千万不要用这种方法调用接口太频繁，会被封号的。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter开发中遇到的小问题</title>
    <url>/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>flutter作为谷歌新推的跨平台的开发框架，有很大的发展前景。我主要归纳一些我在开发过程中遇到的难点,持续更新中…</p>
<h2 id="flutter卡在package-get的解决方案"><a href="#flutter卡在package-get的解决方案" class="headerlink" title="flutter卡在package get的解决方案"></a>flutter卡在package get的解决方案</h2><p>主要的问题是国内有墙，需要一些国内的镜像才可以下载到相应的包。我们可以给我们的电脑增加如下的环境变量：  </p>
<ul>
<li>Linux或Mac<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn</span><br><span class="line"></span><br><span class="line">export FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn</span><br></pre></td></tr></table></figure></li>
<li>Windows<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUB_HOSTED_URL &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; https:&#x2F;&#x2F;pub.flutter-io.cn</span><br><span class="line"></span><br><span class="line">FLUTTER_STORAGE_BASE_URL &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; https:&#x2F;&#x2F;storage.flutter-io.cn</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>然后在终端运行<code>flutter doctor</code>命令，后续的<code>package get</code> 应该就没问题了</p>
<h2 id="Flutter报错Waiting-for-another-flutter-command-to-release-the-startup-lock解决方案"><a href="#Flutter报错Waiting-for-another-flutter-command-to-release-the-startup-lock解决方案" class="headerlink" title="Flutter报错Waiting for another flutter command to release the startup lock解决方案"></a>Flutter报错Waiting for another flutter command to release the startup lock解决方案</h2><p>解决方案： 打开<code>flutter</code><strong>安装目录</strong> <code>/bin/cache</code>，找到<code>lockfile</code>文件，把这个文件删除，问题就解决了</p>
<h2 id="flutter中package包版本冲突的问题"><a href="#flutter中package包版本冲突的问题" class="headerlink" title="flutter中package包版本冲突的问题"></a>flutter中package包版本冲突的问题</h2><p>当你的项目需要安装的依赖包越多，遇到包冲突可能性就越大，尤其是当依赖的包有重大更新时<br><img src="/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/conflict.png" alt="conflict.png"></p>
<p>上面可以看到是<code>xml</code>跟<code>intl_translation</code>两个包有冲突，因为他们依赖两个不同的<code>petitparser</code>包。打开<code>pubspec.yaml</code>看到:<br><img src="/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/depend.png" alt="depend.png"></p>
<p>解决办法：<br>通过将两者依赖包版本号改为：any<br><img src="/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/any.png" alt="any.png"><br>击<code>flutter packages get</code>重新获取包，这样就会自动去匹配适合两者的包，然后我们会看到<code>Got dependencies</code>的结果，但是，问题还没有解决，我们需要在根目录下找到<code>pubspec.lock.yarm</code>文件，然后看到冲突的那两个包对应的版本号，这是通过匹配得到的适配的版本号，然后把在<code>pubspec.yaml</code>中的<code>any</code>改成对应的版本，就可以了。<br><img src="/2020/04/08/Flutter%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/rightVer.png" alt="rightVer.png"></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>异步及异步编程的解决方案</title>
    <url>/2020/04/07/%E5%BC%82%E6%AD%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><p>简单的来说就是一件事不是连续紧接着做完的，可以分为几个阶段，<strong>先进行一个阶段，剩下的阶段延后执行</strong>。在延迟的这段时间，做的是别的任务。相应的，连续执行的任务是同步的</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&quot;4&quot;)</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&quot;5&quot;);</span><br></pre></td></tr></table></figure>
<p><code>setTimeout</code>就是一个异步任务，先做延迟，然后在延迟期间把执行权交给了<code>console.log</code>，所以是先输出5，再输出4.</p>
<p>为什么要异步呢，因为JavaScript是单线程语言，如果像上面那种情况，还是使用同步的话，那延迟期间，线程里什么事情都没有做，会白白浪费处理器时间，耗费性能。</p>
<h2 id="异步编程方案"><a href="#异步编程方案" class="headerlink" title="异步编程方案"></a>异步编程方案</h2><p>异步编程有很多解决的方案，其演变过程是： 回调函数=&gt;<code>promise</code>=&gt; <code>Generator</code> =&gt; <code>async/await</code>,每个演变过程都会解决一些之前的问题</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>举个栗子，Node里的fs模块，读取文件的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.readFile(&#39;url&#39;,&#39;utf-8&#39;,function(err,data)&#123;</span><br><span class="line">    if(err) throw err;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码中，readFile函数的第三个参数，就是回调函数，也就是等操作系统返回对应的文件之后，才会执行这个回调函数的操作。</p>
<p>也即是说，在执行<code>readFile</code>的时候，执行权交给了主线程执行栈的同步任务，同步任务执行完之后，才会执行回调函数对应的操作。</p>
<h4 id="回调函数的缺点"><a href="#回调函数的缺点" class="headerlink" title="回调函数的缺点"></a>回调函数的缺点</h4><p>回调函数会导致回调地狱。</p>
<p>比如说现在有很多异步任务，且任务有依赖关系（一个任务需要拿到另一个任务成功后的结果才能开始执行）的时候，回调的方式写出来的代码就会像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getData1(data1 &#x3D;&gt; &#123;</span><br><span class="line">  getData2(data1, data2 &#x3D;&gt; &#123;</span><br><span class="line">    getData3(data2, data3 &#x3D;&gt; &#123;</span><br><span class="line">      getData4(data3, data4 &#x3D;&gt; &#123;</span><br><span class="line">        getData5(data4, data5 &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 终于取到data5了</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这种多层嵌套的结构就是回调地狱，<strong>代码可读性很差</strong></p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>promise的出现就是为了解决回调函数回调地狱的问题。<strong>将回调函数的嵌套改为了链式调用</strong></p>
<p>Promise可以当作一个状态机，promise实例有三个状态：</p>
<ul>
<li>Pending(进行中)</li>
<li>Fulfilled(已成功)</li>
<li>rejected (已失败)</li>
</ul>
<p>我们使用<code>new Promise</code>去创建一个Promise实例，这个Promise实例会传入一个函数作为参数，函数又有两个函数作为参数，分别是：<code>resolve</code>、<code>reject</code>。</p>
<p>执行<code>resolve</code>函数，<code>Promise</code>实例的状态会变为<code>fulfilled</code>，后续就会去执行.then回调函数</p>
<p>执行<code>reject</code>函数，<code>Promise</code>实例的状态会变为<code>rejected</code>，后续就会去执行<code>.catch</code>回调函数，或者<code>.then</code>的第二个回调函数。</p>
<p>基本结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;做一些事情</span><br><span class="line">    &#x2F;&#x2F;然后在某些条件下resolve，或者reject（以下代码）</span><br><span class="line">    if(&#x2F;* 条件随便写 *&#x2F;)&#123;</span><br><span class="line">       	 resolve()</span><br><span class="line">     &#125; else&#123;</span><br><span class="line">         reject()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(()&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;如果p的状态被resolve了，就进入这里</span><br><span class="line">&#125;,()&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;如果p的状态被reject</span><br><span class="line">&#125;)&#x2F;&#x2F;这么写reject，使用了then的第二个回调函数</span><br></pre></td></tr></table></figure>
<p><code>promise</code>的异步体现在，<code>new promise</code>的部分是立即执行的，执行完毕之后，会把执行权交给主线程的执行栈执行同步任务，然后再是执行，<code>then</code>和<code>catch</code>的回调。这里涉及到了JavaScript的事件执行机制</p>
<h3 id="promise-实现多任务顺序执行"><a href="#promise-实现多任务顺序执行" class="headerlink" title="promise 实现多任务顺序执行"></a>promise 实现多任务顺序执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result&#x3D;new Promise(function(resolve,reject)&#123;</span><br><span class="line">	setTimeout(function()&#123;</span><br><span class="line">		resolve(&quot;one&quot;);</span><br><span class="line">	&#125;,3000)</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">	return new Promise(function(resolve,reject)&#123;</span><br><span class="line">		setTimeout(function()&#123;</span><br><span class="line">			resolve(&quot;two&quot;);</span><br><span class="line">		&#125;,3000)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>原理是在第一个<code>promise</code>实例的<code>then</code>函数回调中再return一个<code>promise</code>实例，也就是后续的任务</p>
<h3 id="promise-实现多任务并行执行"><a href="#promise-实现多任务并行执行" class="headerlink" title="promise 实现多任务并行执行"></a>promise 实现多任务并行执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;做一些事情</span><br><span class="line">    &#x2F;&#x2F;然后在某些条件下resolve，或者reject（以下代码）</span><br><span class="line">    if(&#x2F;* 条件随便写 *&#x2F;)&#123;</span><br><span class="line">       	 resolve()</span><br><span class="line">     &#125; else&#123;</span><br><span class="line">         reject()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(()&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;如果p的状态被resolve了，就进入这里</span><br><span class="line">&#125;,()&#x3D;&gt;&#123;</span><br><span class="line">    &#x2F;&#x2F;如果p的状态被reject</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里主要使用了<code>Promise.all</code>这种结构，<code>Promise.all([p1,p2])</code>接受一个数组作为参数，数组的元素都是<code>Promise</code>实例，只有当数组中所有的<code>promise</code>实例的状态都变为<code>fulfilled</code>的时候，这个<code>Promise.all</code>的实例才会变为<code>fulfilled</code>，才能执行后续的<code>.then</code>操作。</p>
<p>和<code>Promise.all</code>相关的还有<code>Promise.race</code>，那<code>Promise.race</code>实例的状态是等于其参数中第一个执行完毕的<code>Promise</code>实例的状态，它有可能是<code>rejected</code>，也有可能是<code>fulfilled</code>。</p>
<h3 id="promise的缺点"><a href="#promise的缺点" class="headerlink" title="promise的缺点"></a>promise的缺点</h3><p><code>promise</code>的最大的缺点就是会造成代码冗余，原来的任务被<code>promise</code>包装了一下，不管什么操作，一眼看过去都是一堆的then,原来的语义变得很不清楚。通俗点讲，就是链式调用得多了，then多了，你都不知道第一个函数是干嘛的了</p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator函数是ES6提供的异步编程解决方案，generator解决的是上面promise代码冗余的问题。它用的是类似同步的写法来执行一些异步操作</p>
<ul>
<li><code>generator</code>函数的声明方式是<code>function *</code>，函数内部使用<code>yield</code>表达式，定义不同的内部状态</li>
<li>执行Generator函数会返回一个<strong>遍历器对象</strong></li>
<li>调用Generator函数后，该函数并不执行，返回不是函数运行结果，而是一个执行内部状态的指针</li>
<li>必须调用遍历器对象的next方法，使得指针移向下个状态，输出返回的结果。</li>
</ul>
<h3 id="Generator函数的写法"><a href="#Generator函数的写法" class="headerlink" title="Generator函数的写法"></a>Generator函数的写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* helloWorldGenerator() &#123;</span><br><span class="line">  yield &#39;hello&#39;;</span><br><span class="line">  yield &#39;world&#39;;</span><br><span class="line">  return &#39;ending&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hw &#x3D; helloWorldGenerator();</span><br><span class="line">hw.next()</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;hello&#39;, done: false &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;world&#39;, done: false &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;ending&#39;, done: true &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<h3 id="异步应用"><a href="#异步应用" class="headerlink" title="异步应用"></a>异步应用</h3><p>因为<code>yield</code>能够中断执行代码的特性，可以帮助我们来<strong>控制异步代码的执行</strong></p>
<p>例如有两个异步函数<code>A</code>和<code>B</code>，并且B的参数是A的返回值，也就是说，如果<code>A</code>没有执行结束，我们执行结束，我们不能执行<code>B</code></p>
<p>那这时候我们写一段伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* effect() &#123;</span><br><span class="line">  const &#123; param &#125; &#x3D; yield A();</span><br><span class="line">  const &#123; result &#125; &#x3D; yield B(param);</span><br><span class="line">  console.table(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们如果需要得到result，那我们就需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const iterator &#x3D; effect()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure>
<p>co库可以用来每次执行<code>A()/b()</code>请求结束之后，都会自动执行<code>next()</code>方法</p>
<h3 id="使用Generator去实现promise的任务顺序执行"><a href="#使用Generator去实现promise的任务顺序执行" class="headerlink" title="使用Generator去实现promise的任务顺序执行"></a>使用Generator去实现promise的任务顺序执行</h3><p>Generator版本的顺序任务执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    g.next(&quot;one&quot;);  &#x2F;&#x2F;将参数传给data1</span><br><span class="line">  &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2(data1) &#123;</span><br><span class="line">  console.log(&quot;接收到了&quot; + data1);</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">      g.next(&quot;two&quot;);  &#x2F;&#x2F;将参数传给data2</span><br><span class="line">  &#125;,3000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* mygenerator() &#123;</span><br><span class="line">  var data1 &#x3D; yield f1();</span><br><span class="line">  var data2&#x3D;yield f2(data1);</span><br><span class="line">  console.log(data2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; mygenerator();</span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure>
<p>这里要注意的一个点是：执行<code>yield f1()</code>的时候是不会返回的结果返回给<code>data1</code>的。next方法可以接受参数，这是向<code>Generator</code>函数体内输入数据。第二个<code>next</code>的时候传入参数，就能被变量<code>data1</code>就能够接收到。<br>而且不能在f1中直接调用<code>g.next()</code>，要在异步函数内调用<br>再看一个栗子理解:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* G() &#123;</span><br><span class="line">    const a &#x3D; yield 100</span><br><span class="line">    console.log(&#39;a&#39;, a)  &#x2F;&#x2F; a aaa</span><br><span class="line">    const b &#x3D; yield 200</span><br><span class="line">    console.log(&#39;b&#39;, b)  &#x2F;&#x2F; b bbb</span><br><span class="line">    const c &#x3D; yield 300</span><br><span class="line">    console.log(&#39;c&#39;, c)  &#x2F;&#x2F; c ccc</span><br><span class="line">&#125;</span><br><span class="line">const g &#x3D; G()</span><br><span class="line">g.next()    &#x2F;&#x2F; value: 100, done: false</span><br><span class="line">g.next(&#39;aaa&#39;) &#x2F;&#x2F; a aaa   value: 200, done: false   </span><br><span class="line">g.next(&#39;bbb&#39;) &#x2F;&#x2F;   b bbb  value: 300, done: false</span><br><span class="line">g.next(&#39;ccc&#39;) &#x2F;&#x2F;c ccc  value: undefined, done: true</span><br></pre></td></tr></table></figure>
<h3 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* gen(x)&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    var y &#x3D; yield x + 2;</span><br><span class="line">  &#125; catch (e)&#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; gen(1);</span><br><span class="line">g.next();</span><br><span class="line">g.throw(&#39;出错了&#39;);</span><br><span class="line">&#x2F;&#x2F; 出错了</span><br></pre></td></tr></table></figure>
<p>使用<code>try...catch</code>。</p>
<h2 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h2><p>async函数就是Generator的语法糖。<br>形式上的不同：</p>
<ul>
<li><code>async</code>函数将<code>Generator</code>函数的星号(*)替换成<code>async</code></li>
<li>将<code>yield</code>替换成<code>await</code></li>
</ul>
<p>async函数对Generator函数改进体现在以下三点： </p>
<p>1.内置执行器</p>
<p>也就是说async函数的执行，和普通函数一样，只需要一行就可以。不用像Generator函数需要调用<code>next</code>方法才能真正执行。</p>
<p>例如对于一个async函数来说:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const asyncReadFile &#x3D; async function () &#123;</span><br><span class="line">  const f1 &#x3D; await readFile(&#39;&#x2F;etc&#x2F;fstab&#39;);</span><br><span class="line">  const f2 &#x3D; await readFile(&#39;&#x2F;etc&#x2F;shells&#39;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用时只需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asyncReadFile()</span><br></pre></td></tr></table></figure>
<p>2.更好的语义<br><code>async</code>和<code>await</code>比起星号和<code>yield</code>，语义更加清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。<br>3.返回值是Promise<br><code>async</code>函数的返回值是 <code>Promise</code> 对象，这比 <code>Generator</code> 函数的返回值是 <code>Iterator</code>对象方便多了。你可以用then方法指定下一步的操作。</p>
<h3 id="async函数的基本用法"><a href="#async函数的基本用法" class="headerlink" title="async函数的基本用法"></a>async函数的基本用法</h3><p><code>async</code>函数返回一个<code>Promise</code>对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function getStockPriceByName(name) &#123;</span><br><span class="line">  const symbol &#x3D; await getStockSymbol(name);</span><br><span class="line">  const stockPrice &#x3D; await getStockPrice(symbol);</span><br><span class="line">  return stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(&#39;goog&#39;).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先执行了第一个<code>await</code>后的<code>getStockSymbol(name)</code>函数；得到了股票的名称<code>symbol</code>后，将<code>symbol</code>传给第二个<code>await</code>后面的<code>getStockPrice(symbol)</code>作为参数；最后返回股票价格<code>stockPrice</code>。</p>
<h3 id="async-await错误处理"><a href="#async-await错误处理" class="headerlink" title="async/await错误处理"></a>async/await错误处理</h3><p><code>try/catch</code><br>使用<code>try</code>将<code>await</code>语句包含起来，如果<code>await</code>后的语句执行错误，则错误会被<code>catch</code>捕获：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run();</span><br><span class="line"></span><br><span class="line">async function run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await Promise.reject(new Error(&quot;Oops!&quot;));</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        error.message; &#x2F;&#x2F; &quot;Oops!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Oops!</span><br></pre></td></tr></table></figure>
<h3 id="执行顺序问题"><a href="#执行顺序问题" class="headerlink" title="执行顺序问题"></a>执行顺序问题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function async1()&#123;</span><br><span class="line">   console.log(&#39;async1 start&#39;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&#39;async1 end&#39;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2()&#123;</span><br><span class="line">    console.log(&#39;async2&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&#39;script start&#39;);</span><br><span class="line">async1();</span><br><span class="line">console.log(&#39;script end&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></pre></td></tr></table></figure>
<p>当<code>async</code>函数执行的时候，一旦遇到<code>await</code>就会先返回，等到触发的异步操作完成后，再执行函数体后面的语句。可以理解为，是让出了线程，跳出了<code>async</code>函数体。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;</span><br><span class="line">    console.log(&#39;async1 start&#39;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&#39;async1 end&#39;);</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;</span><br><span class="line">    console.log(&#39;async2&#39;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;script start&#39;);</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    console.log(&#39;setTimeout&#39;);</span><br><span class="line">&#125;, 0)</span><br><span class="line">async1();</span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">    console.log(&#39;promise1&#39;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">    console.log(&#39;promise2&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#39;script end&#39;);</span><br></pre></td></tr></table></figure>
<p>执行顺序为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script start-async1 start-async2-promise1-script end-async1 end-promise2--setTimeout</span><br></pre></td></tr></table></figure>
<p>执行<code>async1</code>的时候遇到<code>await</code>先去执行<code>async2</code>，然后跳出了函数体，去执行后续的代码，然后再回到当前<code>async1</code>函数当中执行<code>await</code>后续语句。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://delaprada.com/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/#more" target="_blank" rel="noopener">https://delaprada.com/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/#more</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node的串行化和并行化流程控制</title>
    <url>/2020/04/06/Node%E7%9A%84%E4%B8%B2%E8%A1%8C%E5%8C%96%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%8C%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="异步逻辑顺序化"><a href="#异步逻辑顺序化" class="headerlink" title="异步逻辑顺序化"></a>异步逻辑顺序化</h2><p>在异步程序中，有些任务可能是随时发生的，跟程序中其他部分在做什么没关系，什么时候做这些任务都不会出问题。但有些任务只能在某些特定的任务的之前或之后做。<br>让一组异步任务的执行任务按顺序执行的概念成为<strong>流程控制</strong>。这种控制分为<strong>串行</strong>和<strong>并行</strong><br>串行任务： 需要一个任务接着一个任务<br>并行任务： 不需要一个接着一个执行的任务。这些任务彼此之间开始和结束时间并不重要，<strong>但在后续逻辑执行前它们应该全部执行完成</strong>。</p>
<h2 id="实现串行化流程控制"><a href="#实现串行化流程控制" class="headerlink" title="实现串行化流程控制"></a>实现串行化流程控制</h2><p>原理：<br>为了让一组异步任务按顺序执行，需要把这些任务按预期的执行顺序放到一个数组中去。这个数组起到队列的作用，完成一个任务之后按顺序从数组中取出下一个。</p>
<h3 id="串行化的实现实例"><a href="#串行化的实现实例" class="headerlink" title="串行化的实现实例"></a>串行化的实现实例</h3><p>做一个小程序，让他从一个随机选择的RSS预定源中获取一篇文章的标题和URL，并显示出来。RSS预定源列表放在一个文本文件中。</p>
<p>初始化项目：<br>新建一个一个项目文件夹，然后用vscode打开文件夹，在powershell输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm i request --save-dev</span><br><span class="line">npm i htmlparser --save-dev</span><br></pre></td></tr></table></figure>
<p>request 模块是一个经过简化的<code>HTTP</code> 客户端，这里用它来获取<code>RSS</code> 数据。<br>htmlparser 模块能把原始的 RSS 数据转换成 <code>JavaScript</code> 数据结构。  </p>
<p>新建一个txt文本文件<br>输入的RSS预定源列表<code>rss_feeds.txt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;blog.nodejs.org&#x2F;feed&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;blog.npmjs.org&#x2F;rss</span><br></pre></td></tr></table></figure>
<p>新建一个index.js文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const request &#x3D; require(&#39;request&#39;);</span><br><span class="line">const htmlparser &#x3D; require(&#39;htmlparser&#39;);</span><br><span class="line">const configFilename &#x3D; path.join(__dirname, &#39;.&#x2F;rss_feeds.txt&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 【任务一】确保包含 RSS 预定源 URL 列表的文件存在</span><br><span class="line">function checkForRSSFile() &#123;</span><br><span class="line">    fs.exists(configFilename, (exists) &#x3D;&gt; &#123;</span><br><span class="line">        if (!exists)</span><br><span class="line">        &#x2F;&#x2F; 只要有错误就尽早返回</span><br><span class="line">            return next(new Error(&#96;Missing RSS file: $&#123;configFilename&#125;&#96;));</span><br><span class="line">        next(null, configFilename);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 【任务二】读取并解析包含预定源 URL 的文件</span><br><span class="line">function readRSSFile(configFilename) &#123;</span><br><span class="line">    fs.readFile(configFilename, (err, feedList) &#x3D;&gt; &#123;</span><br><span class="line">        if (err) return next(err);</span><br><span class="line">        &#x2F;&#x2F; 将预定源 URL 列表转换成字符串，然后分隔成一个数组</span><br><span class="line">        feedList &#x3D; feedList</span><br><span class="line">            .toString()</span><br><span class="line">            .replace(&#x2F;^\s+|\s+$&#x2F;g, &#39;&#39;) &#x2F;&#x2F; 字符串替换</span><br><span class="line">            .split(&#39;\n&#39;); &#x2F;&#x2F; split() 方法用于把一个字符串分割成字符串数组。按（\n）分割字符串</span><br><span class="line">        &#x2F;&#x2F; 从预定源 URL 数组中随机选择一个预定源 URL</span><br><span class="line">        console.log(feedList)</span><br><span class="line">        const random &#x3D; Math.floor(Math.random() * feedList.length);</span><br><span class="line">        next(null, feedList[random]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 【任务三】向选定的预定源发送 HTTP 请求以获取数据</span><br><span class="line">function downloadRSSFeed(feedUrl) &#123;</span><br><span class="line">    request(&#123; uri: feedUrl &#125;, (err, res, body) &#x3D;&gt; &#123;</span><br><span class="line">        if (err) return next(err);</span><br><span class="line">        if (res.statusCode !&#x3D;&#x3D; 200)</span><br><span class="line">            return next(new Error(&#39;Abnormal response status code&#39;));</span><br><span class="line">        next(null, body);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 【任务四】将预定源数据解析到一个条目数组中</span><br><span class="line">function parseRSSFeed(rss) &#123;</span><br><span class="line">    const handler &#x3D; new htmlparser.RssHandler();</span><br><span class="line">    const parser &#x3D; new htmlparser.Parser(handler);</span><br><span class="line">    parser.parseComplete(rss);</span><br><span class="line">    if (!handler.dom.items.length)</span><br><span class="line">        return next(new Error(&#39;No RSS items found&#39;));</span><br><span class="line">    &#x2F;&#x2F; 如果有数据，显示第一个预定源条目的标题和 URL</span><br><span class="line">    const item &#x3D; handler.dom.items.shift();</span><br><span class="line">    console.log(item.title);</span><br><span class="line">    console.log(item.link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 把所有要做的任务按执行顺序添加到一个数组中</span><br><span class="line">const tasks &#x3D; [</span><br><span class="line">    checkForRSSFile,</span><br><span class="line">    readRSSFile,</span><br><span class="line">    downloadRSSFeed,</span><br><span class="line">    parseRSSFeed,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 负责执行任务的 next 函数</span><br><span class="line">function next(err, result) &#123;</span><br><span class="line">    if (err) throw err; &#x2F;&#x2F; 如果任务出错，则中断程序，抛出异常。</span><br><span class="line">    &#x2F;&#x2F; shift()：把数组的第一个元素从其中删除，并返回第一个元素的值。</span><br><span class="line">    const currentTask &#x3D; tasks.shift(); &#x2F;&#x2F; 从任务数组中取出下一个任务。</span><br><span class="line">    if (currentTask) &#123;</span><br><span class="line">        currentTask(result); &#x2F;&#x2F; 执行当前任务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next(); &#x2F;&#x2F; 开始任务的串行化执行。</span><br></pre></td></tr></table></figure>
<p>然后在终端输入<code>node index.js</code>指令，我们可以看到输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![CDATA[Changes to Release Schedule]]</span><br><span class="line">https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;blog&#x2F;announcements&#x2F;adjusted-release-schedule-covid</span><br></pre></td></tr></table></figure>
<h2 id="实现并行化流程控制"><a href="#实现并行化流程控制" class="headerlink" title="实现并行化流程控制"></a>实现并行化流程控制</h2><p>原理：<br>为了让异步任务并行执行，仍然是要把任务放到<strong>数组</strong>中，但任务的<strong>存放顺序无关紧要</strong>。每个任务都应该调用处理器函数增加已完成任务的计数值。当<strong>所有任务都完成</strong>后，处理器函数<strong>应该执行后续的逻辑</strong>。</p>
<h3 id="并行化流程控制的实例"><a href="#并行化流程控制的实例" class="headerlink" title="并行化流程控制的实例"></a>并行化流程控制的实例</h3><p>实例程序的功能： 读取几个文本文件的内容，并输出单词在整个文件中出现的次数。</p>
<p>同样先初始化项目,新建另一个项目，打开终端，输入如下命令行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>
<p>建立如下的目录结构：<br><img src="/2020/04/06/Node%E7%9A%84%E4%B8%B2%E8%A1%8C%E5%8C%96%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%8C%96%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/project.png" alt="project.png"><br><code>1.txt</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">how many offers do you have</span><br></pre></td></tr></table></figure>
<p>2.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i have no offer</span><br></pre></td></tr></table></figure>
<p><code>word_count.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">const tasks &#x3D; [];</span><br><span class="line">const wordCounts &#x3D; &#123;&#125;;</span><br><span class="line">const filesDir &#x3D; &#39;.&#x2F;text&#39;;</span><br><span class="line">let completedTasks &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 检查并行任务是否完成</span><br><span class="line">function checkIfComplete() &#123;</span><br><span class="line">    completedTasks++;</span><br><span class="line">    if (completedTasks &#x3D;&#x3D;&#x3D; tasks.length) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当所有任务全部完成后，列出文件中用到的每个单词以及用了多少次。</span><br><span class="line">        for (let index in wordCounts) &#123;</span><br><span class="line">            console.log(&#96;$&#123;index&#125;: $&#123;wordCounts[index]&#125;&#96;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加单次计数次数</span><br><span class="line">function addWordCount(word) &#123;</span><br><span class="line">    wordCounts[word] &#x3D; (wordCounts[word]) ? wordCounts[word] + 1 : 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function countWordsInText(text) &#123;</span><br><span class="line">    const words &#x3D; text</span><br><span class="line">        .toString()</span><br><span class="line">        .toLowerCase()</span><br><span class="line">        .split(&#x2F;\W+&#x2F;)</span><br><span class="line">        .sort();</span><br><span class="line"></span><br><span class="line">    words</span><br><span class="line">        .filter(word &#x3D;&gt; word)</span><br><span class="line">        .forEach(word &#x3D;&gt; addWordCount(word)); &#x2F;&#x2F; 对文本中出现的单次计数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs.readdir(filesDir, (err, files) &#x3D;&gt; &#123; &#x2F;&#x2F;得出 text 目录中的文件列表</span><br><span class="line">    if (err) throw err;</span><br><span class="line"></span><br><span class="line">    files.forEach(file &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 定义处理每个文件的任务。</span><br><span class="line">        &#x2F;&#x2F; 每个任务中都会调用一个异步读取文件的函数并对文件中使用的单次计数。</span><br><span class="line">        &#x2F;&#x2F;是立即执行函数，获取filename</span><br><span class="line">        const task &#x3D; (file &#x3D;&gt; &#123;</span><br><span class="line">            return () &#x3D;&gt; &#123;</span><br><span class="line">                fs.readFile(file, (err, text) &#x3D;&gt; &#123;</span><br><span class="line">                    if (err) throw err;</span><br><span class="line">                    countWordsInText(text);</span><br><span class="line">                    checkIfComplete();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;)(&#96;$&#123;filesDir&#125;&#x2F;$&#123;file&#125;&#96;);</span><br><span class="line">        tasks.push(task); &#x2F;&#x2F; 把所有任务都添加到函数调用数组中。</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tasks.forEach(task &#x3D;&gt; task()); &#x2F;&#x2F; 开始并行执行所有任务。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>命令行输入<code>node word_count.js</code>,得到如下结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">have: 2</span><br><span class="line">i: 1</span><br><span class="line">no: 1</span><br><span class="line">offer: 1</span><br><span class="line">do: 1</span><br><span class="line">how: 1</span><br><span class="line">many: 1</span><br><span class="line">offers: 1</span><br><span class="line">you: 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>Node--Gulp基于流的自动化构建工具</title>
    <url>/2020/04/06/Node-Gulp%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="什么是Gulp"><a href="#什么是Gulp" class="headerlink" title="什么是Gulp"></a>什么是Gulp</h2><p><strong>一个服务于前端的管道式构建系统</strong><br>Gulp是基于流的构建系统，我们可以通过对这些流的引导来创建构建过程，除了<strong>转译</strong>和<strong>缩码</strong>，还能做更多的事情。<br>它有这些优点：</p>
<ul>
<li>易于使用：通过代码优于配置的策略，Gulp让简单的任务更简单，复杂的任务可管理</li>
<li>构建快速： 利用Node.js流的威力，你可以快速的构建项目并减少频繁的IO操作。</li>
<li>插件高质： Gulp严格的插件指南确保插件如你期望的那样简洁高效地工作。</li>
<li>易于学习： 通过最少的API，掌握Gulp毫不费力。</li>
<li>高度重用： 主要归功于两项技术，<strong>使用插件和自定义构建任务</strong>。Gulp的过程是一个流，所以这些任务插件是可以一个接一个拼在一起的。</li>
</ul>
<h2 id="使用Gulp"><a href="#使用Gulp" class="headerlink" title="使用Gulp"></a>使用Gulp</h2><p>首先我们需要把Gulp添加到项目中，添加Gulp需要用<code>npm</code>安装<code>gulp-cli</code>和<code>gulp</code>两个包。下面这段代码中，全局安装<code>gulp-cli</code>，并创建一个带有Gulp开发依赖项的新node项目.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --g gulp-cli</span><br><span class="line">npm init -y</span><br><span class="line">npm i -save-dev gulp</span><br></pre></td></tr></table></figure>
<p>接着创建<code>gulpfile.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch gulpfile.js</span><br></pre></td></tr></table></figure>
<p><code>touch为linux指令</code><br>我们用Gulp构建一个小型的React项目，我们会用到<code>gulp-babel</code>、<code>gulp-sourcemaps</code>和<code>gulp-concat</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i --save-dev gulp-sourcemaps gulp-babel babel-preset-es2015</span><br><span class="line">npm i --save-dev gulp-concat react react-dom babel-preset-react</span><br></pre></td></tr></table></figure>
<p>这里注意的是，安装<code>gulp-babel</code>的时候要安装7版本的，后续还要安装<code>babel-core</code>。如果直接安装，是安装8版本，<code>babel-core</code>是7，就会出错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i gulp-babel@7 babel-core --save-dev</span><br></pre></td></tr></table></figure>

<p>这其中<code>sourcemap</code>的作用着重讲一下<br>sourcemap解决的问题：当我们使用webpack打包代码出错时，如果不用sourcemap，我们只能知道<strong>打包后的代码第几行出错</strong>，并不知道<strong>对应的源代码错在哪里</strong>，所以source的作用是做一个<strong>源代码和目标代码的映射</strong>，即可以通过打包后的（目标）代码错在哪里<strong>定位到错误的源代码的位置</strong></p>
<h2 id="Gulp任务的创建及运行"><a href="#Gulp任务的创建及运行" class="headerlink" title="Gulp任务的创建及运行"></a>Gulp任务的创建及运行</h2><p>创建Gulp任务需要在<code>gulpfile.js</code>中编写Node代码，调用Gulp的API。Gulp的API可以做很多的事情，比如查找文件，把文件进行某种转换的插件频道一起等。</p>
<p>打开<code>gulpfile.js</code>设置一个构建任务，用<code>gulp.src</code>查找JSX文件，用<code>babel</code>处理ES6和React,然后把这些文件拼到一起。</p>
<p><code>gulpfile.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const gulp&#x3D;require(&#39;gulp&#39;);</span><br><span class="line">const sourcemaps&#x3D;require(&#39;gulp-sourcemaps&#39;);</span><br><span class="line">const babel&#x3D;require(&#39;gulp-babel&#39;);</span><br><span class="line">const concat&#x3D;require(&#39;gulp-concat&#39;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#39;default&#39;,()&#x3D;&gt;&#123;</span><br><span class="line">    return gulp.src(&#39;app&#x2F;*.jsx&#39;)</span><br><span class="line">        .pipe(sourcemaps.init())</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets:[&#39;es2015&#39;,&#39;react&#39;]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(concat(&#39;all.js&#39;))</span><br><span class="line">        .pipe(sourcemaps.write(&#39;.&#39;))</span><br><span class="line">        .pipe(gulp.dest(&#39;dist&#39;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://www.gulpjs.com.cn/docs/api/src/" target="_blank" rel="noopener">gulp.src()</a>: Gulp自带的文件聚集工具，查找app目录下所有的React jsx文件。</li>
<li>sourcemaps.init()： 开始监控源文件，为调试构建源码映射</li>
<li>concat(‘all.js’):把所有源码文件拼到一个all.js中</li>
<li>sourcemaps.write(‘.’): 单独写入源码映射文件</li>
<li>gulp.dest(‘dist’): 将所有文件放到dist/目录下</li>
<li>那些babel插件是在把源码拼到到一个all.js文件之前，加一个管道，添加一些babel插件做一些处理，例如ES6转ES5</li>
</ul>
<p>然后在终端运行<code>gulp</code>，我们会看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[21:13:00] Using gulpfile D:\Node_learn\test_Gulp\gulpfile.js</span><br><span class="line">[21:13:00] Starting &#39;default&#39;...</span><br><span class="line">[21:13:02] Finished &#39;default&#39; after 1.82 s</span><br></pre></td></tr></table></figure>
<p>gulp构建完成之后我们会看到我们的项目结构多了dist目录，dist目录下多了<code>all.js</code>和<code>all.js.map</code>文件标识构建成功</p>
<p>all.js文件的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">var _react &#x3D; require(&#39;react&#39;);</span><br><span class="line"></span><br><span class="line">var _react2 &#x3D; _interopRequireDefault(_react);</span><br><span class="line"></span><br><span class="line">var _reactDom &#x3D; require(&#39;react-dom&#39;);</span><br><span class="line"></span><br><span class="line">var _reactDom2 &#x3D; _interopRequireDefault(_reactDom);</span><br><span class="line"></span><br><span class="line">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(_react2.default.createElement(</span><br><span class="line">    &#39;h1&#39;,</span><br><span class="line">    null,</span><br><span class="line">    &#39;Hello,world&#39;</span><br><span class="line">), document.getElementById(&#39;example&#39;));</span><br><span class="line">&#x2F;&#x2F;# sourceMappingURL&#x3D;all.js.map</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Gulp中，用JavaScript表示构建阶段很容易。并且我们可以用gulp.task()往这个文件里添加自己的任务。这些任务通常都遵循相同的模式。</p>
<ul>
<li>源文件： 收集输入文件，<code>gulp.src()</code></li>
<li>转译： 让他们依次通过一个个对他们继续进行转换的插件，例如babel插件，这转译是发生在合并之前的，这合并的pipe之前增加这些插件的pipe</li>
<li>合并： 把这些文件合到一起，创建一个整体构建文件</li>
<li>输出： 设定文件的目标地址或移动输出文件</li>
</ul>
<p>前面那个例子中，<code>sourcemaps</code>是个特例，因为它需要两次<code>pipe</code>：第一次是配置，最后一次是输出文件</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://delaprada.com/2020/04/03/Node%E2%80%94%E2%80%94Gulp%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/#more" target="_blank" rel="noopener">https://delaprada.com/2020/04/03/Node%E2%80%94%E2%80%94Gulp%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/#more</a></p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟DOM的解读</title>
    <url>/2020/04/06/%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道virtual DOM的作用是为了避免直接操作DOM，因为直接操作DOM是一件<strong>很费性能的事情</strong>，但是虚拟DOM最后要渲染成真实的DOM，也是需要采用DOM操作的，那性能优化，优化在哪里？</p>
<h2 id="Virtual-DOM原理"><a href="#Virtual-DOM原理" class="headerlink" title="Virtual DOM原理"></a>Virtual DOM原理</h2><ul>
<li>用JS对象来模拟DOM对象<br>我们知道相比于DOM对象，原生的JS对象操作起来会更简单，DOM节点的一些信息，我们都可以用JS对象来变现出来<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var element &#x3D; &#123;</span><br><span class="line">  tagName: &#39;ul&#39;, &#x2F;&#x2F; 节点标签名</span><br><span class="line">  props: &#123; &#x2F;&#x2F; DOM的属性，用一个对象存储键值对</span><br><span class="line">    id: &#39;list&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ &#x2F;&#x2F; 该节点的子节点</span><br><span class="line">    &#123;tagName: &#39;li&#39;, props: &#123;class: &#39;item&#39;&#125;, children: [&quot;Item 1&quot;]&#125;,</span><br><span class="line">    &#123;tagName: &#39;li&#39;, props: &#123;class: &#39;item&#39;&#125;, children: [&quot;Item 2&quot;]&#125;,</span><br><span class="line">    &#123;tagName: &#39;li&#39;, props: &#123;class: &#39;item&#39;&#125;, children: [&quot;Item 3&quot;]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上面对应的HTML结构是：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&#39;list&#39;&gt;</span><br><span class="line">  &lt;li class&#x3D;&#39;item&#39;&gt;Item 1&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li class&#x3D;&#39;item&#39;&gt;Item 2&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li class&#x3D;&#39;item&#39;&gt;Item 3&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
既然DOM节点可以用JS对象来表示，那么一整个DOM树，当然也可以用JS对象来表示。  </li>
</ul>
<p>JS对象模拟DOM对象的一个简单的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class Element &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * @param &#123;String&#125; tag &#39;div&#39;</span><br><span class="line">   * @param &#123;Object&#125; props &#123; class: &#39;item&#39; &#125;</span><br><span class="line">   * @param &#123;Array&#125; children [ Element1, &#39;text&#39;]</span><br><span class="line">   * @param &#123;String&#125; key option</span><br><span class="line">   *&#x2F;</span><br><span class="line">  constructor(tag, props, children, key) &#123;</span><br><span class="line">    this.tag &#x3D; tag</span><br><span class="line">    this.props &#x3D; props</span><br><span class="line">    if (Array.isArray(children)) &#123;</span><br><span class="line">      this.children &#x3D; children</span><br><span class="line">    &#125; else if (isString(children)) &#123;</span><br><span class="line">      this.key &#x3D; children</span><br><span class="line">      this.children &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">    if (key) this.key &#x3D; key</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 渲染</span><br><span class="line">  render() &#123;</span><br><span class="line">      &#x2F;&#x2F;渲染其实就是DOM操作构建节点</span><br><span class="line">    let root &#x3D; this._createElement(</span><br><span class="line">      this.tag,</span><br><span class="line">      this.props,</span><br><span class="line">      this.children,</span><br><span class="line">      this.key</span><br><span class="line">    )</span><br><span class="line">    document.body.appendChild(root)</span><br><span class="line">    return root</span><br><span class="line">  &#125;</span><br><span class="line">  create() &#123;</span><br><span class="line">    return this._createElement(this.tag, this.props, this.children, this.key)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 创建节点</span><br><span class="line">  _createElement(tag, props, child, key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 通过 tag 创建节点</span><br><span class="line">    let el &#x3D; document.createElement(tag)</span><br><span class="line">    &#x2F;&#x2F; 设置节点属性</span><br><span class="line">    for (const key in props) &#123;</span><br><span class="line">      if (props.hasOwnProperty(key)) &#123;</span><br><span class="line">        const value &#x3D; props[key]</span><br><span class="line">        el.setAttribute(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">      el.setAttribute(&#39;key&#39;, key)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 递归添加子节点</span><br><span class="line">    if (child) &#123;</span><br><span class="line">      child.forEach(element &#x3D;&gt; &#123;</span><br><span class="line">        let child</span><br><span class="line">        if (element instanceof Element) &#123;</span><br><span class="line">          child &#x3D; this._createElement(</span><br><span class="line">            element.tag,</span><br><span class="line">            element.props,</span><br><span class="line">            element.children,</span><br><span class="line">            element.key</span><br><span class="line">          )</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          child &#x3D; document.createTextNode(element)</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Virtual Dom算法<br>用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实<strong>只变更有不同的地方</strong>。这就是Virtual DOM算法的本质，只渲染差异，那我们就要<strong>找出差异</strong>。<br>DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异<br>实现 O(n) 复杂度的关键就是<strong>只对比同层的节点，而不是跨层对比，</strong>这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。<br>所以判断差异的算法就分为了两步：</li>
<li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中<strong>会给每个节点添加索引，便于最后渲染差异</strong></li>
<li>一旦节点有子元素，就去判断子元素是否有不同</li>
</ul>
<h2 id="virtual-DOM算法的实现"><a href="#virtual-DOM算法的实现" class="headerlink" title="virtual DOM算法的实现"></a>virtual DOM算法的实现</h2><h3 id="树的递归"><a href="#树的递归" class="headerlink" title="树的递归"></a>树的递归</h3><p>我们在比对DOM树差异的时候，是会用到树的递归的，在我们实现之前，先考虑好两个节点之间的对比会有哪些情况  </p>
<ul>
<li>新的节点的<code>tagname</code>或者<code>key</code>与旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了。举个栗子，把<code>&lt;ul&gt;</code>换成了<code>&lt;ol&gt;</code>整个节点都换掉了，不需要考虑子节点。</li>
<li>新的节点的<code>tagName</code> 和 <code>key</code> (可能都没有）和旧的相同，开始遍历子树</li>
<li>没有新的节点，那么什么都不用做<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; StateEnums, isString, move &#125; from &#39;.&#x2F;util&#39;</span><br><span class="line">import Element from &#39;.&#x2F;element&#39;</span><br><span class="line"></span><br><span class="line">export default function diff(oldDomTree, newDomTree) &#123;</span><br><span class="line">  &#x2F;&#x2F; 用于记录差异</span><br><span class="line">  let pathchs &#x3D; &#123;&#125;</span><br><span class="line">  &#x2F;&#x2F; 一开始的索引为 0</span><br><span class="line">  dfs(oldDomTree, newDomTree, 0, pathchs)</span><br><span class="line">  return pathchs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dfs(oldNode, newNode, index, patches) &#123;</span><br><span class="line">  &#x2F;&#x2F; 用于保存子树的更改</span><br><span class="line">  let curPatches &#x3D; []</span><br><span class="line">  &#x2F;&#x2F; 需要判断三种情况</span><br><span class="line">  &#x2F;&#x2F; 1.没有新的节点，那么什么都不用做</span><br><span class="line">  &#x2F;&#x2F; 2.新的节点的 tagName 和 &#96;key&#96; 和旧的不同，就替换</span><br><span class="line">  &#x2F;&#x2F; 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树</span><br><span class="line">  if (!newNode) &#123;</span><br><span class="line">  &#125; else if (newNode.tag &#x3D;&#x3D;&#x3D; oldNode.tag &amp;&amp; newNode.key &#x3D;&#x3D;&#x3D; oldNode.key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断属性是否变更</span><br><span class="line">    let props &#x3D; diffProps(oldNode.props, newNode.props)</span><br><span class="line">    if (props.length) curPatches.push(&#123; type: StateEnums.ChangeProps, props &#125;)</span><br><span class="line">    &#x2F;&#x2F; 遍历子树</span><br><span class="line">    diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 节点不同，需要替换</span><br><span class="line">    curPatches.push(&#123; type: StateEnums.Replace, node: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (curPatches.length) &#123;</span><br><span class="line">    if (patches[index]) &#123;</span><br><span class="line">      patches[index] &#x3D; patches[index].concat(curPatches)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      patches[index] &#x3D; curPatches</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="判断属性更改"><a href="#判断属性更改" class="headerlink" title="判断属性更改"></a>判断属性更改</h3><p>判断属性更改也分为三个步骤</p>
<ul>
<li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li>
<li>遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化</li>
<li>在第二步中同时查看是否有属性不存在与旧的属性列列表中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function diffProps(oldProps, newProps) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断 Props 分以下三步骤</span><br><span class="line">  &#x2F;&#x2F; 先遍历 oldProps 查看是否存在删除的属性</span><br><span class="line">  &#x2F;&#x2F; 然后遍历 newProps 查看是否有属性值被修改</span><br><span class="line">  &#x2F;&#x2F; 最后查看是否有属性新增</span><br><span class="line">  let change &#x3D; []</span><br><span class="line">  for (const key in oldProps) &#123;</span><br><span class="line">    if (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) &#123;</span><br><span class="line">      change.push(&#123;</span><br><span class="line">        prop: key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (const key in newProps) &#123;</span><br><span class="line">    if (newProps.hasOwnProperty(key)) &#123;</span><br><span class="line">      const prop &#x3D; newProps[key]</span><br><span class="line">      if (oldProps[key] &amp;&amp; oldProps[key] !&#x3D;&#x3D; newProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else if (!oldProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return change</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断列表差异算法实现"><a href="#判断列表差异算法实现" class="headerlink" title="判断列表差异算法实现"></a>判断列表差异算法实现</h3>这里的步骤其实跟判断属性差异类似的，也是分为三步。</li>
<li>遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</li>
<li>遍历新的节点列表，判断是否有新的节点</li>
<li>在第二步中同时判断节点是否有移动<br><code>ps:该算法只对有key的节点做处理</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function listDiff(oldList, newList, index, patches) &#123;</span><br><span class="line">  &#x2F;&#x2F; 为了遍历方便，先取出两个 list 的所有 keys</span><br><span class="line">  let oldKeys &#x3D; getKeys(oldList)</span><br><span class="line">  let newKeys &#x3D; getKeys(newList)</span><br><span class="line">  let changes &#x3D; []</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 用于保存变更后的节点数据</span><br><span class="line">  &#x2F;&#x2F; 使用该数组保存有以下好处</span><br><span class="line">  &#x2F;&#x2F; 1.可以正确获得被删除节点索引</span><br><span class="line">  &#x2F;&#x2F; 2.交换节点位置只需要操作一遍 DOM</span><br><span class="line">  &#x2F;&#x2F; 3.用于 &#96;diffChildren&#96; 函数中的判断，只需要遍历</span><br><span class="line">  &#x2F;&#x2F; 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要</span><br><span class="line">  &#x2F;&#x2F; 再去判断一遍</span><br><span class="line">  let list &#x3D; []</span><br><span class="line">  oldList &amp;&amp;</span><br><span class="line">    oldList.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">      let key &#x3D; item.key</span><br><span class="line">      if (isString(item)) &#123;</span><br><span class="line">        key &#x3D; item</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 寻找新的 children 中是否含有当前节点</span><br><span class="line">      &#x2F;&#x2F; 没有的话需要删除</span><br><span class="line">      let index &#x3D; newKeys.indexOf(key)</span><br><span class="line">      if (index &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">        list.push(null)</span><br><span class="line">      &#125; else list.push(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#x2F;&#x2F; 遍历变更后的数组</span><br><span class="line">  let length &#x3D; list.length</span><br><span class="line">  &#x2F;&#x2F; 因为删除数组元素是会更改索引的</span><br><span class="line">  &#x2F;&#x2F; 所有从后往前删可以保证索引不变</span><br><span class="line">  for (let i &#x3D; length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断当前元素是否为空，为空表示需要删除</span><br><span class="line">    if (!list[i]) &#123;</span><br><span class="line">      list.splice(i, 1)</span><br><span class="line">      changes.push(&#123;</span><br><span class="line">        type: StateEnums.Remove,</span><br><span class="line">        index: i</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 遍历新的 list，判断是否有节点新增或移动</span><br><span class="line">  &#x2F;&#x2F; 同时也对 &#96;list&#96; 做节点新增和移动节点的操作</span><br><span class="line">  newList &amp;&amp;</span><br><span class="line">    newList.forEach((item, i) &#x3D;&gt; &#123;</span><br><span class="line">      let key &#x3D; item.key</span><br><span class="line">      if (isString(item)) &#123;</span><br><span class="line">        key &#x3D; item</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 寻找旧的 children 中是否含有当前节点</span><br><span class="line">      let index &#x3D; list.indexOf(key)</span><br><span class="line">      &#x2F;&#x2F; 没找到代表新节点，需要插入</span><br><span class="line">      if (index &#x3D;&#x3D;&#x3D; -1 || key &#x3D;&#x3D; null) &#123;</span><br><span class="line">        changes.push(&#123;</span><br><span class="line">          type: StateEnums.Insert,</span><br><span class="line">          node: item,</span><br><span class="line">          index: i</span><br><span class="line">        &#125;)</span><br><span class="line">        list.splice(i, 0, key)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 找到了，需要判断是否需要移动</span><br><span class="line">        if (index !&#x3D;&#x3D; i) &#123;</span><br><span class="line">          changes.push(&#123;</span><br><span class="line">            type: StateEnums.Move,</span><br><span class="line">            from: index,</span><br><span class="line">            to: i</span><br><span class="line">          &#125;)</span><br><span class="line">          move(list, index, i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  return &#123; changes, list &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getKeys(list) &#123;</span><br><span class="line">  let keys &#x3D; []</span><br><span class="line">  let text</span><br><span class="line">  list &amp;&amp;</span><br><span class="line">    list.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">      let key</span><br><span class="line">      if (isString(item)) &#123;</span><br><span class="line">        key &#x3D; [item]</span><br><span class="line">      &#125; else if (item instanceof Element) &#123;</span><br><span class="line">        key &#x3D; item.key</span><br><span class="line">      &#125;</span><br><span class="line">      keys.push(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  return keys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历子元素打标识"><a href="#遍历子元素打标识" class="headerlink" title="遍历子元素打标识"></a>遍历子元素打标识</h3>对于这个函数来说，主要功能就两个</li>
<li>判断两个列表差异，也就是用到上面的listDIff算法</li>
<li>给节点打上标记<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function diffChildren(oldChild, newChild, index, patches) &#123;</span><br><span class="line">  let &#123; changes, list &#125; &#x3D; listDiff(oldChild, newChild, index, patches)</span><br><span class="line">  if (changes.length) &#123;</span><br><span class="line">    if (patches[index]) &#123;</span><br><span class="line">      patches[index] &#x3D; patches[index].concat(changes)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      patches[index] &#x3D; changes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 记录上一个遍历过的节点</span><br><span class="line">  let last &#x3D; null</span><br><span class="line">  oldChild &amp;&amp;</span><br><span class="line">    oldChild.forEach((item, i) &#x3D;&gt; &#123;</span><br><span class="line">      let child &#x3D; item &amp;&amp; item.children</span><br><span class="line">      if (child) &#123;</span><br><span class="line">        index &#x3D;</span><br><span class="line">          last &amp;&amp; last.children ? index + last.children.length + 1 : index + 1</span><br><span class="line">        let keyIndex &#x3D; list.indexOf(item.key)</span><br><span class="line">        let node &#x3D; newChild[keyIndex]</span><br><span class="line">        &#x2F;&#x2F; 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历</span><br><span class="line">        if (node) &#123;</span><br><span class="line">          dfs(item, node, index, patches)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else index +&#x3D; 1</span><br><span class="line">      last &#x3D; item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="渲染差异"><a href="#渲染差异" class="headerlink" title="渲染差异"></a>渲染差异</h3>通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤</li>
</ul>
<p>这个函数的主要两个功能</p>
<ul>
<li>深度遍历树，将需要做变更的操作取出来</li>
<li>局部更新DOM<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let index &#x3D; 0</span><br><span class="line">export default function patch(node, patchs) &#123;</span><br><span class="line">  let changes &#x3D; patchs[index]</span><br><span class="line">  let childNodes &#x3D; node &amp;&amp; node.childNodes</span><br><span class="line">  &#x2F;&#x2F; 这里的深度遍历和 diff 中是一样的</span><br><span class="line">  if (!childNodes) index +&#x3D; 1</span><br><span class="line">  if (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) &#123;</span><br><span class="line">    changeDom(node, changes)</span><br><span class="line">  &#125;</span><br><span class="line">  let last &#x3D; null</span><br><span class="line">  if (childNodes &amp;&amp; childNodes.length) &#123;</span><br><span class="line">    childNodes.forEach((item, i) &#x3D;&gt; &#123;</span><br><span class="line">      index &#x3D;</span><br><span class="line">        last &amp;&amp; last.children ? index + last.children.length + 1 : index + 1</span><br><span class="line">      patch(item, patchs)</span><br><span class="line">      last &#x3D; item</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function changeDom(node, changes, noChild) &#123;</span><br><span class="line">  changes &amp;&amp;</span><br><span class="line">    changes.forEach(change &#x3D;&gt; &#123;</span><br><span class="line">      let &#123; type &#125; &#x3D; change</span><br><span class="line">      switch (type) &#123;</span><br><span class="line">        case StateEnums.ChangeProps:</span><br><span class="line">          let &#123; props &#125; &#x3D; change</span><br><span class="line">          props.forEach(item &#x3D;&gt; &#123;</span><br><span class="line">            if (item.value) &#123;</span><br><span class="line">              node.setAttribute(item.prop, item.value)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              node.removeAttribute(item.prop)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          break</span><br><span class="line">        case StateEnums.Remove:</span><br><span class="line">          node.childNodes[change.index].remove()</span><br><span class="line">          break</span><br><span class="line">        case StateEnums.Insert:</span><br><span class="line">          let dom</span><br><span class="line">          if (isString(change.node)) &#123;</span><br><span class="line">            dom &#x3D; document.createTextNode(change.node)</span><br><span class="line">          &#125; else if (change.node instanceof Element) &#123;</span><br><span class="line">            dom &#x3D; change.node.create()</span><br><span class="line">          &#125;</span><br><span class="line">          node.insertBefore(dom, node.childNodes[change.index])</span><br><span class="line">          break</span><br><span class="line">        case StateEnums.Replace:</span><br><span class="line">          node.parentNode.replaceChild(change.node.create(), node)</span><br><span class="line">          break</span><br><span class="line">        case StateEnums.Move:</span><br><span class="line">          let fromNode &#x3D; node.childNodes[change.from]</span><br><span class="line">          let toNode &#x3D; node.childNodes[change.to]</span><br><span class="line">          let cloneFromNode &#x3D; fromNode.cloneNode(true)</span><br><span class="line">          let cloenToNode &#x3D; toNode.cloneNode(true)</span><br><span class="line">          node.replaceChild(cloneFromNode, toNode)</span><br><span class="line">          node.replaceChild(cloenToNode, fromNode)</span><br><span class="line">          break</span><br><span class="line">        default:</span><br><span class="line">          break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2>Virtual DOM算法的实现主要总结为三步</li>
<li>用JS对象来模拟DOM对象，构建出两个DOM树（新的和旧的）</li>
<li>通过DIFF算法，比对两棵树的差异</li>
<li>渲染差异</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let test4 &#x3D; new Element(&#39;div&#39;, &#123; class: &#39;my-div&#39; &#125;, [&#39;test4&#39;])</span><br><span class="line">let test5 &#x3D; new Element(&#39;ul&#39;, &#123; class: &#39;my-div&#39; &#125;, [&#39;test5&#39;])</span><br><span class="line"></span><br><span class="line">let test1 &#x3D; new Element(&#39;div&#39;, &#123; class: &#39;my-div&#39; &#125;, [test4])</span><br><span class="line"></span><br><span class="line">let test2 &#x3D; new Element(&#39;div&#39;, &#123; id: &#39;11&#39; &#125;, [test5, test4])</span><br><span class="line"></span><br><span class="line">let root &#x3D; test1.render()</span><br><span class="line"></span><br><span class="line">let pathchs &#x3D; diff(test1, test2)</span><br><span class="line">console.log(pathchs)</span><br><span class="line"></span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;开始更新&#39;)</span><br><span class="line">  patch(root, pathchs)&#x2F;&#x2F;渲染差异</span><br><span class="line">  console.log(&#39;结束更新&#39;)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure>

<p>优缺点：<br>优点：  </p>
<ul>
<li>很多DOM API的读写都涉及页面布局的“重新计算”，以确保返回值的准确，涉及样式、结构的还会触发<strong>页面“重新绘制”</strong>，更耗性能。<br>单次的<code>DOM API</code> 调用性能就不够好，频繁调用就会迅速积累上述损耗，导致 DOM 引擎占用主线程过久，用户操作不能及时触发 JS 事件回调，让用户感觉卡顿。</li>
<li>虚拟DOM实际上最终还是会调用DOM API，但它能够<strong>减少不必要的DOM API调用</strong>。虚拟DOM遵循“在JS中缓存必要数据，计算界面更新时的阶段数据差异，<strong>只提交最终差集</strong>”的基本思路。</li>
</ul>
<p>缺点： </p>
<ul>
<li>使用Js去模拟真实的DOM，会占用一定的内存</li>
<li>DIFF算法，会有额外的开销</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/search?type=content&amp;q=%E8%99%9A%E6%8B%9Fdom" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%E8%99%9A%E6%8B%9Fdom</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯云创建云函数以及部署</title>
    <url>/2020/04/03/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%88%9B%E5%BB%BA%E4%BA%91%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在做一个小程序项目，有些接口需要自己实现，作为前端开发人员，对服务器方面一窍不通，所以发现了腾讯云可以提供云开发和云函数(SCF)来实现一站式部署。<br>SCF简而言之，就是自己写好接口代码，放在腾讯云上，腾讯云暴露一个api给你使用。而我主要讲一下使用vscode创建云函数的过程。因为刚好代码之类的也是可以在vscode写的。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p><a href="https://cloud.tencent.com/document/product/583/37511" target="_blank" rel="noopener">详情可以参考官方文档vscode创建云函数</a></p>
<p>但是有几个有点模糊的点我补充一下。</p>
<ul>
<li>根据提示依次输入账号的 APPID，SecretId 及 SecretKey 信息，作为插件调用云 API 时的认证信息。这里的账号，是我们需要自己新建的角色<code>QCS_SCFExcuteRole</code>并且要进行权限的配置，然后才可以看到对应的APPID，SecretId 及 SecretKey</li>
<li>然后在vscode本地调试代码运行的时候，选择的是api网关模板</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>当我们vscode本地上传函数到云端时，我们会在自己的腾讯云函数服务控制台看到我们上传的函数，但是有些地方需要做一些更改。<br>在SCF控制台（云函数控制台），点击我们创建的云函数，点击触发方式，点击api服务名，跳转到<code>api网关服务控制台</code>，选择管理API，点击编辑操作，在前端配置栏<strong>开启CORS</strong>,解决后面调用窗口的<strong>跨域问题</strong>。<br><img src="/2020/04/03/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%88%9B%E5%BB%BA%E4%BA%91%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2/cors.png" alt="cors.png"><br>然后完成后续配置操作之后，我们需要把api再<strong>发布一次，发布一次，发布一次</strong>，然后api便可以正常访问了。<br><img src="/2020/04/03/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%88%9B%E5%BB%BA%E4%BA%91%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2/release.png" alt="release.png"> </p>
]]></content>
      <categories>
        <category>小程序、腾讯云</category>
      </categories>
      <tags>
        <tag>小程序、腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器安全方面的</title>
    <url>/2020/03/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%E7%9A%84/</url>
    <content><![CDATA[<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p>XSS攻击的全称是跨站脚本攻击，通过注入恶意的JavaScript代码进行攻击。</p>
<p>分类：按时间来划分的话，可以分为持久型和非持久型。按照类型的话可以分为DOM型，反射型和存储型</p>
<ul>
<li>DOM-Based型：属于非持久型的XSS攻击，不需要服务端的参与，主要是因为一些前端代码的漏洞导致的，DOM 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover</code>等，<code>a</code> 标签的 <code>href</code> 属性，img 的 <code>src</code>，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，<strong>都能把字符串作为代码运行</strong>，拼接数据时需要注意。<code>innerHTML，outerHTML，document.write</code>与用户输入有关联时需要注意</li>
</ul>
<ul>
<li>反射型： 也属于非持久型的XSS，需要经过服务器，但是不经过数据库。当用户打开带有恶意代码的URL，网站服务端将恶意代码从URL中取出，拼接再HTML中返回给浏览器。常见于网站搜索，跳转等等</li>
</ul>
<ul>
<li>存储型：属于持久型XSS，需要经过服务器和数据库。当用户将恶意代码提交到了<strong>目标数据库</strong>，下次用户打开网站时，网站服务端把恶意代码从数据库取出，拼接再HTML中返回给浏览器。常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信。（基本都是表单类的）</li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>关于cookie和session的深究</title>
    <url>/2020/03/16/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E6%B7%B1%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接二连三受挫，想做一篇总结篇吧。  </p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><h3 id="cookie是客户端保持状态的方案，session是服务端保持状态的方案"><a href="#cookie是客户端保持状态的方案，session是服务端保持状态的方案" class="headerlink" title="cookie是客户端保持状态的方案，session是服务端保持状态的方案"></a>cookie是客户端保持状态的方案，session是服务端保持状态的方案</h3><p>cookie是服务器在本地机器上存储的小段文本并随着每一个请求发送至同一个服务器。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。<br>也就是说，cookie是服务端生成的，通过HTTP响应头向客户端发送，客户端浏览器解析拿到这个cookie，会保存为一个本地文件，并在后面与这一台服务器发送的任何请求，都会携带这个cookie。</p>
<p>那为什么要携带这个cookie呢，因为cookie的作用就是为了解决HTTP协议无状态的缺陷所作的努力。cookie的内容主要包括：名字，值，过期时间，路径和域。<strong>(可以理解成键值对，外加一些其他的属性)</strong>一般用户的敏感信息就会存在value字段。每次请求携带cookie相当于客户端在告诉服务器，现在是谁谁谁和你通信.所以说，<strong>cookie是客户端保持状态的方案</strong><br><img src="/2020/03/16/%E5%85%B3%E4%BA%8Ecookie%E5%92%8Csession%E7%9A%84%E6%B7%B1%E7%A9%B6/cookie.png" alt="cookie.png"><br>图一、   cookie的一些属性<br>cookie又分为两种：</p>
<ul>
<li><p>会话cookie：不设置过期时间，只要关闭浏览器，就会消失。生命周期是浏览器会话期间，一般保存在内存上</p>
</li>
<li><p>持久性cookie：设置过期时间，<strong>会保存在用户硬盘上</strong>，同一浏览器可以访问，直到到了过期时间</p>
</li>
</ul>
<p>既然cookie是服务端生成的，那怎么生成呢？<br>服务器通过在HTTP的响应头(第一次访问网站服务器的reponse头)中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie<br>服务端那边写代码给HTTP响应头加入<code>set-Cookie</code>字段（cookie其实跟键值对差不多)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;HTTP响应头</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-type: text&#x2F;html</span><br><span class="line">Set-Cookie: foo&#x3D;10</span><br><span class="line">Set-Cookie: bar&#x3D;20; Expires&#x3D;Fri, 30 Sep 2011 11:48:00 GMT</span><br><span class="line">... rest  of the response</span><br></pre></td></tr></table></figure>
<p>这里两个cookie foo = 10和bar = 20被存储在浏览器中。第二个将在9月30日到期。在随后的每个请求中，浏览器都会将cookie发送回服务器。</p>
<p>后面浏览器给服务器发送的请求的时候，请求头(会携带上cookie)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;spec.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Cookie: foo&#x3D;10; bar&#x3D;20</span><br><span class="line">Accept: *&#x2F;*</span><br></pre></td></tr></table></figure>

<p>那客户端浏览器可以生成cookie嘛？<br>答案是可以的。我们可以在chrome的控制台上，加入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie &#x3D; &#39;age &#x3D;18;max-age&#x3D;1000&#39;</span><br></pre></td></tr></table></figure>
<p>然后你就可以看到cookie选项多了个<code>age=18</code>的cookie。然后这个cookie的长度，或者说size就是字符串’age18’的length，为5.其实还是挺符合定义，cookie是服务器存在本地机器上的<strong>一小段文本</strong><br>那前端既然可以用JavaScript创建cookie，那怎么清除掉呢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delCookies(name)&#123;</span><br><span class="line"></span><br><span class="line">var exp &#x3D; new Date();</span><br><span class="line"></span><br><span class="line">exp.setTime(exp.getTime() - 1);</span><br><span class="line"></span><br><span class="line">var cval &#x3D; this.getCookie(name);</span><br><span class="line"></span><br><span class="line">if(cval !&#x3D; null)&#123;</span><br><span class="line"></span><br><span class="line">document.cookie &#x3D; name + &quot;&#x3D;&quot; +cval + &quot;;expires&#x3D;&quot; + exp.toGMTString()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于session<br>session是一种保持上下文信息的机制，它是针对每一个用户的，变量的值保存在服务端，通过sessionid来区分不同的用户，session是以<code>cookie或url重写</code>为基础的.<br>也就是这个sessionid是保存在客户端的，那用什么方法传给客户端呢，一种是通过cookie，顾名思义把sessionid写在cookie里面（然后通过请求携带cookie可以把用户的sessionid告诉给服务器）<br>如果浏览器禁止cookie的话，我们可以通过url重写，就是把sessionid写在url路径的后面。这样可以，那这样服务器就可以解析url地址拿到用户的sessionid</p>
<p>session的工作原理：<br>client———&gt;1.request————————-&gt;server<br>          2. session_start();<br>   |&lt;————-3.reponse(SESSION_ID)&lt;——–|<br>   |————-&gt;4.request(SESSION_ID)———&gt;|<br>                       5. session_start();<br>   |&lt;————-6.reponse(SESSION_ID)&lt;———|<br>   |————-&gt;7. request(SESSION_ID + logout)–&gt;|<br>                      8. session_destroy();<br>   |&lt;————-9. reponse(删除cookie文件)&lt;——-|<br>具体的流程：  </p>
<p>1.client打开网页，向server发出请求，client上由于没有相应的cookie文件存在，在请求中不输送SESSION_ID<br>2.服务器在接受到client的请求后，通过执行session_start()函数开始进行session的处理， 首先确认请求中有没有SESSION_ID，如果没有的话，发行一个新的SESSION_ID；如果有的话， 则调用那个存有SESSION_ID的文件，并把信息写入$_SESSION里去，并存入以sess_开头的文件里。<br>把写入信息的$_SESSION参数发回给client，client在GET服务器发来的信息后，把这些信息保存在cookie里。<br>3.client把cookie里的SESSION_ID一起写入header后再次向server发出请求。重复1-3的操作<br>4.client发出登出请求<br>5.服务器接受请求后，通过执行session_destroy()函数开始删除session文件处理<br>服务器向client发出删除保存在client上的cookie文件的命令:   setcookie(session_name(), ”, time()-60, ‘/’);  </p>
<p>看到上面的原理之后，我们会明白session其实一般情况下是不可以跨窗口使用的，但是我们可以通过把session放在持久性的cookie里，也就是给cookie加一个过期时间，然后我们可以在新窗口读取这个cookie实现跨窗口的使用。</p>
<h3 id="隐私策略不同"><a href="#隐私策略不同" class="headerlink" title="隐私策略不同"></a>隐私策略不同</h3><p>Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。</p>
<h3 id="服务器的压力不同"><a href="#服务器的压力不同" class="headerlink" title="服务器的压力不同"></a>服务器的压力不同</h3><p>Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。<br>而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。</p>
<h3 id="跨域支持上不同"><a href="#跨域支持上不同" class="headerlink" title="跨域支持上不同"></a>跨域支持上不同</h3><p>Cookie支持跨域名访问，例如将cookie的<code>domain</code>属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。</p>
<h3 id="存取方式的不同"><a href="#存取方式的不同" class="headerlink" title="存取方式的不同"></a>存取方式的不同</h3><p>Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象<br>而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。</p>
<h3 id="关于二者的使用场景"><a href="#关于二者的使用场景" class="headerlink" title="关于二者的使用场景"></a>关于二者的使用场景</h3><p>   cookie应用场景：①判断用户是否登录过网站； ②用来记录购物车或者记录用户使用偏好来制定推送(记录用户的行为)；<br>    session应用场景：①登录验证信息</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/zhuwei1035838807/article/details/79752683?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">关于Session的使用场景案例</a>  </p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>promise解决请求延迟的问题</title>
    <url>/2020/03/05/promise%E8%A7%A3%E5%86%B3%E8%AF%B7%E6%B1%82%E5%BB%B6%E8%BF%9F%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>利用Promise实现数据多个请求加载完成时执行某个方法<br>在实际开发中常常有些业务的数据是来自多个接口的，因为ajax是异步，这样就导致我们需要判断是否请求到了数据然后在做其他的逻辑，在Promise没有出现之前，通常我们的解决方法是，第一粗暴的改异步为同步，但这样会造成阻塞，异步好像又失去了意义，第二也就是大家常用的解决办法用回调既一个异步执行完成后在执行下一个请求，这样看比第一种要好太多了，但是问题又来了，延迟延迟延迟，请求越多最后的那个请求延迟就会越严重，而且这样请求多了之后逻辑就会变得很乱。。。痛苦不堪，还好es6带来的Promise正好能解决这个东西，关于<code>Promise</code>具体详情请百度，这里大致只说三个东西，<code>resolve</code>, <code>reject</code>，<code>Promise.all</code> 对应成功执行，失败执行，返回全部状态，实例贴代码 很容易理解。  </p>
<p>然鹅我们async的话，各种await之间也要等到上一个await执行完毕之后，才会执行下一个await，所以还是解决不了延迟的情况，所以我们采用ES6中的promise，来解决并行执行的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const promist &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    this.$http.jsonp(getRegionNameByIdApi, &#123; params: &#123; regionId: dqarr &#125; &#125;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">        this.dqarr &#x3D; res.body.data</span><br><span class="line">        resolve(res.body.data)</span><br><span class="line">    &#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">const promist1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    this.$http.jsonp(getPartnerNameByIdApi, &#123; params: &#123; partnerId: sharr &#125; &#125;).then((res) &#x3D;&gt; &#123;</span><br><span class="line">        this.sharr &#x3D; res.body.data</span><br><span class="line">        resolve(res.body.data)</span><br><span class="line">    &#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.all([promist, promist1]).then((resultList) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;results:&#39;, resultList)</span><br><span class="line">    resultList[0].map((item) &#x3D;&gt; &#123;</span><br><span class="line">        this.tableData.map((val) &#x3D;&gt; &#123;</span><br><span class="line">            if (item.regionId &#x3D;&#x3D;&#x3D; val.regionId) &#123;</span><br><span class="line">                val.region_name &#x3D; item.regionName</span><br><span class="line">            &#125;</span><br><span class="line">            if (item.regionId &#x3D;&#x3D;&#x3D; val.areaId) &#123;</span><br><span class="line">                val.area_name &#x3D; item.regionName</span><br><span class="line">            &#125;</span><br><span class="line">            if (item.regionId &#x3D;&#x3D;&#x3D; val.shopId) &#123;</span><br><span class="line">                val.shopName &#x3D; item.regionName</span><br><span class="line">            &#125;</span><br><span class="line">            if (resultList[1][val.partnerId]) &#123;</span><br><span class="line">                val.partner_name &#x3D; resultList[1][val.partnerId]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    this.$set(this.tableData, this.tableData)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="Promise实现任务顺序执行"><a href="#Promise实现任务顺序执行" class="headerlink" title="Promise实现任务顺序执行"></a>Promise实现任务顺序执行</h2><p>在<code>.then</code>里要<code>return</code>一个<code>new Promise</code>，这样后续才能继续使用<code>.then</code>执行后续操作：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result&#x3D;new Promise(function(resolve,reject)&#123;</span><br><span class="line">	setTimeout(function()&#123;</span><br><span class="line">		resolve(&quot;one&quot;);</span><br><span class="line">	&#125;,3000)</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">	return new Promise(function(resolve,reject)&#123;</span><br><span class="line">		setTimeout(function()&#123;</span><br><span class="line">			resolve(&quot;two&quot;);</span><br><span class="line">		&#125;,3000)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">	console.log(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中的computed属性和nextTick方法</title>
    <url>/2020/02/23/Vue%E4%B8%AD%E7%9A%84computed%E5%B1%9E%E6%80%A7%E5%92%8CnextTick%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><h3 id="computed属性的实现原理"><a href="#computed属性的实现原理" class="headerlink" title="computed属性的实现原理"></a>computed属性的实现原理</h3><ul>
<li>Vue实例初始化时，给data的每个属性<code>(dataKey)</code>都添加getter和setter方法  </li>
<li>计算属性<code>computed</code>初始化时，提供的函数将作为对应属性<code>(computedKey)</code>的getter方法<br>其中，computed属性采用<strong>函数式声明</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computedKey: function()&#123;</span><br><span class="line">       return this.dataKey+&#39;change&#39;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>当首次获取计算属性的值是，dep开始收集依赖，即收集到dataKey和computedKey的依赖关系，也就是上面的<code>this.datakey+&#39;change&#39;</code>;<br>在dataKey变化时，此时会调用dataKey的getter方法，通过dep收集的依赖，可以判定出data与<code>computed</code>对应数据的依赖关系<br>此时可以做到，在data发生变化时，<code>computed</code>属性数据也发生变化.我们要记住的是，computed中不推荐有任何数据的改变，最好只进行计算。如果你非要进行数据的操作那么可以把监听写在<code>watch</code>（注意deep深拷贝）或者使用<code>computed</code>的<code>get</code>和<code>set</code>如下图：<br><img src="/2020/02/23/Vue%E4%B8%AD%E7%9A%84computed%E5%B1%9E%E6%80%A7%E5%92%8CnextTick%E6%96%B9%E6%B3%95/computed.png" alt="computed.png"></li>
</ul>
<h3 id="computed属性的用法"><a href="#computed属性的用法" class="headerlink" title="computed属性的用法"></a>computed属性的用法</h3><p>目的：是为了避免模板中加入太多的计算公式，不够精炼，而且computed属性比较节约<br>官网中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#39;Hello&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算属性的 getter</span><br><span class="line">    reversedMessage: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class="line">      return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在模板文件中，只需要在插值表达式中写<strong>reversedMessage</strong>这个属性即可，它与<code>message</code>有依赖关系</p>
<h3 id="computed属性与watch的区别"><a href="#computed属性与watch的区别" class="headerlink" title="computed属性与watch的区别"></a>computed属性与watch的区别</h3><ul>
<li>当需要数据在 <strong>异步变化或者开销较大时</strong> ，执行更新，使用watch会更好一些；而computed<strong>不能进行异步操作</strong>；  </li>
<li>computed可以用 <strong>缓存中拿数据</strong> ，而watch是每次都要运行函数计算，不管变量的值是否发生变化，而computed在值没有发生变化时，可以直接读取上次的值  </li>
</ul>
<h3 id="computed属性与methods的区别"><a href="#computed属性与methods的区别" class="headerlink" title="computed属性与methods的区别"></a>computed属性与methods的区别</h3><p>在模板文件中，computed属性只需要写<code>reverseMessage</code>，而methods需要写成<code>reverseMessage()</code>，最明显的区别就是methods是方法，需要执行；<br>computed属性只有在依赖的data放生变化时，才会重新执行，否则会使用缓存中的值，而methods是每次进入页面都要执行的，有些需要每次进入页面都执行的方法，需要使用methods，而computed属性比较节约。</p>
<h2 id="this-nextTick"><a href="#this-nextTick" class="headerlink" title="this.$nextTick"></a>this.$nextTick</h2><h3 id="nextTick的原理"><a href="#nextTick的原理" class="headerlink" title="nextTick的原理"></a>nextTick的原理</h3><p>nextTick 可以让我们在<strong>下次 DOM 更新循环结束之后执行延迟回调</strong>，用于获得更新后的 DOM。<br>在 Vue 2.4 之前都是使用的 <code>microtasks</code>，但是 <code>microtasks</code> 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，（也就是，出现微任务执行比点击事件之类的事件触发还要快，导致逻辑出错）但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 <code>microtasks</code>，但在特殊情况下会使用 <code>macrotasks</code>，比如 v-on。</p>
<p>对于实现 <code>macrotasks</code> ，会先判断是否能使用 <code>setImmediate</code> ，不能的话降级为 <code>MessageChannel</code> ，以上都不行的话就使用<code>setTimeout</code></p>
<h3 id="nextTick的使用实例"><a href="#nextTick的使用实例" class="headerlink" title="nextTick的使用实例"></a>nextTick的使用实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;模板</span><br><span class="line">&lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;div ref&#x3D;&quot;msgDiv&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div v-if&#x3D;&quot;msg1&quot;&gt;Message got outside $nextTick: &#123;&#123;msg1&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div v-if&#x3D;&quot;msg2&quot;&gt;Message got inside $nextTick: &#123;&#123;msg2&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div v-if&#x3D;&quot;msg3&quot;&gt;Message got outside $nextTick: &#123;&#123;msg3&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;changeMsg&quot;&gt;</span><br><span class="line">    Change the Message</span><br><span class="line">  &lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Vue实例</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;.app&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: &#39;Hello Vue.&#39;,</span><br><span class="line">    msg1: &#39;&#39;,</span><br><span class="line">    msg2: &#39;&#39;,</span><br><span class="line">    msg3: &#39;&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeMsg() &#123;</span><br><span class="line">      this.msg &#x3D; &quot;Hello world.&quot;</span><br><span class="line">      this.msg1 &#x3D; this.$refs.msgDiv.innerHTML</span><br><span class="line">      this.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">        this.msg2 &#x3D; this.$refs.msgDiv.innerHTML</span><br><span class="line">      &#125;)</span><br><span class="line">      this.msg3 &#x3D; this.$refs.msgDiv.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>点击前：<br><img src="/2020/02/23/Vue%E4%B8%AD%E7%9A%84computed%E5%B1%9E%E6%80%A7%E5%92%8CnextTick%E6%96%B9%E6%B3%95/nextTick%E7%82%B9%E5%87%BB%E5%89%8D.png" alt="nextTick点击前.png"></p>
<p>点击后：<br><img src="/2020/02/23/Vue%E4%B8%AD%E7%9A%84computed%E5%B1%9E%E6%80%A7%E5%92%8CnextTick%E6%96%B9%E6%B3%95/nextTick%E7%82%B9%E5%87%BB%E5%90%8E.png" alt="nextTick点击后.png"></p>
<p>此时我们看到msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的<br>具体原因在Vue的官方文档中详细的解释：<br>Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 <code>setTimeout(fn, 0)</code>代替。</p>
<p>例如，当你设置<code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</p>
<p>让我们回到之前的例子，执行点击事件之后msg1,msg3中对DOM进行操作，他们拿到的数据还是DOM为更新前的，还是<code>hello,vue</code>,因为上面说了，置vm.someData = ‘new value’，该组件不会立即重新渲染。而msg2是写在nexttick函数里面的，它的执行会延迟到DOM更新之后，也就是msg变成<code>hello,world</code>之后，这样它操作DOM拿到的数据才是更新后的。  </p>
<p>这只是一个简单方便理解的例子，要是想深入了解的话，建议还是可以看一下vue.nextTick的源码。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/a7550c0e164f" target="_blank" rel="noopener">https://www.jianshu.com/p/a7550c0e164f</a><br><a href="https://segmentfault.com/a/1190000015070628" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015070628</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染过程</title>
    <url>/2020/02/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="从键入url到页面显示发生了什么"><a href="#从键入url到页面显示发生了什么" class="headerlink" title="从键入url到页面显示发生了什么"></a>从键入url到页面显示发生了什么</h2><p>这个过程可以大致分为两个部分：网络通信和页面渲染。</p>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>输入url按下回车之后，浏览器会去浏览器缓存中寻找该url的ip；没有的话去系统缓存中找，还是没有的话去路由器缓存中寻找；再没有就去系统host文件中找，还是没有最后只能去请求dns服务器，然后dns给一个ip给浏览器；浏览器根据这个IP地址，向服务器发送HTTP请求。HTTP经过传输层(TCP的三次握手建立连接);网络层(IP协议查询MAC地址);数据链路层(找到对方的MAC地址之后，将数据传送到数据链路层);物理层(传输给服务器);服务器接受数据；服务器响应请求；服务器返回相应的文件(HTML文件等)，接下来就是页面渲染</p>
<h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><ul>
<li>处理 HTML 并构建 DOM 树。(如果遇到style节点 则构建css树（这里不会阻塞dom树的构建）)</li>
<li>处理 CSS 构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调用 GPU 绘制，合成图层，显示在屏幕上。</li>
</ul>
<p><img src="/2020/02/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/xuanran.png" alt="xuanran.png"></p>
<p>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢</p>
<h4 id="浏览器渲染阻塞"><a href="#浏览器渲染阻塞" class="headerlink" title="浏览器渲染阻塞"></a>浏览器渲染阻塞</h4><p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。<br>为了避免解析到script标签的时候就发生浏览器渲染阻塞，我们可以给script标签加上async或者defer属性，这两个属性使得script标签不会阻塞DOM的渲染，<strong>能够异步加载script脚本，不阻塞DOM渲染。</strong></p>
<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>如果<code>script</code>标签设置了该属性，浏览器则会异步地下载该文件并且不会影响到后续DOM的渲染。如果有多个设置了<code>defer</code>的<code>script</code>标签存在，则会按照顺序执行所有的script。（defer按script脚本的声明顺序执行）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script defer type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;script2</span><br><span class="line">.js&quot;&gt;&#x2F;&lt;script&gt;</span><br><span class="line">&lt;script defer type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;script1</span><br><span class="line">.js&quot;&gt;&#x2F;&lt;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p><code>async</code>的设置，会使得script脚本异步加载。<code>async</code>的执行，不会按照script在页面中的顺序来执行，而是谁先加载完谁执行（此处与defer有所不同）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script async type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;script2</span><br><span class="line">.js&quot;&gt;&#x2F;&lt;script&gt;</span><br><span class="line">&lt;script async type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;script1</span><br><span class="line">.js&quot;&gt;&#x2F;&lt;script&gt;</span><br></pre></td></tr></table></figure>

<p>对于<code>link</code>标签和<code>@import</code>,这是引入CSS的两种方式，当解析HTML解析到<code>Link</code>标签时，会同步加载CSS文件，浏览器会多开一个线程，而<code>@import</code>，会等页面构建完，也就是加载完HTML文件之后再加载这个CSS文件。<code>link</code>标签的优先级比<code>@import</code>高</p>
<h4 id="DOM树与渲染树"><a href="#DOM树与渲染树" class="headerlink" title="DOM树与渲染树"></a>DOM树与渲染树</h4><p> DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像<code>&lt;head&gt;</code>元素或<code>display</code>属性值为<code>none</code>的元素都不在渲染树中。</p>
<h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><p> 重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p>
<ul>
<li><p>重绘是当节点需要更改外观而不会影响布局的，比如改变  <code>color</code>就叫称为重绘</p>
</li>
<li><p>回流是布局或者几何属性需要改变就称为回流</p>
<p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</p>
<h3 id="减少回流和重绘"><a href="#减少回流和重绘" class="headerlink" title="减少回流和重绘"></a>减少回流和重绘</h3></li>
<li><p>使用 <code>translate</code> 替代<code>top</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;div class&#x3D;&quot;test&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .test &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 10px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 引起回流</span><br><span class="line">    document.querySelector(&#39;.test&#39;).style.top &#x3D; &#39;100px&#39;</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>visibility</code>替换 <code>display: none</code>，因为前者只会引起重绘，后者会引发回流（改变了布局）</li>
<li>把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来</li>
<li>不要把 DOM 结点的属性值放在一个循环里当成循环里的变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取 offsetTop 会导致回流，因为需要去获取正确的值</span><br><span class="line">  console.log(document.querySelector(&#39;.test&#39;).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不要使用<code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code>的重新布局</li>
<li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li>
<li>CSS 选择符从右往左匹配查找，避免 DOM 深度过深,　css选择器的嵌套层级最好不要超过三级</li>
<li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于<code>video</code>标签，浏览器会自动将该节点变为图层。</li>
</ul>
</li>
</ul>
<h2 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h2><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。<strong>不同的图层渲染互不影响</strong>，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。<strong>但也不能生成过多的图层，会引起反作用。</strong><br>通过以下几个常用属性可以生成新图层</p>
<ul>
<li>3D 变换：<code>translate3d</code>、<code>translateZ</code></li>
<li><code>will-change</code></li>
<li><code>video</code>、<code>iframe</code> 标签</li>
<li>通过动画实现的 <code>opacity</code> 动画转换</li>
<li><code>position: fixed</code></li>
</ul>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖与节流</title>
    <url>/2020/02/09/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p>
<p>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p>
<p>PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p><strong>防抖动是将多次执行变为最后一次执行</strong>，这个最后一次执行分两种，一种是首次执行，一种是真的是最后一次执行。<br>举个栗子</p>
<ul>
<li>例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。</li>
<li>例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。  </li>
</ul>
<p>防抖的实现()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这个是用来获取当前时间戳的</span><br><span class="line">function now() &#123;</span><br><span class="line">  return +new Date()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;function&#125; func        回调函数</span><br><span class="line"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span><br><span class="line"> * @return &#123;function&#125;             返回客户调用函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">function debounce (func, wait &#x3D; 50, immediate &#x3D; true) &#123;</span><br><span class="line">  let timer, context, args</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 延迟执行函数</span><br><span class="line">  const later &#x3D; () &#x3D;&gt; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 延迟函数执行完毕，清空缓存的定时器序号</span><br><span class="line">    timer &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 延迟执行的情况下，函数会在延迟函数中执行</span><br><span class="line">    &#x2F;&#x2F; 使用到之前缓存的参数和上下文</span><br><span class="line">    if (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context &#x3D; args &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 这里返回的函数是每次实际调用的函数</span><br><span class="line">  return function(...params) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果没有创建延迟执行函数（later），就创建一个</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer &#x3D; later()</span><br><span class="line">      &#x2F;&#x2F; 如果是立即执行，调用函数</span><br><span class="line">      &#x2F;&#x2F; 否则缓存参数和调用上下文</span><br><span class="line">      if (immediate) &#123;</span><br><span class="line">        func.apply(this, params)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        context &#x3D; this</span><br><span class="line">        args &#x3D; params</span><br><span class="line">      &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span><br><span class="line">    &#x2F;&#x2F; 这样做延迟函数会重新计时</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer &#x3D; later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p><strong>节流是将多次执行变成每隔一段时间执行。</strong></p>
<p>节流的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 &#x2F; wait</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;function&#125;   func      回调函数</span><br><span class="line"> * @param  &#123;number&#125;     wait      表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。</span><br><span class="line"> *                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125;</span><br><span class="line"> *                                两者不能共存，否则函数不能执行</span><br><span class="line"> * @return &#123;function&#125;             返回客户调用函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">_.throttle &#x3D; function(func, wait, options) &#123;</span><br><span class="line">    var context, args, result;</span><br><span class="line">    var timeout &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 之前的时间戳</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 如果 options 没传则设为空对象</span><br><span class="line">    if (!options) options &#x3D; &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 定时器回调函数</span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果设置了 leading，就将 previous 设为 0</span><br><span class="line">      &#x2F;&#x2F; 用于下面函数的第一个 if 判断</span><br><span class="line">      previous &#x3D; options.leading &#x3D;&#x3D;&#x3D; false ? 0 : _.now();</span><br><span class="line">      &#x2F;&#x2F; 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span><br><span class="line">      timeout &#x3D; null;</span><br><span class="line">      result &#x3D; func.apply(context, args);</span><br><span class="line">      if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 获得当前时间戳</span><br><span class="line">      var now &#x3D; _.now();</span><br><span class="line">      &#x2F;&#x2F; 首次进入前者肯定为 true</span><br><span class="line">	  &#x2F;&#x2F; 如果需要第一次不执行函数</span><br><span class="line">	  &#x2F;&#x2F; 就将上次时间戳设为当前的</span><br><span class="line">      &#x2F;&#x2F; 这样在接下来计算 remaining 的值时会大于0</span><br><span class="line">      if (!previous &amp;&amp; options.leading &#x3D;&#x3D;&#x3D; false) previous &#x3D; now;</span><br><span class="line">      &#x2F;&#x2F; 计算剩余时间</span><br><span class="line">      var remaining &#x3D; wait - (now - previous);</span><br><span class="line">      context &#x3D; this;</span><br><span class="line">      args &#x3D; arguments;</span><br><span class="line">      &#x2F;&#x2F; 如果当前调用已经大于上次调用时间 + wait</span><br><span class="line">      &#x2F;&#x2F; 或者用户手动调了时间</span><br><span class="line"> 	  &#x2F;&#x2F; 如果设置了 trailing，只会进入这个条件</span><br><span class="line">	  &#x2F;&#x2F; 如果没有设置 leading，那么第一次会进入这个条件</span><br><span class="line">	  &#x2F;&#x2F; 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span><br><span class="line">	  &#x2F;&#x2F; 其实还是会进入的，因为定时器的延时</span><br><span class="line">	  &#x2F;&#x2F; 并不是准确的时间，很可能你设置了2秒</span><br><span class="line">	  &#x2F;&#x2F; 但是他需要2.2秒才触发，这时候就会进入这个条件</span><br><span class="line">      if (remaining &lt;&#x3D; 0 || remaining &gt; wait) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果存在定时器就清理掉否则会调用二次回调</span><br><span class="line">        if (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        previous &#x3D; now;</span><br><span class="line">        result &#x3D; func.apply(context, args);</span><br><span class="line">        if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">      &#125; else if (!timeout &amp;&amp; options.trailing !&#x3D;&#x3D; false) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否设置了定时器和 trailing</span><br><span class="line">	    &#x2F;&#x2F; 没有的话就开启一个定时器</span><br><span class="line">        &#x2F;&#x2F; 并且不能不能同时设置 leading 和 trailing</span><br><span class="line">        timeout &#x3D; setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="https://yuchengkai.cn/docs/frontend/#%E9%98%B2%E6%8A%96" target="_blank" rel="noopener">https://yuchengkai.cn/docs/frontend/#%E9%98%B2%E6%8A%96</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js中的函数</title>
    <url>/2020/02/06/Js%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><p>柯里化概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数<br>看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var add &#x3D; function(x) &#123;</span><br><span class="line">  return function(y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var increment &#x3D; add(1);</span><br><span class="line">var addTen &#x3D; add(10);</span><br><span class="line"></span><br><span class="line">increment(2);</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">addTen(2);</span><br><span class="line">&#x2F;&#x2F; 12</span><br></pre></td></tr></table></figure>
<p>我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用了<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。</p>
<p>因为一次性地调用它有点繁琐，所以使用一个特殊的<code>curry</code>帮助函数使得这类函数的定义和调用更加容易。</p>
<h3 id="curry的封装"><a href="#curry的封装" class="headerlink" title="curry的封装"></a>curry的封装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初步封装</span><br><span class="line">var currying &#x3D; function(fn) &#123;</span><br><span class="line">    &#x2F;&#x2F; args 获取第一个方法内的全部参数</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1)</span><br><span class="line">    return function() &#123;</span><br><span class="line">        &#x2F;&#x2F; 将后面方法里的全部参数和args进行合并</span><br><span class="line">        var newArgs &#x3D; args.concat(Array.prototype.slice.call(arguments))</span><br><span class="line">        &#x2F;&#x2F; 把合并后的参数通过apply作为fn的参数并执行</span><br><span class="line">        return fn.apply(this, newArgs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边首先是初步封装,通过闭包把初步参数给保存下来，然后通过获取剩下的<code>arguments</code>(这里的arguments是函数function自带的一个隐式参数，表现为所有参数组成的数组)进行拼接，最后执行需要<code>currying</code>的函数。</p>
<p>但是好像还有些什么缺陷，这样返回的话其实只能多扩展一个参数，<code>currying(a)(b)(c)</code>这样的话，貌似就不支持了（不支持多参数调用），一般这种情况都会想到使用递归再进行封装一层。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 支持多参数传递</span><br><span class="line">function progressCurrying(fn, args) &#123;</span><br><span class="line"></span><br><span class="line">    var _this &#x3D; this</span><br><span class="line">    var len &#x3D; fn.length;</span><br><span class="line">    var args &#x3D; args || [];</span><br><span class="line"></span><br><span class="line">    return function() &#123;</span><br><span class="line">        var _args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">        Array.prototype.push.apply(args, _args);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果参数个数小于最初的fn.length，则递归调用，继续收集参数</span><br><span class="line">        if (_args.length &lt; len) &#123;</span><br><span class="line">            return progressCurrying.call(_this, fn, _args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 参数收集完毕，则执行fn</span><br><span class="line">        return fn.apply(this, _args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展一道经典的面试题"><a href="#拓展一道经典的面试题" class="headerlink" title="拓展一道经典的面试题"></a>拓展一道经典的面试题</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现一个add方法，使计算结果能够满足如下预期：</span><br><span class="line">&#x2F;&#x2F; add(1)(2)(3) &#x3D; 6;</span><br><span class="line">&#x2F;&#x2F; add(1, 2, 3)(4) &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; add(1)(2)(3)(4)(5) &#x3D; 15;</span><br><span class="line"></span><br><span class="line">function add() &#123;</span><br><span class="line">    &#x2F;&#x2F; 第一次执行时，定义一个数组专门用来存储所有的参数</span><br><span class="line">    var _args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span><br><span class="line">    var _adder &#x3D; function() &#123;</span><br><span class="line">        console.log(&quot;接收了一个()&quot;);</span><br><span class="line">        _args.push(...arguments); &#x2F;&#x2F;...arguments在ES6中表示剩下所有的参数，接受剩下的所有参数</span><br><span class="line">        return _adder; &#x2F;&#x2F;再返回adder,进行下一次递归，把上次接收的结果作为第一个参数，</span><br><span class="line">        &#x2F;&#x2F;再接受下一个参数，这里相当于接受下一个()里的参数,直到接收完毕</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span><br><span class="line">    _adder.toString &#x3D; function() &#123;</span><br><span class="line">         &#x2F;&#x2F; return _args.reduce(function(a, b) &#123;</span><br><span class="line">        &#x2F;&#x2F;     return a + b;</span><br><span class="line">        &#x2F;&#x2F; &#125;);</span><br><span class="line">        return _args.reduce((a, b) &#x3D;&gt; a + b);</span><br><span class="line">        &#x2F;&#x2F;reduce是ES5中的API，利用其能够遍历到数组的每一个元素，这里的a+b相当于当前所有的参数</span><br><span class="line">    &#125;</span><br><span class="line">    return _adder; &#x2F;&#x2F;这里相当于返回最后计算好的结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var res &#x3D; add(1, 2)(1)(2)(5);</span><br><span class="line">console.log(res + &#39;&#39;);</span><br><span class="line">console.log(add(1)(2)(3) + &#39;&#39;);</span><br><span class="line">&#x2F;*</span><br><span class="line">接收了一个()</span><br><span class="line">接收了一个()</span><br><span class="line">接收了一个()</span><br><span class="line">11</span><br><span class="line">接收了一个()</span><br><span class="line">接收了一个()</span><br><span class="line">6</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="为什么要进行隐式转化"><a href="#为什么要进行隐式转化" class="headerlink" title="为什么要进行隐式转化"></a>为什么要进行隐式转化</h4><p>因为当我们将函数参与其他的计算时，函数会默认调用toString方法，直接将函数体转换为字符串参与计算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn() &#123; return 20 &#125;</span><br><span class="line">console.log(fn + 10);     &#x2F;&#x2F; 输出结果 function fn() &#123; return 20 &#125;10</span><br></pre></td></tr></table></figure>
<p>我们可以重写函数的toString方法，让函数参与计算，输出我们想要的结果：,就像上面我们所写的_adder.toString =function(){},</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn() &#123; return 20; &#125;</span><br><span class="line">fn.toString &#x3D; function() &#123; return 30 &#125;</span><br><span class="line"></span><br><span class="line">console.log(fn + 10); &#x2F;&#x2F; 40</span><br></pre></td></tr></table></figure>
<p>除此之外，当我们重写函数的valueOf方法也能够改变函数的隐式转换结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn() &#123; return 20; &#125;</span><br><span class="line">fn.valueOf &#x3D; function() &#123; return 60 &#125;</span><br><span class="line"></span><br><span class="line">console.log(fn + 10); &#x2F;&#x2F; 70</span><br></pre></td></tr></table></figure>
<h3 id="函数柯里化的好处"><a href="#函数柯里化的好处" class="headerlink" title="函数柯里化的好处"></a>函数柯里化的好处</h3><h4 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常正则验证字符串 reg.test(txt)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数封装后</span><br><span class="line">function check(reg, txt) &#123;</span><br><span class="line">    return reg.test(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check(&#x2F;\d+&#x2F;g, &#39;test&#39;)       &#x2F;&#x2F;false</span><br><span class="line">check(&#x2F;[a-z]+&#x2F;g, &#39;test&#39;)    &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Currying后</span><br><span class="line">function curryingCheck(reg) &#123;</span><br><span class="line">    return function(txt) &#123;</span><br><span class="line">        return reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hasNumber &#x3D; curryingCheck(&#x2F;\d+&#x2F;g)</span><br><span class="line">var hasLetter &#x3D; curryingCheck(&#x2F;[a-z]+&#x2F;g)</span><br><span class="line"></span><br><span class="line">hasNumber(&#39;test1&#39;)      &#x2F;&#x2F; true</span><br><span class="line">hasNumber(&#39;testtest&#39;)   &#x2F;&#x2F; false</span><br><span class="line">hasLetter(&#39;21212&#39;)      &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>上面的示例是一个正则的校验，正常来说直接调用check函数就可以了，但是如果我有很多地方都要校验是否有数字，其实就是需要将第一个参数reg进行复用，这样别的地方就能够直接调用hasNumber，hasLetter等函数，让参数能够复用，调用起来也更方便。</p>
<h4 id="提前确认"><a href="#提前确认" class="headerlink" title="提前确认"></a>提前确认</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var on &#x3D; function(element, event, handler) &#123;</span><br><span class="line">    if (document.addEventListener) &#123;</span><br><span class="line">        if (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.addEventListener(event, handler, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">            element.attachEvent(&#39;on&#39; + event, handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var on &#x3D; (function() &#123;</span><br><span class="line">    if (document.addEventListener) &#123;</span><br><span class="line">        return function(element, event, handler) &#123;</span><br><span class="line">            if (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.addEventListener(event, handler, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return function(element, event, handler) &#123;</span><br><span class="line">            if (element &amp;&amp; event &amp;&amp; handler) &#123;</span><br><span class="line">                element.attachEvent(&#39;on&#39; + event, handler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;换一种写法可能比较好理解一点，上面就是把isSupport这个参数给先确定下来了</span><br><span class="line">var on &#x3D; function(isSupport, element, event, handler) &#123;</span><br><span class="line">    isSupport &#x3D; isSupport || document.addEventListener;</span><br><span class="line">    if (isSupport) &#123;</span><br><span class="line">        return element.addEventListener(event, handler, false);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return element.attachEvent(&#39;on&#39; + event, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在做项目的过程中，封装一些dom操作可以说再常见不过，上面第一种写法也是比较常见，但是我们看看第二种写法，它相对一第一种写法就是自执行然后返回一个新的函数，这样其实就是提前确定了会走哪一个方法，避免每次都进行判断。  </p>
<h4 id="延迟运行"><a href="#延迟运行" class="headerlink" title="延迟运行"></a>延迟运行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; function (context) &#123;</span><br><span class="line">    var _this &#x3D; this</span><br><span class="line">    var args &#x3D; Array.prototype.slice.call(arguments, 1)</span><br><span class="line"> </span><br><span class="line">    return function() &#123;</span><br><span class="line">        return _this.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像我们js中经常使用的bind，实现的机制就是Currying.</p>
<h2 id="Js中的高阶函数"><a href="#Js中的高阶函数" class="headerlink" title="Js中的高阶函数"></a>Js中的高阶函数</h2><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，<strong>函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</strong>。<br>一个最简单的高阶函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(x, y, f) &#123;</span><br><span class="line">    return f(x) + f(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数x，y和f分别接收<code>-5，6</code>和函数<code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; -5;</span><br><span class="line">y &#x3D; 6;</span><br><span class="line">f &#x3D; Math.abs;</span><br><span class="line">f(x) + f(y) &#x3D;&#x3D;&gt; Math.abs(-5) + Math.abs(6) &#x3D;&#x3D;&gt; 11;</span><br><span class="line">return 11;</span><br></pre></td></tr></table></figure>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>由于<code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array的map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">function pow(x) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line">var arr &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">var results &#x3D; arr.map(pow); &#x2F;&#x2F; [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">console.log(results);</span><br></pre></td></tr></table></figure>

<p>再看reduce的用法。Array的<code>reduce()</code>把一个函数作用在这个Array的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 3, 5, 7, 9];</span><br><span class="line">arr.reduce(function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;还可以写成箭头函数形式</span><br><span class="line">arr.reduce((a,b)&#x3D;&gt; a+b);</span><br></pre></td></tr></table></figure>
<h3 id="filter-筛选器"><a href="#filter-筛选器" class="headerlink" title="filter(筛选器)"></a>filter(筛选器)</h3><p>filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。  </p>
<p>和<code>map()</code>类似，Array的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。<br>把一个Array中的空字符串删掉，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, null, undefined, &#39;C&#39;, &#39;  &#39;];</span><br><span class="line">var r &#x3D; arr.filter(function (s) &#123;</span><br><span class="line">    return s &amp;&amp; s.trim(); &#x2F;&#x2F; 注意：IE9以下的版本没有trim()方法</span><br><span class="line">&#125;);</span><br><span class="line">r; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br></pre></td></tr></table></figure>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</p>
<p>要按数字大小排序，我们可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [10, 20, 1, 2];</span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr); &#x2F;&#x2F; [1, 2, 10, 20]</span><br><span class="line">&#x2F;&#x2F;对包含字母的排序</span><br><span class="line">var arr &#x3D; [&#39;Google&#39;, &#39;apple&#39;, &#39;Microsoft&#39;];</span><br><span class="line">arr.sort(function (s1, s2) &#123;</span><br><span class="line">    x1 &#x3D; s1.toUpperCase();</span><br><span class="line">    x2 &#x3D; s2.toUpperCase();</span><br><span class="line">    if (x1 &lt; x2) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x1 &gt; x2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;); &#x2F;&#x2F; [&#39;apple&#39;, &#39;Google&#39;, &#39;Microsoft&#39;]</span><br></pre></td></tr></table></figure>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><p><code>every()</code>方法可以判断数组的所有元素是否满足测试条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];</span><br><span class="line">console.log(arr.every(function (s) &#123;</span><br><span class="line">    return s.length &gt; 0;</span><br><span class="line">&#125;)); &#x2F;&#x2F; true, 因为每个元素都满足s.length&gt;0</span><br><span class="line"></span><br><span class="line">console.log(arr.every(function (s) &#123;</span><br><span class="line">    return s.toLowerCase() &#x3D;&#x3D;&#x3D; s;</span><br><span class="line">&#125;)); &#x2F;&#x2F; false, 因为不是每个元素都全部是小写</span><br></pre></td></tr></table></figure>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><code>find()</code>方法用于查找<strong>符合条件的第一个元素</strong>，如果找到了，返回这个元素，否则，返回<code>undefined</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];</span><br><span class="line">console.log(arr.find(function (s) &#123;</span><br><span class="line">    return s.toLowerCase() &#x3D;&#x3D;&#x3D; s;</span><br><span class="line">&#125;)); &#x2F;&#x2F; &#39;pear&#39;, 因为pear全部是小写</span><br><span class="line"></span><br><span class="line">console.log(arr.find(function (s) &#123;</span><br><span class="line">    return s.toUpperCase() &#x3D;&#x3D;&#x3D; s;</span><br><span class="line">&#125;)); &#x2F;&#x2F; undefined, 因为没有全部是大写的元素</span><br></pre></td></tr></table></figure>
<h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h4><p><code>findIndex()</code>和<code>find()</code>类似，也是查找符合条件的第一个元素，不同之处在于<code>findIndex()</code>会返回这个元素的索引，如果没有找到，返回<code>-1</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];</span><br><span class="line">console.log(arr.findIndex(function (s) &#123;</span><br><span class="line">    return s.toLowerCase() &#x3D;&#x3D;&#x3D; s;</span><br><span class="line">&#125;)); &#x2F;&#x2F; 1, 因为&#39;pear&#39;的索引是1</span><br><span class="line"></span><br><span class="line">console.log(arr.findIndex(function (s) &#123;</span><br><span class="line">    return s.toUpperCase() &#x3D;&#x3D;&#x3D; s;</span><br><span class="line">&#125;)); &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组。forEach()常用于遍历数组，因此，传入的函数不需要返回值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];</span><br><span class="line">arr.forEach(console.log); &#x2F;&#x2F; 依次打印每个元素</span><br></pre></td></tr></table></figure>
<h2 id="Generator函数-async函数"><a href="#Generator函数-async函数" class="headerlink" title="Generator函数 async函数"></a>Generator函数 async函数</h2><p>概念：</p>
<ul>
<li><code>Generator</code> 函数是 ES6 提供的一种异步编程解决方案</li>
<li><code>generator</code> <code>由function *</code>定义（注意多出的<code>*</code>号）;函数内部使用<code>yield</code>表达式，定义不同的内部状态</li>
<li>调用<code>Generator</code>函数后，该函数并不执行，返回的不是函数运行结果，而是一个指向内部状态的指针对象</li>
<li>必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态，输出返回的结果</li>
<li><code>next</code>方法返回的是一个对象。它的<code>value</code>属性就是当前<code>yield</code>表达式的值hello，<code>done</code>属性的值<code>false</code>则表示遍历还没有结束（即没有遇到<code>return</code>）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* helloWorldGenerator() &#123;</span><br><span class="line">  yield &#39;hello&#39;;</span><br><span class="line">  yield &#39;world&#39;;</span><br><span class="line">  return &#39;ending&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hw &#x3D; helloWorldGenerator();</span><br><span class="line">hw.next()</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;hello&#39;, done: false &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;world&#39;, done: false &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">&#x2F;&#x2F; &#123; value: &#39;ending&#39;, done: true &#125;</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line">&#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>next方法可以传参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* gen(x)&#123;</span><br><span class="line"> const y &#x3D; yield x + 6;</span><br><span class="line"> return y;</span><br><span class="line">&#125;</span><br><span class="line">const g &#x3D; gen(1);</span><br><span class="line">g.next() &#x2F;&#x2F; &#123; value: 7, done: false &#125;</span><br><span class="line">g.next(2) &#x2F;&#x2F; &#123; value: 2, done: true &#125; </span><br><span class="line">&#x2F;&#x2F; next 的参数是作为上个阶段异步任务的返回结果</span><br></pre></td></tr></table></figure>
<h3 id="异步应用"><a href="#异步应用" class="headerlink" title="异步应用"></a>异步应用</h3><p>因为<code>yield</code>能够中断执行代码的特性，可以帮助我们来控制异步代码的执行顺序。</p>
<p>例如有两个异步的函数<code>A</code>和<code>B</code>, 并且<code>B</code>的参数是 <code>A</code>的返回值，也就是说，如果 <code>A</code>没有执行结束，我们不能执行<code>B</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* effect() &#123;</span><br><span class="line">  const &#123; param &#125; &#x3D; yield A();</span><br><span class="line">  const &#123; result &#125; &#x3D; yield B(param);</span><br><span class="line">  console.table(result);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;看到结果</span><br><span class="line">const iterator &#x3D; effect()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure>
<h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>这两个相当于generator函数的另一种语义表示</p>
<ul>
<li><code>async</code>函数将Generator函数的<code>星号（*）</code>替换成<code>async</code></li>
<li>将<code>yield</code>替换成<code>await</code></li>
</ul>
<p>async函数对Generator函数的改进体现在以下3点：<br>1.内置执行器</p>
<p>也就是说<code>async函数</code>的执行，和普通函数一样，只需要一行就可以。不用像<code>Generator</code>函数需要调用<code>next</code>方法才能真正执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const asyncReadFile &#x3D; async function () &#123;</span><br><span class="line">  const f1 &#x3D; await readFile(&#39;&#x2F;etc&#x2F;fstab&#39;);</span><br><span class="line">  const f2 &#x3D; await readFile(&#39;&#x2F;etc&#x2F;shells&#39;);</span><br><span class="line">  console.log(f1.toString());</span><br><span class="line">  console.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;调用只需要一行代码，而且自带执行器，不需要next()</span><br><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>

<p>2.更好的语义</p>
<p><code>async</code>和<code>await</code>比起星号和<code>yield</code>，语义更加清楚了。<code>async</code>表示函数里有<strong>异步操作</strong>，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
<p>3.返回值是promise</p>
<p><code>async函数</code>的返回值是 <code>Promise 对象</code>，这比 <code>Generator 函数</code>的返回值是<code>Iterator 对象</code>方便多了。你可以用<code>then</code>方法指定下一步的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function getStockPriceByName(name) &#123;</span><br><span class="line">  const symbol &#x3D; await getStockSymbol(name);</span><br><span class="line">  const stockPrice &#x3D; await getStockPrice(symbol);</span><br><span class="line">  return stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(&#39;goog&#39;).then(function (result) &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先执行了第一个<code>await</code>后的<code>getStockSymbol(name)</code>函数；得到了股票的名称<code>symbol</code>后，将<code>symbol</code>传给第二个await后面的<code>getStockPrice(symbol)</code>作为参数；最后返回股票价格<code>stockPrice</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">https://www.jianshu.com/p/2975c25e4d71</a><br><a href="https://delaprada.com/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/#more" target="_blank" rel="noopener">https://delaprada.com/2020/01/14/Generator%E5%87%BD%E6%95%B0-async%E5%87%BD%E6%95%B0/#more</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Http各个状态码的含义</title>
    <url>/2020/01/28/Http%E5%90%84%E4%B8%AA%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    <content><![CDATA[<h2 id="状态码的含义"><a href="#状态码的含义" class="headerlink" title="状态码的含义"></a>状态码的含义</h2><p>http各个状态码的含义：由三位数字组成，第一位定义了状态码的类型</p>
<h2 id="2开头：（请求成功）表示成功处理了请求的状态代码"><a href="#2开头：（请求成功）表示成功处理了请求的状态代码" class="headerlink" title="2开头：（请求成功）表示成功处理了请求的状态代码"></a>2开头：（请求成功）表示成功处理了请求的状态代码</h2><ul>
<li>200：（成功）服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</li>
<li>201：（已创建）请求成功并且服务器创建了新的资源</li>
<li>202：（已接受）服务器已接受请求，但尚未处理</li>
<li>203：（非授权信息）服务器已成功处理了请求，但返回的信息可能来自另一资源。</li>
<li>204：（无内容）服务器成功处理了请求，但没有返回任何内容</li>
<li>205：（重置内容）服务器成功处理了请求，但没有返回任何内容</li>
<li>206：（部分内容）服务器成功处理了部分 GET 请求</li>
</ul>
<h2 id="3开头：（请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向"><a href="#3开头：（请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向" class="headerlink" title="3开头：（请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向"></a>3开头：（请求被重定向）表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向</h2><ul>
<li>300：（多种选择）针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li>
<li>301：（永久移动）请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新的位置</li>
<li>302：（临时移动）服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
<li>303：（查看其他位置）请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li>
<li>304：（未修改）自从上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页内容</li>
<li>305：（使用代理）请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li>
<li>307：（临时重定向）服务器目前从不同位置的网页响应请求，但请求者继续使用原有位置来进行以后的请求</li>
</ul>
<h2 id="4开头：（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理"><a href="#4开头：（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理" class="headerlink" title="4开头：（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理"></a>4开头：（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</h2><ul>
<li>400：（错误请求）服务器不理解请求的语法</li>
<li>401：（未授权）请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li>
<li>403：（禁止）服务器拒绝请求</li>
<li>404：（未找到）服务器找不到请求的网页</li>
<li>405：（方法禁用）禁用请求中指定的方法</li>
<li>406：（不接受）无法使用请求的内容特性响应请求的网页</li>
<li>407：（需要代理授权）此状态代码与 401 （未授权）类似，但指定请求者应当授权使用代理</li>
<li>408：（请求超时）服务器等候请求时发生超时</li>
<li>409：（冲突）服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息</li>
<li>410：（已删除）如果请求的资源已永久删除，服务器就会返回此响应</li>
<li>411：（需要有效长度）服务器不接受不含有效内容长度标头字段的请求</li>
<li>412：（未满足前提条件）服务器未满足请求者在请求中设置的其中一个前提条件</li>
<li>413：（请求实体过大）服务器无法处理请求，因为请求实体过大，超出服务器的处理能力</li>
<li>414：（请求的 URI 过长）请求的URI（通常为网址）过长，服务器无法处理</li>
<li>415：（不支持的媒体类型）请求的格式不受请求页面的支持</li>
<li>416：（请求范围不符合）如果页面无法提供请求的范围，则服务器返回此状态代码</li>
<li>417：（未满足期望值）服务器未满足“期望”请求标头字段要求</li>
</ul>
<h2 id="5开头：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。"><a href="#5开头：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。" class="headerlink" title="5开头：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。"></a>5开头：（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</h2><ul>
<li>500：（服务器内部错误）服务器遇到错误，无法完成请求</li>
<li>501：（尚未实施）服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li>
<li>502：（错误网关）服务器作为网关或代理，从上游服务器收到无效响应</li>
<li>503：（服务不可用）服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态</li>
<li>504：（网关超时）服务器作为网关或代理，但是没有及时从上游服务器收到请求</li>
<li>505：（HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/ningxinyu520/article/details/18217077?utm_source=blogxgwz2" target="_blank" rel="noopener">https://blog.csdn.net/ningxinyu520/article/details/18217077?utm_source=blogxgwz2</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>几种常见的CSS布局</title>
    <url>/2020/01/21/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84CSS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h2><h3 id="header-content和footer等宽的单列布局"><a href="#header-content和footer等宽的单列布局" class="headerlink" title="header,content和footer等宽的单列布局"></a>header,content和footer等宽的单列布局</h3><p><img src="/2020/01/21/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84CSS%E5%B8%83%E5%B1%80/danlie1.png" alt="danlie1.png"><br>实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .header &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            max-width: 960px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .content &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            max-width: 960px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .footer &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            max-width: 960px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;header&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;content&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="header与footer等宽-content略窄的单列布局"><a href="#header与footer等宽-content略窄的单列布局" class="headerlink" title="header与footer等宽,content略窄的单列布局"></a>header与footer等宽,content略窄的单列布局</h3><p><img src="/2020/01/21/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84CSS%E5%B8%83%E5%B1%80/danlie2.png" alt="danlie2.png"><br>实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .header &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            max-width: 960px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .nav &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            max-width: 800px;</span><br><span class="line">            background-color: darkgray;</span><br><span class="line">            height: 50px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .content &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            max-width: 800px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .footer &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            max-width: 960px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: aqua;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;header&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;nav&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;content&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="两列自适应布局"><a href="#两列自适应布局" class="headerlink" title="两列自适应布局"></a>两列自适应布局</h2><p>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式<br><img src="/2020/01/21/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84CSS%E5%B8%83%E5%B1%80/lianglie.png" alt="lianglie.png"></p>
<h3 id="float-overflow-hidden"><a href="#float-overflow-hidden" class="headerlink" title="float+overflow:hidden"></a>float+overflow:hidden</h3><p>如果是普通的两列布局，浮动+普通元素的<code>margin</code>便可以实现，但如果是自适应的两列布局，利用<code>float+overflow:hidden</code>便可以实现，这种办法主要通过<code>overflow</code>触发BFC,而BFC不会重叠浮动元素。由于设置<code>overflow:hidden</code>并不会触发IE6-浏览器的<code>haslayout</code>属性，所以需要设置<code>zoom:1</code>来兼容IE6-浏览器。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .parent &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            zoom: 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .left &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            margin-right: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .right &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">            zoom: 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot; style&#x3D;&quot;background-color: lightgrey;&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;left&quot; style&#x3D;&quot;background-color: lightblue;&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;left&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;right&quot; style&#x3D;&quot;background-color: lightgreen;&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="flex布局实现"><a href="#flex布局实现" class="headerlink" title="flex布局实现"></a>flex布局实现</h3><p>Flex布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局。<br>实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .parent &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .right &#123;</span><br><span class="line">            margin-left: 20px;</span><br><span class="line">            flex: 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot; style&#x3D;&quot;background-color: lightgrey;&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;left&quot; style&#x3D;&quot;background-color: lightblue;&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;left&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;right&quot; style&#x3D;&quot;background-color: lightgreen;&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>Grid布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .parent &#123;</span><br><span class="line">            display: grid;</span><br><span class="line">            grid-template-columns: auto 1fr;</span><br><span class="line">            grid-gap: 20px</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot; style&#x3D;&quot;background-color: lightgrey;&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;left&quot; style&#x3D;&quot;background-color: lightblue;&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;left&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;right&quot; style&#x3D;&quot;background-color: lightgreen;&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">            &lt;p&gt;right&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h2><p>特征：中间列自适应宽度，旁边两侧固定宽度，实现三栏布局有多种方式，着重讲圣杯布局和双飞翼布局。</p>
<h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p><img src="/2020/01/21/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84CSS%E5%B8%83%E5%B1%80/shengbei.png" alt="shengbei.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container &#123;</span><br><span class="line">            padding-left: 220px;</span><br><span class="line">            padding-right: 220px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .left &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background: red;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            position: relative;</span><br><span class="line">            left: -220px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .center &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 500px;</span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .right &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background: blue;</span><br><span class="line">            margin-left: -200px;</span><br><span class="line">            position: relative;</span><br><span class="line">            right: -220px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article class&#x3D;&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;center&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h2&gt;圣杯布局&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>实现步骤：  </p>
<ul>
<li>三个部分都设定为左浮动，否则左右两边内容上不去，就不可能与中间列同一行。然后设置center的宽度为100%(实现中间列内容自适应)，此时，left和right部分会被挤到下一行  </li>
<li>通过设置margin-left为负值让left和right部分回到与center部分同一行  </li>
<li>通过设置父容器的padding-left和padding-right，让左右两边留出间隙。这样的空隙，也就是为了到时候，左右界面分别移动到左右边界的分界线，左右界面和中间界面的分界  </li>
<li>空隙先预留好了，此时的左右界面还有跟中间界面黏在一块的，我们要让左右界面基于中间界面做移动。通过设置相对定位，设置left和right的值，让左右部分移动到两边。  </li>
</ul>
<p>但是这样的圣杯布局有缺点：</p>
<ul>
<li>center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行</li>
<li>如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助伪等高布局可解决)<h4 id="解决方法伪等高布局"><a href="#解决方法伪等高布局" class="headerlink" title="解决方法伪等高布局"></a>解决方法伪等高布局</h4>实现的方法很简单，我们的需求是，所有的列的高度都要一样。但是既然叫做伪等高。是因为，并没有实际设置这三个的列的高度相同。<br>我们先设置一个设置一个大数值的<code>padding-bottom</code>，再设置相同数值的负的<code>margin-bottom</code>，并在包裹这三列的容器container设置<code>overflow:hidden</code>把溢出背景切掉。这样就相当于把这三列都以container的高度为主了，但是container的高度是由高度最大的center撑开的，所以以center的高度为主<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2>同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。<br><img src="/2020/01/21/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84CSS%E5%B8%83%E5%B1%80/shuangfeiyi.png" alt="shuangfeiyi.png"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;test&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot;&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .container &#123;</span><br><span class="line">            min-width: 600px;</span><br><span class="line">            &#x2F;* 确保中间内容可以显示出来，两倍left宽+right宽 *&#x2F;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .center,</span><br><span class="line">        .left,</span><br><span class="line">        .right &#123;</span><br><span class="line">               &#x2F;* 伪等高采取的，跟上面一样 *&#x2F;</span><br><span class="line">            padding-bottom: 10000px;</span><br><span class="line">            margin-bottom: -10000px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .left &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background: red;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .center &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 500px;</span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .center .inner &#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            margin: 0 200px;</span><br><span class="line">            &#x2F;* 新增部分 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .right &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 400px;</span><br><span class="line">            background: blue;</span><br><span class="line">            margin-left: -200px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article class&#x3D;&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;center&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class&#x3D;&quot;inner&quot;&gt;双飞翼布局&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
实现步骤：  </li>
<li>三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行</li>
<li>通过设置margin-left为负值让left和right部分回到与center部分同一行，此时形状看起来像是已经实现了双飞翼了，但是还不行</li>
<li>center部分增加一个内层div，并设margin: 0 200px；这层新加的才是真正的center，center需要写的东西在这一层新增的div里面写</li>
</ul>
<p>缺点：多加一层 dom 树节点，增加渲染树生成的计算量。</p>
<p>两种布局实现方式对比:  </p>
<ul>
<li>两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局</li>
<li>两种布局方式的不同之处在于如何处理中间主列的位置：圣杯布局是利用父容器的左、右内边距+两个从列相对定位；双飞翼布局则是在center新增一个内嵌的div，在div里面调整左右外间距等于left,right的宽度。然后在这一层新增的div里面写真正的center的内容<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>推荐阅读：<a href="https://blog.csdn.net/VhWfR2u02Q/article/details/84076421" target="_blank" rel="noopener">https://blog.csdn.net/VhWfR2u02Q/article/details/84076421</a></li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS和HTTP的区别分析</title>
    <url>/2020/01/20/HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>纯面试需要而总结</p>
<h2 id="HTTPS和HTTP的区别主要如下"><a href="#HTTPS和HTTP的区别主要如下" class="headerlink" title="HTTPS和HTTP的区别主要如下"></a>HTTPS和HTTP的区别主要如下</h2><ul>
<li><code>https</code>协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。(但是现在在阿里云和腾讯云都可以免费从<code>HTTP</code>转<code>HTTPS</code>。会有免费的CA证书给你下载，时效为一年)</li>
<li>http是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，https则是具有安全性的<strong>SSL加密传输协议。</strong></li>
<li><code>http</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样，前者是<code>80</code>，后者是<code>443</code>。</li>
<li><code>http</code>的连接很简单，是<strong>无状态的</strong>；<code>HTTPS</code>协议是由<code>SSL+HTTP协议</code>构建的可进行<strong>加密传输、身份认证的网络协议</strong>，比<code>http</code>协议安全。<br>由此可以对比得到，<code>http</code>协议是明文传输，<strong>不确认通信方</strong>，<strong>不保证传输数据完整</strong>的协议。它带来了三大风险：</li>
<li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li>
<li>篡改风险（tampering）：第三方可以修改通信内容。</li>
<li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。<br>用一幅图更好的理解两种协议：<br><img src="/2020/01/20/HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/HTTPS.PNG" alt="HTTPS.png"><h2 id="关于HTTP和HTTPS的基本概念"><a href="#关于HTTP和HTTPS的基本概念" class="headerlink" title="关于HTTP和HTTPS的基本概念"></a>关于HTTP和HTTPS的基本概念</h2></li>
<li><em>HTTP :*</em>是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准<code>（TCP）</code>，用于从<code>WWW服务器</code>传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。  </li>
<li><em>HTTPS：*</em>是以安全为目标的HTTP通道，简单讲是<code>HTTP</code>的安全版，即<code>HTTP</code>下加入<code>SSL层</code>，<code>HTTPS的安全基础是SSL</code>，因此加密的详细内容就需要<code>SSL</code>。  </li>
</ul>
<p>HTTPS协议的主要作用可以分为两种：</p>
<ul>
<li>一种是建立一个信息安全通道，来保证数据传输的安全</li>
<li>另一种就是确认网站的真实性。</li>
</ul>
<h3 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h3><ul>
<li>支持客户/服务器模式。（C/S模式）</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有<code>GET、HEAD、POST。</code>每种方法规定了客户与服务器联系的类型不同。由于<code>HTTP</code>协议简单，使得<code>HTTP</code>服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：<code>HTTP</code>允许传输<strong>任意类型的数据对象</strong>。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是<strong>限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接</strong>。采用这种方式可以节省传输时间。</li>
<li>无状态：<strong>HTTP协议是无状态协议</strong>。无状态是指协议对于<strong>事务处理没有记忆能力</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须<code>重传</code>，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快<h3 id="HTTPS特点"><a href="#HTTPS特点" class="headerlink" title="HTTPS特点"></a>HTTPS特点</h3>相比于http，https可以提供更加优质保密的信息，保证了<strong>用户数据的安全性</strong>，此外https同时也一定程度上保护了服务端，使用恶意攻击和伪装数据的成本大大提高。<h2 id="HTTP协议和HTTPS协议的工作过程"><a href="#HTTP协议和HTTPS协议的工作过程" class="headerlink" title="HTTP协议和HTTPS协议的工作过程"></a>HTTP协议和HTTPS协议的工作过程</h2><h3 id="HTTP协议的工作流程"><a href="#HTTP协议的工作流程" class="headerlink" title="HTTP协议的工作流程"></a>HTTP协议的工作流程</h3>第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接</li>
</ul>
<p>第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1）</p>
<p>第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕</p>
<p>第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK</p>
<p>第五步：服务器向客户端发送应答头信息</p>
<p>第六步：服务器向客户端发送应答头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端</p>
<p>第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接</p>
<h3 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h3><p><img src="/2020/01/20/HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/HTTPSwork.PNG" alt="HTTPSwork.png"><br>第一步：客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>第二步：Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>第三步：客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p>
<p>第四步：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>第五步：Web服务器利用自己的私钥解密出会话密钥。</p>
<p>第六步：Web服务器利用会话密钥加密与客户端之间的通信。</p>
<h3 id="SSL-TLS握手过程"><a href="#SSL-TLS握手过程" class="headerlink" title="SSL/TLS握手过程"></a>SSL/TLS握手过程</h3><p>现在我们具体关注在SSL连接是怎么样建立的<br><img src="/2020/01/20/HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/SSL.PNG" alt="SSL.png"><br><strong>Client Hello</strong><br>握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数Random1，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。</p>
<p><strong>Server Hello</strong><br>第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。</p>
<p>注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。</p>
<p><strong>Certificate</strong><br>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<p><strong>Server Hello Done</strong><br>Server Hello Done通知客户端Server Hello过程结束。</p>
<p><strong>Certificate Verify</strong><br>客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。</p>
<p>https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的</p>
<p><strong>Client Key Exchange</strong><br>上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。</p>
<p>至此，客户端和服务端都拥有<code>Random1+Random2+Random3</code>，那么两边再根据同样的算法就可以生成一份<strong>秘钥</strong>，握手结束后的应用层数据都是使用这个秘钥进行<strong>对称加密</strong>。</p>
<p>为什么要使用三个随机数？</p>
<p><strong>这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baijiahao.baidu.com/s?id=1629455363537331894&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1629455363537331894&amp;wfr=spider&amp;for=pc</a><br><a href="https://delaprada.com/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/#more" target="_blank" rel="noopener">https://delaprada.com/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/#more</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于canvas元素和CSS中的flex属性</title>
    <url>/2020/01/19/%E5%85%B3%E4%BA%8Ecanvas%E5%85%83%E7%B4%A0%E5%92%8CCSS%E4%B8%AD%E7%9A%84flex%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="canvas元素解析"><a href="#canvas元素解析" class="headerlink" title="canvas元素解析"></a>canvas元素解析</h2><h3 id="什么是canvas？"><a href="#什么是canvas？" class="headerlink" title="什么是canvas？"></a>什么是canvas？</h3><p>HTML5 的 <code>canvas</code> 元素使用 JavaScript 在网页上绘制图像。<br>画布是一个矩形区域，您可以控制其每一像素。<br><code>canvas</code> 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法</p>
<h3 id="创建canvas元素"><a href="#创建canvas元素" class="headerlink" title="创建canvas元素"></a>创建canvas元素</h3><p>规定元素的 id、宽度和高度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通过JavaScript来绘制"><a href="#通过JavaScript来绘制" class="headerlink" title="通过JavaScript来绘制"></a>通过JavaScript来绘制</h3><p><code>canvas</code> 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);&#x2F;&#x2F;找到画布</span><br><span class="line">var cxt&#x3D;c.getContext(&quot;2d&quot;);&#x2F;&#x2F;创建context对象，context对象是内建的HTML5对象</span><br><span class="line">cxt.fillStyle&#x3D;&quot;#FF0000&quot;;&#x2F;&#x2F;绘制context对象的颜色</span><br><span class="line">cxt.fillRect(0,0,150,75);&#x2F;&#x2F;绘制形状，左上角坐标为(0,0)，再画布上绘制150*75的矩形</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><code>除了矩形，还可以通过JavaScript绘制线条，圆形，加入图片等等</code><br>把一幅图像放置到画布上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var cxt&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line">var img&#x3D;new Image()</span><br><span class="line">img.src&#x3D;&quot;flower.png&quot;</span><br><span class="line">cxt.drawImage(img,0,0);</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="canvas需要注意的点"><a href="#canvas需要注意的点" class="headerlink" title="canvas需要注意的点"></a>canvas需要注意的点</h3><p><code>&lt;canvas width=&quot;250&quot; height=&quot;250&quot;&gt;&lt;/canvas&gt;</code>有个矩形长20px，高10px,CSS中width：250px  height：500px，请问这个矩形渲染出来的实际面积?<br>画布大小和CSS中设置width：250px  height：500px一致，其width和初始值比例为1:1，height和初始值比例为2:1。<strong>因此渲染出来的矩形的高度也将扩大一倍为20px，</strong>则矩形渲染出来的实际面积20X20=400。</p>
<h2 id="CSS中的flex属性"><a href="#CSS中的flex属性" class="headerlink" title="CSS中的flex属性"></a>CSS中的flex属性</h2><h3 id="flex属性的定义"><a href="#flex属性的定义" class="headerlink" title="flex属性的定义"></a>flex属性的定义</h3><p><code>flex</code> 属性用于设置或检索弹性盒模型对象的子元素如何分配空间。<br><code>flex</code> 属性是<code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code>属性的简写属性。<br>属性值：<br><img src="/2020/01/19/%E5%85%B3%E4%BA%8Ecanvas%E5%85%83%E7%B4%A0%E5%92%8CCSS%E4%B8%AD%E7%9A%84flex%E5%B1%9E%E6%80%A7/flex.PNG" alt="flex.PNG"><br>CSS语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex: flex-grow flex-shrink flex-basis|auto|initial|inherit;</span><br></pre></td></tr></table></figure>
<h3 id="flex布局的作用"><a href="#flex布局的作用" class="headerlink" title="flex布局的作用"></a>flex布局的作用</h3><p>以前在写导航栏的时候，总是用<code>float</code>或者<code>display：inline-block</code>实现，但是这两种方法都会有各种问题，比如浮动会影响父元素以及兄弟元素的样式，需要<strong>清除浮动</strong>, 现在用flex会很方便，并且是<strong>弹性布局</strong><br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML代码 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"> &lt;li&gt;音乐&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;li&gt;影视&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;li&gt;旅游&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- CSS代码 --&gt;</span><br><span class="line">ul&#123;</span><br><span class="line">  display: flex;         </span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下<br><img src="/2020/01/19/%E5%85%B3%E4%BA%8Ecanvas%E5%85%83%E7%B4%A0%E5%92%8CCSS%E4%B8%AD%E7%9A%84flex%E5%B1%9E%E6%80%A7/flex_layout1.PNG" alt="flex_layout1.PNG"><br>我们只要在HTML代码里面多加两个li元素，导航便弹性变化,不需要改动CSS代码<br><img src="/2020/01/19/%E5%85%B3%E4%BA%8Ecanvas%E5%85%83%E7%B4%A0%E5%92%8CCSS%E4%B8%AD%E7%9A%84flex%E5%B1%9E%E6%80%A7/flex_layout2.PNG" alt="flex_layout2.PNG"></p>
<h3 id="关于flex那三个属性的计算问题"><a href="#关于flex那三个属性的计算问题" class="headerlink" title="关于flex那三个属性的计算问题"></a>关于flex那三个属性的计算问题</h3><p>前面讲到<code>flex</code> 属性是<code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code>属性的简写属性。<br>拿一个栗子方便讲解：<br>下列布局在页面上的宽度比是多少？ <code>答案 2：3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css</span><br><span class="line">.flex &#123;</span><br><span class="line">display: flex;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">flex: 3 0 50px;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">flex: 2 0 100px;</span><br><span class="line">background: blue;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; html</span><br><span class="line">&lt;div class&#x3D;&quot;flex&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>首先我们知道外层<code>flex</code>被设置为flex布局，然后left层的<code>flex:3 0 50px</code>；意思就是放大3倍，然后<code>flex-basis</code>定为50px，意思就是宽度为50px。<br>同理看right布局，<code>flex: 2 0 100px;</code>意思是放大两倍，<code>flex-basis</code>定为100px，宽度为100px。<br>现在我们外层flex总宽度为200px，减去left的50px，再减去right的100px，剩下50px。剩下的50px按照各自的放大倍数比例去分配空间，left分到50*3/5=30px,right分到20px。所以最后left布局应该是80px，right布局应该是120px。他们的宽度比2：3</p>
<p><code>除此之外，我们要注意的是，flex-basis为0%时，表示在分配多余的空间之前。该项目已经不占据空间了，他的 width已经失效了,这个元素的width为0 ，而最后的width还是要这个元素的width加上分配完全部剩下的按放大比例分配的width。 当flex-basis为auto时，则width取值为这个元素原先设置的width。最后的width算法同上。</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>推荐阅读：<br>          <a href="https://www.cnblogs.com/yiyistar/p/6539485.html" target="_blank" rel="noopener">https://www.cnblogs.com/yiyistar/p/6539485.html</a><br>          <a href="https://www.cnblogs.com/maqunjing/p/3155180.html" target="_blank" rel="noopener">https://www.cnblogs.com/maqunjing/p/3155180.html</a></p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>JavaScript</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中prototype解析</title>
    <url>/2020/01/19/JavaScript%E4%B8%ADprototype%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客我们讲到关于JavaScript中<code>this</code>的解析，里面涉及到关于JavaScript中<code>prototype</code>的内容，讲的内容比较限定于<code>this</code>，对此专门做一篇完整一点的，只关于<code>prototype</code>的博文<br>而与其相关的还有刷到一道前端笔试题跟其有关的<br><img src="/2020/01/19/JavaScript%E4%B8%ADprototype%E8%A7%A3%E6%9E%90/prototype.PNG" alt="prototype.PNG"></p>
<h2 id="关于prototype"><a href="#关于prototype" class="headerlink" title="关于prototype"></a>关于prototype</h2><p>所有的 JavaScript 对象都会从一个<code>prototype</code>（原型对象）中继承属性和方法：</p>
<ul>
<li>Date 对象从 Date.prototype 继承。</li>
<li>Array 对象从 Array.prototype 继承。</li>
<li>Person 对象从 Person.prototype 继承。  </li>
<li><em>所有 JavaScript 中的对象都是位于原型链顶端的 <code>Object</code> 的实例。*</em>换句话说，prototype原型链最终指向的是<code>object.prototype</code>,而  <code>object.prototype</code>对象的原型其实是一个没有任何属性和方法的<code>null对象</code><br>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。(有点像继承，跟上一篇博文我说的，有点类似JavaScript面向对象的继承)，因此<code>Date</code> 对象, <code>Array</code> 对象, 以及 <code>Person</code> 对象从 <code>Object.prototype</code> 继承。<br>而这道题目中<code>function.prototype</code>的最终指向，而JavaScript中函数其实也是个对象，所以函数对象的<code>prototype</code>最终指向的还是<code>Object</code><h2 id="prototype属性的作用"><a href="#prototype属性的作用" class="headerlink" title="prototype属性的作用"></a>prototype属性的作用</h2><h3 id="构造函数的介绍"><a href="#构造函数的介绍" class="headerlink" title="构造函数的介绍"></a>构造函数的介绍</h3>要讲prototype属性的作用之前还是得先讲一下构造函数。<br>所谓构造函数，就是提供了一个生成对象的模板并描述对象的基本结构的函数。一个构造函数，可以生成多个对象，每个对象都有相同的结构。总的来说，构造函数就是对象的模板，对象就是构造函数的实例。<br>构造函数的特点有：</li>
<li>构造函数的函数名首字母必须大写。</li>
<li>内部使用this对象，来指向将要生成的对象实例。</li>
<li>使用new操作符来调用构造函数，并返回对象实例。<br>看一个简单的例子：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line"> this.name &#x3D; &#39;keith&#39;;</span><br><span class="line">&#125;</span><br><span class="line"> var boy &#x3D; new Person();</span><br><span class="line"> &#x2F;&#x2F;new之后，此时的this指向boy</span><br><span class="line">console.log(boy.name); &#x2F;&#x2F;&#39;keith&#39;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3>所有的实例对象都可以继承构造函数中的属性和方法。但是，同一个对象实例之间，无法共享属性。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name,height)&#123;</span><br><span class="line"> this.name&#x3D;name;</span><br><span class="line"> this.height&#x3D;height;</span><br><span class="line"> this.hobby&#x3D;function()&#123;</span><br><span class="line"> return &#39;watching movies&#39;;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">var boy&#x3D;new Person(&#39;keith&#39;,180);</span><br><span class="line"> var girl&#x3D;new Person(&#39;rascal&#39;,153);</span><br><span class="line"> console.log(boy.name); &#x2F;&#x2F;&#39;keith&#39;</span><br><span class="line"> console.log(girl.name); &#x2F;&#x2F;&#39;rascal&#39;</span><br><span class="line"> console.log(boy.hobby&#x3D;&#x3D;&#x3D;girl.hobby); &#x2F;&#x2F;false 按照我们的理解，男孩和女孩的兴趣应该是一样的，但是结果为false</span><br></pre></td></tr></table></figure>
上面代码中，一个构造函数Person生成了两个对象实例<code>boy</code>和<code>girl</code>，并且有两个属性和一个方法。但是，它们的<code>hobby</code>方法是不一样的。也就是说，每当你使用<code>new</code>来调用构造函数放回一个对象实例的时候，都会new一个<code>hobby</code>方法(两个方法是不一样的)，这既没有必要，又浪费资源，因为所有hobby方法都是同样的行为，完全可以被<strong>两个对象实例共享。</strong>这时候就需要<code>prototype</code>来提供帮助。<h3 id="prototype属性的作用-1"><a href="#prototype属性的作用-1" class="headerlink" title="prototype属性的作用"></a>prototype属性的作用</h3>为了解决构造函数的对象实例之间无法共享属性的缺点，js提供了prototype属性。上面的例子改一下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name,height)&#123;</span><br><span class="line">this.name&#x3D;name;</span><br><span class="line">this.height&#x3D;height;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.hobby&#x3D;function()&#123;</span><br><span class="line">return &#39;watching movies&#39;;</span><br><span class="line">&#125;</span><br><span class="line">var boy&#x3D;new Person(&#39;keith&#39;,180);</span><br><span class="line">var girl&#x3D;new Person(&#39;rascal&#39;,153);</span><br><span class="line">console.log(boy.name); &#x2F;&#x2F;&#39;keith&#39;</span><br><span class="line">console.log(girl.name); &#x2F;&#x2F;&#39;rascal&#39;</span><br><span class="line">console.log(boy.hobby&#x3D;&#x3D;&#x3D;girl.hobby); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
这里把<code>hobby</code>方法放在<code>Person</code>的原型对象的属性里面了，这样你无论<code>new</code>多少个<code>person</code>实例，他们的<code>hobby</code>方法都是继承Person原型的那个<code>hobby</code>方法，都是一样的。<br>但是要记住<strong>原型对象的属性不是对象实例的属性。</strong>对象实例的属性是继承自构造函数定义的属性，因为构造函数内部有一个<code>this</code>关键字来指向将要生成的对象实例。<br>因此当修改了原型对象的hobby方法之后，两个对象实例都发生了变化。这是因为对象实例其实是没有hobby方法，都是读取person原型对象的hobby方法。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boy.hobby&#x3D;function()&#123;</span><br><span class="line"> return &#39;play basketball&#39;;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(boy.hobby()); &#x2F;&#x2F;&#39;play basketball&#39;</span><br><span class="line"> console.log(girl.hobby()); &#x2F;&#x2F;&#39;watching movies&#39;</span><br></pre></td></tr></table></figure>
上面代码中，<strong><code>boy</code>对象实例的hobby方法修改时，就不会在继承原型对象上的hobby方法了</strong>。不过girl仍然会继承原型对象的方法。也就是说当你重写跟原型对象一样(或者便于理解，说成父类)的相同属性或者方法时，就一定按子类重写的那个属性或方法为主，如果没有重写，就继承父类的。<h2 id="原型链-prototype-chains"><a href="#原型链-prototype-chains" class="headerlink" title="原型链(prototype chains)"></a>原型链(prototype chains)</h2>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型对象本身对于对象实例来说也是对象，它也有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。所有一切的对象的原型顶端，都是<code>Object.prototype</code>，即Object构造函数的<code>prototype</code>属性指向的那个对象。<br>当然，<code>Object.prototype对象</code>也有自己的原型对象，那就是没有任何属性和方法的<code>null对象</code>，而<code>null对象</code>没有自己的原型。<br>原型链的特点有：</li>
<li>读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。</li>
<li>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”<code>（overiding）</code>。</li>
<li>一级级向上在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链</li>
</ul>
<h2 id="顺便补充讲一下proto"><a href="#顺便补充讲一下proto" class="headerlink" title="顺便补充讲一下proto"></a>顺便补充讲一下<em>proto</em></h2><p><code>_proto_</code>属性，<strong>用来读取或设置当前对象的<code>prototype对象</code>。</strong>目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; es5 的写法</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  method: function() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ &#x3D; someOtherObj;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6 的写法</span><br><span class="line">var obj &#x3D; Object.create(someOtherObj);</span><br><span class="line">obj.method &#x3D; function() &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>然鹅ES6并没有把它写进去，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替这个<code>_proto_</code>属性。</p>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p>也就是<code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype对象</code>，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 格式</span><br><span class="line">Object.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用法</span><br><span class="line">const o &#x3D; Object.setPrototypeOf(&#123;&#125;, null);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等价于用_proto_属性</span><br><span class="line">function (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ &#x3D; proto;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一个例子更好的理解<code>Object.setPrototypeOf</code>的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let proto &#x3D; &#123;&#125;;</span><br><span class="line">let obj &#x3D; &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">&#x2F;&#x2F;设置obj的原型时proto</span><br><span class="line">proto.y &#x3D; 20;</span><br><span class="line">proto.z &#x3D; 40;</span><br><span class="line">&#x2F;&#x2F;给proto新增属性，同时obj也会继承</span><br><span class="line">obj.x &#x2F;&#x2F; 10</span><br><span class="line">obj.y &#x2F;&#x2F; 20</span><br><span class="line">obj.z &#x2F;&#x2F; 40</span><br></pre></td></tr></table></figure>
<p>如果第一个参数不是对象，会自动转为对象。但是<strong>由于返回的还是第一个参数，</strong>所以这个操作不会产生任何效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.setPrototypeOf(1, &#123;&#125;) &#x3D;&#x3D;&#x3D; 1 &#x2F;&#x2F; true</span><br><span class="line">Object.setPrototypeOf(&#39;foo&#39;, &#123;&#125;) &#x3D;&#x3D;&#x3D; &#39;foo&#39; &#x2F;&#x2F; true</span><br><span class="line">Object.setPrototypeOf(true, &#123;&#125;) &#x3D;&#x3D;&#x3D; true &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.setPrototypeOf(undefined, &#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; TypeError: Object.setPrototypeOf called on null or undefined</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(null, &#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; TypeError: Object.setPrototypeOf called on null or undefined</span><br></pre></td></tr></table></figure>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Rectangle() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rec &#x3D; new Rectangle();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(rec) &#x3D;&#x3D;&#x3D; Rectangle.prototype</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(rec, Object.prototype);</span><br><span class="line">Object.getPrototypeOf(rec) &#x3D;&#x3D;&#x3D; Rectangle.prototype</span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>如果参数不是对象，会被自动转为对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 等同于 Object.getPrototypeOf(Number(1))</span><br><span class="line">Object.getPrototypeOf(1)</span><br><span class="line">&#x2F;&#x2F; Number &#123;[[PrimitiveValue]]: 0&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于 Object.getPrototypeOf(String(&#39;foo&#39;))</span><br><span class="line">Object.getPrototypeOf(&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于 Object.getPrototypeOf(Boolean(true))</span><br><span class="line">Object.getPrototypeOf(true)</span><br><span class="line">&#x2F;&#x2F; Boolean &#123;[[PrimitiveValue]]: false&#125;</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(1) &#x3D;&#x3D;&#x3D; Number.prototype &#x2F;&#x2F; true</span><br><span class="line">Object.getPrototypeOf(&#39;foo&#39;) &#x3D;&#x3D;&#x3D; String.prototype &#x2F;&#x2F; true</span><br><span class="line">Object.getPrototypeOf(true) &#x3D;&#x3D;&#x3D; Boolean.prototype &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.getPrototypeOf(null)</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot convert undefined or null to object</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(undefined)</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot convert undefined or null to object</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考阅读：<a href="https://www.cnblogs.com/douyage/p/8630529.html" target="_blank" rel="noopener">https://www.cnblogs.com/douyage/p/8630529.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript this解析</title>
    <url>/2020/01/17/JavaScriptthis%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想码这篇博文的动力是源于刷了网易2020年正式批的前端笔试题，里面有一道涉及到关于JavaScript this的问题。</p>
<p><img src="/2020/01/17/JavaScriptthis%E8%A7%A3%E6%9E%90/this.png" alt="this.png"> </p>
<p>由于这道题是我瞎蒙的，所以真正的解题思路是什么样的，我想真真正正了解一下。顺便全面地了解JavaScript的this</p>
<h2 id="不同环境中的this含义不一样"><a href="#不同环境中的this含义不一样" class="headerlink" title="不同环境中的this含义不一样"></a>不同环境中的this含义不一样</h2><h3 id="全局中的this"><a href="#全局中的this" class="headerlink" title="全局中的this"></a>全局中的this</h3><h4 id="浏览器环境下"><a href="#浏览器环境下" class="headerlink" title="浏览器环境下"></a>浏览器环境下</h4><p>在浏览器里，在全局范围内，<code>this</code>等价于<code>window</code>对象。用<code>var</code>声明一个变量和给<code>this</code>或者window添加属性是等价的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   console.log(this &#x3D;&#x3D;&#x3D; window) &#x2F;&#x2F;true</span><br><span class="line">   </span><br><span class="line">   var a &#x3D; 3;</span><br><span class="line">   console.log(this.a, window.a)&#x2F;&#x2F;3  3</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><code>说明：在浏览器中window对象同时也是全局对象</code></p>
<h4 id="node环境中"><a href="#node环境中" class="headerlink" title="node环境中"></a>node环境中</h4><p>在<code>node</code>环境里，在全局范围内，如果你用<code>REPL</code>(通过执行一个js文件来运行你的代码)执行一个脚本文件，用<code>var</code>声明一个变量并不会和在浏览器里面一样将这个变量添加给<code>this</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.js 文件在node环境中执行</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &quot;bar&quot;;</span><br><span class="line">console.log(this.foo);&#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>
<p>但是如果你不是用<code>REPL</code>执行脚本文件，而是直接执行代码，结果和在浏览器里面是一样的(神坑)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var foo &#x3D; &quot;bar&quot;;</span><br><span class="line">&gt; this.foo</span><br><span class="line">bar</span><br><span class="line">&gt; global.foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>在<code>node</code>环境里，用REPL运行脚本文件的时候，如果在声明变量的时候没有使用<code>var</code>或者<code>let</code>，这个变量会自动添加到<code>global</code>对象，但是不会自动添加给<code>this</code>对象。如果是直接执行代码，则会同时添加给<code>global</code>和<code>this</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.js 文件在node环境中执行</span><br><span class="line"></span><br><span class="line"> foo &#x3D; &quot;bar&quot;;</span><br><span class="line"> console.log(this.foo);&#x2F;&#x2F;undefined</span><br><span class="line"> console.log(global.foo);&#x2F;&#x2F;bar</span><br></pre></td></tr></table></figure>
<h3 id="函数-function-中的this"><a href="#函数-function-中的this" class="headerlink" title="函数(function)中的this"></a>函数(function)中的this</h3><p>如果不是用new调用，在函数里面使用this都是指代全局范围的this。无论是浏览器环境还是node环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">testa()</span><br><span class="line">function testa()&#123;</span><br><span class="line">     testb()</span><br><span class="line">    function testb()&#123;</span><br><span class="line">        console.log(this &#x3D;&#x3D;&#x3D; window)&#x2F;&#x2F;true</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;在node环境下</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">index.js 文件在node环境中执行</span><br><span class="line"></span><br><span class="line">foo &#x3D; &quot;bar&quot;;</span><br><span class="line"></span><br><span class="line">function testThis () &#123;</span><br><span class="line">  this.foo &#x3D; &quot;foo&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(global.foo);&#x2F;&#x2F;bar</span><br><span class="line">testThis();</span><br><span class="line">console.log(global.foo);&#x2F;&#x2F;foo</span><br></pre></td></tr></table></figure>
<p>如果你在调用函数的时候在前面使用了new，this就会变成一个新的值，和global的this脱离干系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">      foo &#x3D; &quot;bar&quot;;</span><br><span class="line">  </span><br><span class="line">      function testThis() &#123;</span><br><span class="line">        this.foo &#x3D; &quot;foo&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      console.log(this.foo); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line">      new testThis();</span><br><span class="line">     console.log(this.foo); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line"> </span><br><span class="line">     console.log(new testThis().foo); &#x2F;&#x2F;logs &quot;foo&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>如果想把<code>this</code>的值从一个环境传到另一个环境，就要用到<code>call</code>或者<code>apply</code>的方法。也就是说<code>call</code>和<code>apply</code>都能改变函数调用者即(<code>this</code>)的走向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。</span><br><span class="line">var obj &#x3D; &#123;a: &#39;Custom&#39;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个属性是在global对象定义的。</span><br><span class="line">var a &#x3D; &#39;Global&#39;;</span><br><span class="line"></span><br><span class="line">function whatsThis(arg) &#123;</span><br><span class="line">  return this.a;  &#x2F;&#x2F; this的值取决于函数的调用方式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whatsThis();          &#x2F;&#x2F; &#39;Global&#39;</span><br><span class="line">whatsThis.call(obj);  &#x2F;&#x2F; &#39;Custom&#39;</span><br><span class="line">whatsThis.apply(obj); &#x2F;&#x2F; &#39;Custom&#39;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="然鹅js的call和apply有什么不同呢？"><a href="#然鹅js的call和apply有什么不同呢？" class="headerlink" title="然鹅js的call和apply有什么不同呢？"></a>然鹅js的call和apply有什么不同呢？</h4><p>首先看一下这两个函数的原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.call(newObj, arg1, arg2, ...);</span><br><span class="line">obj.apply(newObj, [arg1, arg2, ...]);</span><br></pre></td></tr></table></figure>
<p>上面的都是把<code>obj</code>的<code>this</code>指向了<code>newObj</code>，这时<code>newObj</code>就继承了obj的属性和方法。<strong>两者区别是接收的参数不同</strong>，第一个参数都是函数运行的作用域<code>（this）</code> ,也就是让<code>this</code>指向这个参数 ,但是如果传递给 <code>this</code> 的值不是一个对象，JavaScript 会尝试使用内部 <code>ToObject</code>操作将其转换为对象。因此，如果传递的值是一个原始值比如 <code>7</code>或 <code>‘foo’</code>，那么就会使用相关构造函数将它转换为对象，所以原始值 <code>7</code>会被转换为对象，像 new Number(7) 这样，而字符串 <code>‘foo’</code>转化成 new String(‘foo’)<br><code>apply</code>第二个参数接受的是数组参数，如果没有提供<code>argArray</code>和<code>newObj</code>任何一个参数，那么<code>Global对象</code>将用作<code>newObj</code>。<br><code>call</code>接受的是连续参数，如果没有提供<code>newObj</code>参数，那么<code>Global对象</code>被用于<code>newObj</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(c,d)&#123;</span><br><span class="line">    return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s &#x3D; &#123;a:1, b:2&#125;;</span><br><span class="line">console.log(add.call(s,3,4)); &#x2F;&#x2F; 1+2+3+4 &#x3D; 10</span><br><span class="line">console.log(add.apply(s,[5,6])); &#x2F;&#x2F; 1+2+5+6 &#x3D; 14</span><br></pre></td></tr></table></figure>
<h4 id="除了call和apply之外的bind"><a href="#除了call和apply之外的bind" class="headerlink" title="除了call和apply之外的bind"></a>除了call和apply之外的bind</h4><p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>。调用<code>f.bind(someObject)</code>会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code>将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。也就是说bind只生效一次，生效之后，永远将<code>this</code>绑定在第一个参数对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">function f()&#123;</span><br><span class="line">  return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g()); &#x2F;&#x2F; azerty</span><br><span class="line"></span><br><span class="line">var h &#x3D; g.bind(&#123;a:&#39;yoo&#39;&#125;); &#x2F;&#x2F; bind只生效一次！</span><br><span class="line">console.log(h()); &#x2F;&#x2F; azerty</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123;a:37, f:f, g:g, h:h&#125;;</span><br><span class="line">console.log(o.f(), o.g(), o.h()); &#x2F;&#x2F; 37, azerty, azerty</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="prototype中的this"><a href="#prototype中的this" class="headerlink" title="prototype中的this"></a>prototype中的this</h3><p><strong>你创建的每一个函数都是函数对象</strong>，他们会自动获取<strong>一个特殊的属性<code>prototype</code>，</strong>你可以给这个属性赋值。当你用<code>new</code>的方式调用一个函数的时候，你就能通过<code>this</code>访问你给<code>prototype</code>赋的值了。而<code>prototype</code>属性的值可以是一个值也可以是一个函数。<br>当你使用<code>new</code>为你的函数创建多个实例的时候，这些实例会共享你给<code>prototype</code>设定的值。对于下面的例子，当你调用<code>this.foo</code>的时候，都会返回相同的值，除非你在某个实例里面重写了自己的<code>this.foo</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"> function Thing() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Thing.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">  Thing.prototype.logFoo &#x3D; function () &#123;</span><br><span class="line">      console.log(this.foo);</span><br><span class="line">  &#125;</span><br><span class="line">  Thing.prototype.setFoo &#x3D; function (newFoo) &#123;</span><br><span class="line">      this.foo &#x3D; newFoo;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> var thing1 &#x3D; new Thing();</span><br><span class="line"> var thing2 &#x3D; new Thing();</span><br><span class="line"> </span><br><span class="line"> thing1.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line"> thing2.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line"> </span><br><span class="line"> thing1.setFoo(&quot;foo&quot;);</span><br><span class="line"> thing1.logFoo(); &#x2F;&#x2F;logs &quot;foo&quot;;</span><br><span class="line"> thing2.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;;</span><br><span class="line"> </span><br><span class="line"> thing2.foo &#x3D; &quot;foobar&quot;;</span><br><span class="line"> thing1.logFoo(); &#x2F;&#x2F;logs &quot;foo&quot;;</span><br><span class="line"> thing2.logFoo(); &#x2F;&#x2F;logs &quot;foobar&quot;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>但是记住当你给函数实例对象的属性<code>foo</code>赋值时候，实惠改变<code>this</code>的指向，但是函数对象<code>prototype.foo</code>还是原来那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">function Thing() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Thing.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">  Thing.prototype.logFoo &#x3D; function () &#123;</span><br><span class="line">      console.log(this.foo, Thing.prototype.foo);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  var thing &#x3D; new Thing();</span><br><span class="line">  thing.foo &#x3D; &quot;foo&quot;;</span><br><span class="line">  thing.logFoo(); &#x2F;&#x2F;logs &quot;foo bar&quot;;</span><br><span class="line">  delete thing.foo; &#x2F;&#x2F;函数对象的属性可以删除</span><br><span class="line"> thing.logFoo(); &#x2F;&#x2F;logs &quot;bar bar&quot;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="而如果将bind-call-apply和prototype联系起来会怎么样"><a href="#而如果将bind-call-apply和prototype联系起来会怎么样" class="headerlink" title="而如果将bind, call, apply和prototype联系起来会怎么样"></a>而如果将bind, call, apply和prototype联系起来会怎么样</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  function Thing() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Thing.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">   </span><br><span class="line">  function logFoo(aStr) &#123;</span><br><span class="line">      console.log(aStr, this.foo);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;这里 logFoo是一个新的函数对象，并不是Thing的prototype里面的属性 </span><br><span class="line"> var thing &#x3D; new Thing();</span><br><span class="line"> logFoo.bind(thing)(&quot;using bind&quot;); &#x2F;&#x2F;logs &quot;using bind bar&quot;</span><br><span class="line"> logFoo.apply(thing, [&quot;using apply&quot;]); &#x2F;&#x2F;logs &quot;using apply bar&quot;</span><br><span class="line"> logFoo.call(thing, &quot;using call&quot;); &#x2F;&#x2F;logs &quot;using call bar&quot;</span><br><span class="line"> logFoo(&quot;using nothing&quot;); &#x2F;&#x2F;logs &quot;using nothing undefined&quot;  undefined是因为此时logFoo里面的this指向的是window，而全局的foo并没有定义</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>这种prototype的方式，被称为原型链，有点像JavaScript中面向对象中的继承方式。函数对象的prototype属性就像是函数对象继承来的一样。而prototype属性也刚好有值，有函数。<br>但是有种情况需要特别注意一下，虽然说是很想继承关系，但是任何给用于构建原型链的函数的<code>this</code>的赋值的语句都会隐藏原型链上游的相同的属性。也就是说，如果子类已经声明相同属性foo的值了，要以子类的值为主，隐藏父类的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  function Thing1() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Thing1.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">  </span><br><span class="line">  function Thing2() &#123;</span><br><span class="line">      this.foo &#x3D; &quot;foo&quot;;&#x2F;&#x2F;像这种已经声明了的，以这个为老大</span><br><span class="line">  &#125;</span><br><span class="line">  Thing2.prototype &#x3D; new Thing1();</span><br><span class="line">  </span><br><span class="line"> function Thing3() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> Thing3.prototype &#x3D; new Thing2();</span><br><span class="line"> </span><br><span class="line"> var thing &#x3D; new Thing3();</span><br><span class="line"> console.log(thing.foo); &#x2F;&#x2F;logs &quot;foo&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="对象-object-中的this"><a href="#对象-object-中的this" class="headerlink" title="对象(object)中的this"></a>对象(object)中的this</h3><p>在一个对象的一个函数里，你可以通过<code>this</code>来引用这个对象的其他属性。这个用<code>new</code>来新建一个实例是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"> var obj &#x3D; &#123;</span><br><span class="line">     foo: &quot;bar&quot;,</span><br><span class="line">     logFoo: function () &#123;</span><br><span class="line">         console.log(this.foo);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;; </span><br><span class="line"> obj.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>没有使用new，没有使用<code>Object.create</code>，也没有使用函数调用创建一个对象。你也可以将对象当作一个实例将函数绑定到上面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"> var obj &#x3D; &#123;</span><br><span class="line">     foo: &quot;bar&quot;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> function logFoo() &#123;</span><br><span class="line">     console.log(this.foo);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> logFoo.apply(obj); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>当你用这种方式使用<code>this</code>的时候，并不会越出当前的对象。只有有相同直接父元素的属性才能通过<code>this</code>共享变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  var obj &#x3D; &#123;</span><br><span class="line">      foo: &quot;bar&quot;,</span><br><span class="line">      deeper: &#123;</span><br><span class="line">          logFoo: function () &#123;</span><br><span class="line">              console.log(this.foo);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"> obj.deeper.logFoo(); &#x2F;&#x2F;logs undefined</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>但是你可以直接通过对象引用你需要的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	var obj &#x3D; &#123;</span><br><span class="line">	    foo: &quot;bar&quot;,</span><br><span class="line">	    deeper: &#123;</span><br><span class="line">	        logFoo: function () &#123;</span><br><span class="line">	            console.log(obj.foo);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	obj.deeper.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="最后是箭头函数下的this"><a href="#最后是箭头函数下的this" class="headerlink" title="最后是箭头函数下的this"></a>最后是箭头函数下的this</h3><p>箭头函数不会创建自己的this，它<strong>只会从自己的作用域链的上一层继承this。</strong>上一层找不到再去window找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">	return (a)&#x3D;&gt;&#123;</span><br><span class="line">		console.log(this.a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj1&#x3D;&#123;</span><br><span class="line">	a:2</span><br><span class="line">&#125;;</span><br><span class="line">var obj2&#x3D;&#123;</span><br><span class="line">	a:3</span><br><span class="line">&#125;;</span><br><span class="line">var bar&#x3D;foo.call(obj1);</span><br><span class="line">bar.call(obj2);  &#x2F;&#x2F;2,不是3！</span><br></pre></td></tr></table></figure>
<p><code>foo()</code>内部创建的箭头函数会捕获调用时<code>foo()</code>的<code>this</code>。由于<code>foo()</code>的<code>this</code>绑定到<code>obj1</code>，所以<code>bar</code>（引用箭头函数）的<code>this</code>也会绑定到<code>obj1</code>，箭头函数的绑定无法被修改。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基本知识</title>
    <url>/2020/01/17/JavaScript%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JavaScript是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。</p>
<h3 id="JavaScript和ES6的区别"><a href="#JavaScript和ES6的区别" class="headerlink" title="JavaScript和ES6的区别"></a>JavaScript和ES6的区别</h3><p>ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。ES6适应更复杂的应用；实现代码库之间的共享。目前只有chrome和firefox两个浏览器对ES6比较友好。</p>
<h2 id="JavaScript快速入门"><a href="#JavaScript快速入门" class="headerlink" title="JavaScript快速入门"></a>JavaScript快速入门</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>1.JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中<br>2.第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件,在这个.js文件中编写代码，更容易维护。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>{...}</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。但是我们自己编写代码的时候还有养成加<code>;</code>的习惯，避免因为引擎自动加引号，导致语义出错，而运行结果不一致的</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123; &#x2F;&#x2F; 整数123</span><br><span class="line">0.456; &#x2F;&#x2F; 浮点数0.456</span><br><span class="line">1.2345e3; &#x2F;&#x2F; 科学计数法表示1.2345x1000，等同于1234.5</span><br><span class="line">-99; &#x2F;&#x2F; 负数</span><br><span class="line">NaN; &#x2F;&#x2F; NaN表示Not a Number，当无法计算结果时用NaN表示</span><br><span class="line">Infinity; &#x2F;&#x2F; Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></pre></td></tr></table></figure>
<p>Number可以直接做四则运算，规则和数学一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + 2; &#x2F;&#x2F; 3</span><br><span class="line">(1 + 2) * 5 &#x2F; 2; &#x2F;&#x2F; 7.5</span><br><span class="line">2 &#x2F; 0; &#x2F;&#x2F; Infinity</span><br><span class="line">0 &#x2F; 0; &#x2F;&#x2F; NaN</span><br><span class="line">10 % 3; &#x2F;&#x2F; 1  % 表示求余运算</span><br><span class="line">10.5 % 3; &#x2F;&#x2F; 1.5</span><br></pre></td></tr></table></figure>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串是用单引号或双引号括起来的任意文本,如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符,如果字符串内部既包含<code>&#39;</code>,又包含<code>&quot;</code>怎么办，可以用转义字符<code>\</code>标识，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;I\&#39;m \&quot;OK\&quot;!&#39;;</span><br></pre></td></tr></table></figure>
<p>表示的字符串内容是: <code>I&#39;m &quot;OK&quot;!</code></p>
<h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>获取字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Hello world!&#39;;</span><br><span class="line">s.length; &#x2F;&#x2F;12</span><br></pre></td></tr></table></figure>
<p>获取字符串指定位置的字符，使用类似Array的下标操作，索引号从0开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Hello world!&#39;;</span><br><span class="line">s[0]; &#x2F;&#x2F;&#39;H&#39;</span><br><span class="line">s[6]; &#x2F;&#x2F;&#39; &#39;</span><br><span class="line">s[12]; &#x2F;&#x2F;undefined,超出范围不会报错，一律返回undefined</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有错误，但是也没有任何效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Test&#39;;</span><br><span class="line">s[0] &#x3D; &#39;X&#39;;</span><br><span class="line">alert(s); &#x2F;&#x2F; s仍然为&#39;Test&#39;</span><br></pre></td></tr></table></figure>
<p><code>toUpperCase()</code>把一个字符串全部变大写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Hello&#39;;</span><br><span class="line">s.toUpperCase(); &#x2F;&#x2F; 返回&#39;HELLO&#39;</span><br></pre></td></tr></table></figure>
<p><code>toLowerCase()</code>把一个字符串全部变小写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Hello&#39;;</span><br><span class="line">var lower &#x3D; s.toLowerCase(); &#x2F;&#x2F; 返回&#39;hello&#39;并赋值给变量lower</span><br><span class="line">lower; &#x2F;&#x2F; &#39;hello&#39;</span><br></pre></td></tr></table></figure>
<p><code>indexOf()</code>会搜索指定字符串中出现的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello, world&#39;;</span><br><span class="line">s.indexOf(&#39;world&#39;); &#x2F;&#x2F; 返回7</span><br><span class="line">s.indexOf(&#39;World&#39;); &#x2F;&#x2F; 没有找到指定的子串，返回-1</span><br></pre></td></tr></table></figure>
<p><code>substring()</code>返回指定索引区间的子串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello, world&#39;</span><br><span class="line">s.substring(0, 5); &#x2F;&#x2F; 从索引0开始到5（不包括5），返回&#39;hello&#39;</span><br><span class="line">s.substring(7); &#x2F;&#x2F; 从索引7开始到结束，返回&#39;world&#39;</span><br></pre></td></tr></table></figure>
<p>ES6新增了子串的识别方法：</p>
<ul>
<li>includes()：返回布尔值，判断是否找到参数字符串。</li>
<li>startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。  </li>
</ul>
<p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let string &#x3D; &quot;apple,banana,orange&quot;;</span><br><span class="line">string.includes(&quot;banana&quot;);     &#x2F;&#x2F; true</span><br><span class="line">string.startsWith(&quot;apple&quot;);    &#x2F;&#x2F; true</span><br><span class="line">string.endsWith(&quot;apple&quot;);      &#x2F;&#x2F; false</span><br><span class="line">string.startsWith(&quot;banana&quot;,6)  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>除此之外还有字符串补全的方法：</p>
<ul>
<li>padStart：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</li>
<li>padEnd：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;h&quot;.padStart(5,&quot;o&quot;));  &#x2F;&#x2F; &quot;ooooh&quot;</span><br><span class="line">console.log(&quot;h&quot;.padEnd(5,&quot;o&quot;));    &#x2F;&#x2F; &quot;hoooo&quot;</span><br><span class="line">console.log(&quot;h&quot;.padStart(5));      &#x2F;&#x2F; &quot;    h&quot;</span><br></pre></td></tr></table></figure>
如果指定的长度小于或等于原字符串的长度，则返回原字符串:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;hello&quot;.padStart(5,&quot;A&quot;));  &#x2F;&#x2F; &quot;hello&quot;</span><br></pre></td></tr></table></figure>
如果原字符串加上补全的字符串长度大于指定长度，则截去超出位数的字符串：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;hello&quot;.padEnd(10,&quot;,world!&quot;));  &#x2F;&#x2F; &quot;hello,worl&quot;</span><br></pre></td></tr></table></figure>
常用于补全位数:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;123&quot;.padStart(10,&quot;0&quot;));  &#x2F;&#x2F; &quot;0000000123&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>模板字符串相当于加强版的字符串，用反引号`,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。  </p>
<p>普通字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let string &#x3D; &#96;Hello&#39;\n&#39;world&#96;;</span><br><span class="line">console.log(string); </span><br><span class="line">&#x2F;&#x2F; &quot;Hello&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;world&quot;</span><br></pre></td></tr></table></figure>
<p>ES6支持多行字符串,省去了加<code>\n</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let string1 &#x3D;  &#96;Hey,</span><br><span class="line">can you stop angry now?&#96;;</span><br><span class="line">console.log(string1);</span><br><span class="line">&#x2F;&#x2F; Hey,</span><br><span class="line">&#x2F;&#x2F; can you stop angry now?</span><br></pre></td></tr></table></figure>
<p>之前要把多个字符串连接起来，需要用<code>+</code>号连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;小明&#39;;</span><br><span class="line">var age &#x3D; 20;</span><br><span class="line">var message &#x3D; &#39;你好, &#39; + name + &#39;, 你今年&#39; + age + &#39;岁了!&#39;;</span><br><span class="line">alert(message);   &#x2F;&#x2F; 你好小明，你今年20岁了</span><br></pre></td></tr></table></figure>
<p>但是ES6的模板字符串，<strong>支持在字符串中加入变量和表达式</strong><br>变量名写在<code>${}</code>中，<code>${}</code>还可以放入JavaScript 表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name &#x3D; &quot;Mike&quot;;</span><br><span class="line">let age &#x3D; 27;</span><br><span class="line">let info &#x3D; &#96;My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.&#96;</span><br><span class="line">console.log(info);</span><br><span class="line">&#x2F;&#x2F; My Name is Mike,I am 28 years old next year.</span><br></pre></td></tr></table></figure>
<p>字符串中调用函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  return &quot;have fun!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">let string2&#x3D; &#96;Game start,$&#123;f()&#125;&#96;;</span><br><span class="line">console.log(string2);  &#x2F;&#x2F; Game start,have fun!</span><br></pre></td></tr></table></figure>
<p><strong><code>注意要点:模板字符串中的换行和空格都是会被保留的</code></strong></p>
<h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>true</code>、<code>false</code>两种值，要么是<code>true</code>，要么是<code>false</code>，可以直接用<code>true</code>、<code>false</code>表示布尔值，也可以通过布尔运算计算出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true; &#x2F;&#x2F; 这是一个true值</span><br><span class="line">false; &#x2F;&#x2F; 这是一个false值</span><br><span class="line">2 &gt; 1; &#x2F;&#x2F; 这是一个true值</span><br><span class="line">2 &gt;&#x3D; 3; &#x2F;&#x2F; 这是一个false值</span><br></pre></td></tr></table></figure>
<p>在JavaScript在设计时，有两种比较运算符：  </p>
<ul>
<li>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；  </li>
<li>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。<br>由于JavaScript这个设计缺陷，不要使用<code>==</code>比较，始终坚持使用<code>===</code>比较。<br>另一个例外是<code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isNaN(NaN); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
而需要注意的是浮点数的比较：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &#x2F; 3 &#x3D;&#x3D;&#x3D; (1 - 2 &#x2F; 3); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.abs(1 &#x2F; 3 - (1 - 2 &#x2F; 3)) &lt; 0.0000001; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4>null 表示一个”空”的值，它和 <code>0</code>和空字符串<code>&#39;&#39;</code>,<code>0</code>表示一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而null表示为”空”。<br>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。然鹅区分的意义不是很大，大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3.14, &#39;Hello&#39;, null, true];</span><br></pre></td></tr></table></figure>
另一种创建数组的方法是通过<code>Array()</code>函数实现的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Array(1, 2, 3); &#x2F;&#x2F; 创建了数组[1, 2, 3]</span><br></pre></td></tr></table></figure>
然鹅，出于对代码的可读性考虑，建议直接使用<code>[]</code><br>数组的值可以用索引来访问，索引的起始值是0：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3.14, &#39;Hello&#39;, null, true];</span><br><span class="line">arr[0]; &#x2F;&#x2F; 返回索引为0的元素，即1</span><br><span class="line">arr[5]; &#x2F;&#x2F; 返回索引为5的元素，即true</span><br><span class="line">arr[6]; &#x2F;&#x2F; 索引超出了范围，返回undefined</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>indexOf</strong><br>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];</span><br><span class="line">arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0</span><br><span class="line">arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1</span><br><span class="line">arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2</span><br></pre></td></tr></table></figure>

<p><strong>slice</strong><br><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];</span><br><span class="line">arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br><span class="line">arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span><br></pre></td></tr></table></figure>
<p>如果不给<code>slice()</code>指定参数，默认是从头截到尾，我们也可以用这个方法来复制一个数组  </p>
<p><strong>push和pop</strong>  </p>
<p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2];</span><br><span class="line">arr.push(&#39;A&#39;, &#39;B&#39;); &#x2F;&#x2F; 返回Array新的长度: 4</span><br><span class="line">arr; &#x2F;&#x2F; [1, 2, &#39;A&#39;, &#39;B&#39;]</span><br><span class="line">arr.pop(); &#x2F;&#x2F; pop()返回&#39;B&#39;</span><br><span class="line">arr; &#x2F;&#x2F; [1, 2, &#39;A&#39;]</span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); &#x2F;&#x2F; 连续pop 3次</span><br><span class="line">arr; &#x2F;&#x2F; []</span><br><span class="line">arr.pop(); &#x2F;&#x2F; 空数组继续pop不会报错，而是返回undefined</span><br><span class="line">arr; &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>
<p><strong>unshift和shift</strong><br>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2];</span><br><span class="line">arr.unshift(&#39;A&#39;, &#39;B&#39;); &#x2F;&#x2F; 返回Array新的长度: 4</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, 1, 2]</span><br><span class="line">arr.shift(); &#x2F;&#x2F; &#39;A&#39;</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;B&#39;, 1, 2]</span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); &#x2F;&#x2F; 连续shift 3次</span><br><span class="line">arr; &#x2F;&#x2F; []</span><br><span class="line">arr.shift(); &#x2F;&#x2F; 空数组继续shift不会报错，而是返回undefined</span><br><span class="line">arr; &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p><strong>reverse</strong><br><code>reverse()</code>把整个<code>Array</code>的元素给掉个个，也就是反转:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];</span><br><span class="line">arr.reverse(); </span><br><span class="line">arr; &#x2F;&#x2F; [&#39;three&#39;, &#39;two&#39;, &#39;one&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>splice</strong><br><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];</span><br><span class="line">&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>concat</strong><br> <code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">var added &#x3D; arr.concat([1, 2, 3]);</span><br><span class="line">added; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br></pre></td></tr></table></figure>
<p>请注意 <code>concat()</code>方法并没有修改原来的<code>Array</code>,只是返回一个新的<code>Array</code><br>实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">arr.concat(1, 2, [3, 4]); &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p><strong>join</strong><br><code>join()</code>方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后<strong>返回连接后的字符串</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">arr.concat(1, 2, [3, 4]); &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [&#39;小明&#39;, &#39;小红&#39;, &#39;大军&#39;, &#39;阿黄&#39;];</span><br><span class="line">console.log(&#39;欢迎&#39;+arr.join(&#39;,&#39;)); &#x2F;&#x2F;欢迎小明,小红,大军,阿黄</span><br></pre></td></tr></table></figure>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &#39;Bob&#39;,</span><br><span class="line">    age: 20,</span><br><span class="line">    tags: [&#39;js&#39;, &#39;web&#39;, &#39;mobile&#39;],</span><br><span class="line">    city: &#39;Beijing&#39;,</span><br><span class="line">    hasCar: true,</span><br><span class="line">    zipcode: null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要访问到对象的属性，我们只需要用<code>对象名.属性名</code>的方式。<br>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; undefined</span><br><span class="line">xiaoming.age &#x3D; 18; &#x2F;&#x2F; 新增一个age属性</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; 18</span><br><span class="line">delete xiaoming.age; &#x2F;&#x2F; 删除age属性</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; undefined</span><br><span class="line">delete xiaoming[&#39;name&#39;]; &#x2F;&#x2F; 删除name属性</span><br><span class="line">xiaoming.name; &#x2F;&#x2F; undefined</span><br><span class="line">delete xiaoming.school; &#x2F;&#x2F; 删除一个不存在的school属性也不会报错</span><br></pre></td></tr></table></figure>
<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;,</span><br><span class="line">    birth: 1990,</span><br><span class="line">    school: &#39;No.1 Middle School&#39;,</span><br><span class="line">    height: 1.70,</span><br><span class="line">    weight: 65,</span><br><span class="line">    score: null</span><br><span class="line">&#125;;</span><br><span class="line">&#39;name&#39; in xiaoming; &#x2F;&#x2F; true</span><br><span class="line">&#39;grade&#39; in xiaoming; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>但是<code>in</code>判断一个属性是否存在，这个属性可能是这个对象继承得到的，并非自己有的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;toString&#39; in xiaoming; &#x2F;&#x2F; true toString是每个object对象都有的属性</span><br></pre></td></tr></table></figure>
<p>所以要判断一个属性是否是对象自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(&#39;name&#39;); &#x2F;&#x2F; true</span><br><span class="line">xiaoming.hasOwnProperty(&#39;toString&#39;); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。申明一个变量用<code>var</code>语句，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a; &#x2F;&#x2F; 申明了变量a，此时a的值为undefined</span><br><span class="line">var $b &#x3D; 1; &#x2F;&#x2F; 申明了变量$b，同时给$b赋值，此时$b的值为1</span><br><span class="line">var s_007 &#x3D; &#39;007&#39;; &#x2F;&#x2F; s_007是一个字符串</span><br><span class="line">var Answer &#x3D; true; &#x2F;&#x2F; Answer是一个布尔值true</span><br><span class="line">var t &#x3D; null; &#x2F;&#x2F; t的值是null</span><br></pre></td></tr></table></figure>
<p>在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，<strong>但是要注意只能用<code>var</code>申明一次</strong>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123</span><br><span class="line">a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串</span><br></pre></td></tr></table></figure>
<p>这种变量本身类型不固定的语言称之为动态语言，与之相对应的是静态语言，静态语言在定义变量的时候必须指定变量类型，如果赋值的时候，类型不匹配，就会报错，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 123; &#x2F;&#x2F; a是整数类型变量，类型用int申明</span><br><span class="line">a &#x3D; &quot;ABC&quot;; &#x2F;&#x2F; 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure>
<p>与静态语言相比，动态语言更灵活就是这样的原因。</p>
<h4 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h4><p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为<strong>全局变量</strong>：(这是一个设计缺陷)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 10; &#x2F;&#x2F; i现在是全局变量</span><br></pre></td></tr></table></figure>
<p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，<strong>强制通过<code>var</code>申明变量</strong>，未使用<code>var</code>申明变量就使用的，将导致运行错误。<br>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">    name: &#39;Jack&#39;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &#39;Beijing&#39;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    if (o.hasOwnProperty(key)) &#123; &#x2F;&#x2F;过滤掉非继承得来的属性</span><br><span class="line">        console.log(key); &#x2F;&#x2F; &#39;name&#39;, &#39;age&#39;, &#39;city&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">    console.log(i); &#x2F;&#x2F; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;</span><br><span class="line">    console.log(a[i]); &#x2F;&#x2F; &#39;A&#39;, &#39;B&#39;, &#39;C&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>请注意，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</strong></p>
<h3 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h3><p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code>是一组键值对的结构，具有极快的查找速度。用JavaScript写一个Map如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]);</span><br><span class="line">m.get(&#39;Michael&#39;); &#x2F;&#x2F; 95</span><br></pre></td></tr></table></figure>
<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map(); &#x2F;&#x2F; 空Map</span><br><span class="line">m.set(&#39;Adam&#39;, 67); &#x2F;&#x2F; 添加新的key-value</span><br><span class="line">m.set(&#39;Bob&#39;, 59);</span><br><span class="line">m.has(&#39;Adam&#39;); &#x2F;&#x2F; 是否存在key &#39;Adam&#39;: true</span><br><span class="line">m.get(&#39;Adam&#39;); &#x2F;&#x2F; 67</span><br><span class="line">m.delete(&#39;Adam&#39;); &#x2F;&#x2F; 删除key &#39;Adam&#39;</span><br><span class="line">m.get(&#39;Adam&#39;); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map();</span><br><span class="line">m.set(&#39;Adam&#39;, 67);</span><br><span class="line">m.set(&#39;Adam&#39;, 88);</span><br><span class="line">m.get(&#39;Adam&#39;); &#x2F;&#x2F; 88</span><br></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>Set</code>和<code>Map</code>类似，也是一组<code>key</code>的集合，但不存储<code>value</code>。由于<code>key</code>不能重复，所以，在<code>Set</code>中，没有重复的<code>key</code>。<br>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s1 &#x3D; new Set(); &#x2F;&#x2F; 空Set</span><br><span class="line">var s2 &#x3D; new Set([1, 2, 3]); &#x2F;&#x2F; 含1, 2, 3</span><br></pre></td></tr></table></figure>
<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set([1, 2, 3, 3, &#39;3&#39;]);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3, &quot;3&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。<br>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; 仍然是 Set &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set([1, 2, 3]);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3&#125;</span><br><span class="line">s.delete(3);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h3><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。<br>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。<br><code>for...of</code> 是 ES6 新引入的循环，用于替代 <code>for..in</code> 和 <code>forEach()</code> ，并且支持新的迭代协议。它可用于迭代常规的数据类型，如 <code>Array</code> 、 <code>String</code> 、 <code>Map</code> 和 <code>Set</code> 等等。<br>用<code>for ... of</code>循环遍历集合，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">var s &#x3D; new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);</span><br><span class="line">var m &#x3D; new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);</span><br><span class="line">for (var x of a) &#123; &#x2F;&#x2F; 遍历Array</span><br><span class="line">    console.log(x); &#x2F;&#x2F; A \n B \n C</span><br><span class="line">&#125;</span><br><span class="line">for (var x of s) &#123; &#x2F;&#x2F; 遍历Set</span><br><span class="line">    console.log(x); &#x2F;&#x2F;A \n B \n C</span><br><span class="line">&#125;</span><br><span class="line">for (var x of m) &#123; &#x2F;&#x2F; 遍历Map</span><br><span class="line">    console.log(x[0] + &#39;&#x3D;&#39; + x[1]);</span><br><span class="line">&#125;&#x2F;&#x2F; 1&#x3D;x  \n 2&#x3D;y  \n 3&#x3D;z</span><br></pre></td></tr></table></figure>
<p><code>for ... of</code>循环和<code>for ... in</code>循环有何区别？<br><code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个<code>Array</code>数组实际上也是一个对象，它的<strong>每个元素的索引被视为一个属性</strong>。<br>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">a.name &#x3D; &#39;Hello&#39;;</span><br><span class="line">for (var x in a) &#123;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; &#39;0&#39;,\n &#39;1&#39;,\n &#39;2&#39;, &#39;name&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for ... in</code>循环将把<code>name</code>包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。<br><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">a.name &#x3D; &#39;Hello&#39;;</span><br><span class="line">for (var x of a) &#123;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; &#39;A&#39;,\n &#39;B&#39;,\n &#39;C&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">a.forEach(function (element, index, array) &#123;</span><br><span class="line">    &#x2F;&#x2F; element: 指向当前元素的值</span><br><span class="line">    &#x2F;&#x2F; index: 指向当前索引</span><br><span class="line">    &#x2F;&#x2F; array: 指向Array对象本身</span><br><span class="line">    console.log(element + &#39;, index &#x3D; &#39; + index);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;A, index &#x3D; 0</span><br><span class="line">&#x2F;&#x2F;B, index &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;C, index &#x3D; 2</span><br></pre></td></tr></table></figure>
<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);</span><br><span class="line">s.forEach(function (element, sameElement, set) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Map</code>的回调函数参数依次为value、key和map本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);</span><br><span class="line">m.forEach(function (value, key, map) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">a.forEach(function (element) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/w3cnote/es6-tutorial.html" target="_blank" rel="noopener">ES6教程</a><br>基本数据类型和引用数据类型的区别：<a href="https://www.cnblogs.com/c2016c/articles/9328725.html" target="_blank" rel="noopener">https://www.cnblogs.com/c2016c/articles/9328725.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo categories和tags页面不显示解决办法</title>
    <url>/2020/01/12/hexo%20categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="解决hexo-categories和tags页面不显示解决办法"><a href="#解决hexo-categories和tags页面不显示解决办法" class="headerlink" title="解决hexo categories和tags页面不显示解决办法"></a>解决hexo categories和tags页面不显示解决办法</h2><h3 id="第一步-需要新建tags和categories页面"><a href="#第一步-需要新建tags和categories页面" class="headerlink" title="第一步 需要新建tags和categories页面"></a>第一步 需要新建tags和categories页面</h3><p>在终端powershell下，确保此时是在hexo目录下，命令行输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags //新建tags页面</span><br></pre></td></tr></table></figure>
<p>然后会在hexo下的source目录看到tags文件夹，在index.md里输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-01-10 16:14:33</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">layout: <span class="string">"tags"</span>   <span class="comment">#增加tags的布局</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后再用同样的方法，新建一个categories</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories //新建categories页面</span><br></pre></td></tr></table></figure>
<p>然后配置categories 文件夹下的index.md</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-01-10 16:15:43</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">layout: <span class="string">"categories"</span>    <span class="comment">#增加categories的布局</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="第二步-给自己的帖子新加配置-增加tags和categories"><a href="#第二步-给自己的帖子新加配置-增加tags和categories" class="headerlink" title="第二步 给自己的帖子新加配置,增加tags和categories"></a>第二步 给自己的帖子新加配置,增加tags和categories</h3><p>例如我自己的一篇博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo categories和tags页面不显示解决办法</span><br><span class="line">date: 2020-01-12 17:22:40</span><br><span class="line">tags: 前端</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>但是就这样部署到github上是，访问自己的域名服务器，打开分类界面和标签界面都是404</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>打开theme目录下的主题配置文件_config.yml,按ctrl-f，搜索menu:，然后把/后面的空格去掉（刚开始的时候默认后面是加了空格所以导致的点击页面出现的404）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">   <span class="comment">#这/后面的空格得去掉，否则点击访问标签页和分类页的时候会404报错</span></span><br><span class="line">  home: /|| home <span class="comment">#首页</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br></pre></td></tr></table></figure>
<h2 id="给自己的post中的代码块增加一键复制功能"><a href="#给自己的post中的代码块增加一键复制功能" class="headerlink" title="给自己的post中的代码块增加一键复制功能"></a>给自己的post中的代码块增加一键复制功能</h2><h3 id="第一步-下载clipboard-js"><a href="#第一步-下载clipboard-js" class="headerlink" title="第一步 下载clipboard.js"></a>第一步 下载clipboard.js</h3><p>下载第三方插件<a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js" target="_blank" rel="noopener">clipboard.js</a>，打开之后，右键另存为，保存文件再theme/next/source/js/src目录下</p>
<h3 id="第二步-clipboard-js的使用"><a href="#第二步-clipboard-js的使用" class="headerlink" title="第二步 clipboard.js的使用"></a>第二步 clipboard.js的使用</h3><p>也是在theme/next/source/js/src目录下，创建 clipboard-use.js，添加内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*页面载入完成后，创建复制按钮*/</span><br><span class="line">!<span class="keyword">function</span> (e, t, a) &#123; </span><br><span class="line">  /* code */</span><br><span class="line">  var initCopyCode = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var copyHtml = <span class="string">''</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;span&gt;复制&lt;/span&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">    $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">    new ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">        target: <span class="keyword">function</span>(trigger) &#123;</span><br><span class="line">            <span class="built_in">return</span> trigger.nextElementSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure>
<p>然后再theme/next/source/css/_custom/custom.styl 样式中添加如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//代码块复制按钮</span><br><span class="line">.highlight&#123;</span><br><span class="line">  //方便copy代码按钮（btn-copy）的定位</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    background-color: <span class="comment">#eee;</span></span><br><span class="line">    background-image: linear-gradient(<span class="comment">#fcfcfc,#eee);</span></span><br><span class="line">    border: 1px solid <span class="comment">#d5d5d5;</span></span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">    -webkit-appearance: none;</span><br><span class="line">    font-size: 13px;</span><br><span class="line">    font-weight: 700;</span><br><span class="line">    line-height: 20px;</span><br><span class="line">    color: <span class="comment">#333;</span></span><br><span class="line">    -webkit-transition: opacity .3s ease-in-out;</span><br><span class="line">    -o-transition: opacity .3s ease-in-out;</span><br><span class="line">    transition: opacity .3s ease-in-out;</span><br><span class="line">    padding: 2px 6px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 5px;</span><br><span class="line">    top: 5px;</span><br><span class="line">    opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy span &#123;</span><br><span class="line">    margin-left: 5px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight:hover .btn-copy&#123;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三步-引用"><a href="#第三步-引用" class="headerlink" title="第三步 引用"></a>第三步 引用</h3><p>在 theme/next/layout/_layout.swig文件中引用(/body)结束标签之前添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 代码块复制功能 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard.min.js"</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard-use.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="第四步-运行"><a href="#第四步-运行" class="headerlink" title="第四步 运行"></a>第四步 运行</h3><p>重新 执行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean //清理之前的文件</span><br><span class="line">hexo g //生成</span><br><span class="line">hexo s //跑在本地</span><br></pre></td></tr></table></figure>
<p>打开本地localhost:4000，看复制功能是否可以正常实现。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>采用gitpages和hexo建立自己的个人博客</title>
    <url>/2019/12/27/%E9%87%87%E7%94%A8gitpages%E5%92%8Chexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从开始搭建到完成，断断续续，毕竟自己也是照着别人的文章和官方文档再做，结果变成了搭建完，先优化主题，最后才开始写这篇博客。这其中还是有些坑需要记录一下</p>
<h2 id="第一步-准备工作"><a href="#第一步-准备工作" class="headerlink" title="第一步 准备工作"></a>第一步 准备工作</h2><p>首先确保自己的node.js已经安装好，而且环境变量配置好，有自己个人的github账户。<br>接着在github上新建一个repository，命名为：你的github名称.github.io(下面是我的仓库名称)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yinjiangqaq.github.io</span><br></pre></td></tr></table></figure>

<h2 id="第二步-安装hexo"><a href="#第二步-安装hexo" class="headerlink" title="第二步 安装hexo"></a>第二步 安装hexo</h2><p>hexo其实就是一个博客框架，方便我们建站的一个框架。官网也有安装教程<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p>
<h3 id="step1："><a href="#step1：" class="headerlink" title="step1："></a>step1：</h3><p>Windows系统的话，可以不在系统盘，可以选择D盘，然后鼠标右键git bash，输入两个安装指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> npm install hexo-cli -g   //用于全局安装hexo</span><br><span class="line">npm install hexo-deployer-git --save   //用于安装hexo部署到git page的deployer</span><br></pre></td></tr></table></figure>
<h3 id="step2：-新建一个hexo文件夹"><a href="#step2：-新建一个hexo文件夹" class="headerlink" title="step2： 新建一个hexo文件夹"></a>step2： 新建一个hexo文件夹</h3><p>在D盘新建一个名为hexo的文件夹，然后再次鼠标右键git bash，输入两个指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init  //安装 hexo相关的包</span><br><span class="line">npm install   //安装node_modules和所有package.json里的包</span><br></pre></td></tr></table></figure>
<p>执行这两个指令完成之后，你会看到你的hexo文件夹多了一些文件，这时候如果你想看本地效果的话，可以执行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate  //自动将md文件生成静态html，css文件</span><br><span class="line">hexo server  //启动本地hexo服务器（localhost:4000）</span><br></pre></td></tr></table></figure>
<p>然后打开浏览器访问localhost:4000，便可以看到自己建立博客页面了</p>
<h2 id="第三步-了解hexo文件夹中-config-yml文件"><a href="#第三步-了解hexo文件夹中-config-yml文件" class="headerlink" title="第三步 了解hexo文件夹中_config.yml文件"></a>第三步 了解hexo文件夹中_config.yml文件</h2><p>hexo文件夹中比较重要的文件是：_config.yml，这是一个全局配置文件。</p>
<h3 id="step1：-1"><a href="#step1：-1" class="headerlink" title="step1："></a>step1：</h3><p>执行命令，安装deploy.git插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h3 id="step2："><a href="#step2：" class="headerlink" title="step2："></a>step2：</h3><p>打开这个文件，修改一下下面这部分(在配置文件的最后)，让自己的本地项目和远程仓库通过 git  建立连接部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">   <span class="built_in">type</span>: git</span><br><span class="line">   repository: https://github.com/yinjiangqaq/yinjiangqaq.github.io.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure>
<h3 id="step3："><a href="#step3：" class="headerlink" title="step3："></a>step3：</h3><p>配置提交github认证方式<br>执行指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>直接提交到远程你自己之前创建的github仓库，如果没有认证github和本地的关系，会提示你输入用户名和密码，输入完成之后，就会发现除了在.gitignore中出现的默认不推上去的文件之后，其他文件都推到了远程的github仓库</p>
<h2 id="第五步-添加域名"><a href="#第五步-添加域名" class="headerlink" title="第五步 添加域名"></a>第五步 添加域名</h2><p>阿里云中买一个.com的域名(域名价格纯看你的自己想起的名字，反正我的不知不觉就贵了，还享受不到优惠….)<br>这其中省略了你要注册阿里云账号，实名认证之类的步骤</p>
<h3 id="step1-cmd-ping-一下-github-io，获得真是ip地址"><a href="#step1-cmd-ping-一下-github-io，获得真是ip地址" class="headerlink" title="step1 cmd ping 一下 github.io，获得真是ip地址"></a>step1 cmd ping 一下 github.io，获得真是ip地址</h3><p><img src="/2019/12/27/%E9%87%87%E7%94%A8gitpages%E5%92%8Chexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ping.png" alt="ping.png"> </p>
<h3 id="step2：-1"><a href="#step2：-1" class="headerlink" title="step2："></a>step2：</h3><p>然后再域名操作栏点击解析，添加记录<br><img src="/2019/12/27/%E9%87%87%E7%94%A8gitpages%E5%92%8Chexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/jiexi.png" alt="jiexi.png"><br>记得需要添加两个记录，只添加www不知道为啥显示不出来</p>
<h3 id="step3"><a href="#step3" class="headerlink" title="step3:"></a>step3:</h3><p>去hexo文件夹的source目录下新建一个名为CNAME的文件，添加文件内容为你刚才购买的域名，不要添加www，内容添加如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yinjiangqaq.com</span><br></pre></td></tr></table></figure>
<h3 id="step4："><a href="#step4：" class="headerlink" title="step4："></a>step4：</h3><p>然后部署,power shell输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  //清除上次的缓存</span><br><span class="line">hexo generate //生成</span><br><span class="line">hexo deploy //部署</span><br></pre></td></tr></table></figure>
<p>(每次做出大一点的更改都建议部署一次)</p>
<h3 id="step5"><a href="#step5" class="headerlink" title="step5:"></a>step5:</h3><p>如果之前注册域名的时候，有进行过实名认证，那部署成功之后，打开浏览器输入你的域名，便可以看到你的个人博客了</p>
<h2 id="关于主题优化"><a href="#关于主题优化" class="headerlink" title="关于主题优化"></a>关于主题优化</h2><p>推荐一些已经很完善的博客，我也是借鉴其中的：<br><a href="https://io-oi.me/tech/hexo-next-optimization/#%E5%BF%85%E8%AF%BB-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2" target="_blank" rel="noopener">hexo深度优化</a><br><a href="https://blog.csdn.net/zgcr654321/article/details/86751765" target="_blank" rel="noopener">hexo主题个性化设置</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
