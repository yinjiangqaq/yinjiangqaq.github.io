<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTPS和HTTP的区别分析</title>
    <url>/2020/01/20/HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>纯面试需要而总结</p>
<h2 id="HTTPS和HTTP的区别主要如下"><a href="#HTTPS和HTTP的区别主要如下" class="headerlink" title="HTTPS和HTTP的区别主要如下"></a>HTTPS和HTTP的区别主要如下</h2><ul>
<li><code>https</code>协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。(但是现在在阿里云和腾讯云都可以免费从<code>HTTP</code>转<code>HTTPS</code>。会有免费的CA证书给你下载，时效为一年)</li>
<li>http是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，https则是具有安全性的<strong>SSL加密传输协议。</strong></li>
<li><code>http</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样，前者是<code>80</code>，后者是<code>443</code>。</li>
<li><code>http</code>的连接很简单，是<strong>无状态的</strong>；<code>HTTPS</code>协议是由<code>SSL+HTTP协议</code>构建的可进行<strong>加密传输、身份认证的网络协议</strong>，比<code>http</code>协议安全。<br>由此可以对比得到，<code>http</code>协议是明文传输，<strong>不确认通信方</strong>，<strong>不保证传输数据完整</strong>的协议。它带来了三大风险：</li>
<li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li>
<li>篡改风险（tampering）：第三方可以修改通信内容。</li>
<li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。<br>用一幅图更好的理解两种协议：<br><img src="/2020/01/20/HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/HTTPS.PNG" alt="HTTPS.png"><h2 id="关于HTTP和HTTPS的基本概念"><a href="#关于HTTP和HTTPS的基本概念" class="headerlink" title="关于HTTP和HTTPS的基本概念"></a>关于HTTP和HTTPS的基本概念</h2></li>
<li><em>HTTP :*</em>是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准<code>（TCP）</code>，用于从<code>WWW服务器</code>传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。  </li>
<li><em>HTTPS：*</em>是以安全为目标的HTTP通道，简单讲是<code>HTTP</code>的安全版，即<code>HTTP</code>下加入<code>SSL层</code>，<code>HTTPS的安全基础是SSL</code>，因此加密的详细内容就需要<code>SSL</code>。  </li>
</ul>
<p>HTTPS协议的主要作用可以分为两种：</p>
<ul>
<li>一种是建立一个信息安全通道，来保证数据传输的安全</li>
<li>另一种就是确认网站的真实性。</li>
</ul>
<h3 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h3><ul>
<li>支持客户/服务器模式。（C/S模式）</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有<code>GET、HEAD、POST。</code>每种方法规定了客户与服务器联系的类型不同。由于<code>HTTP</code>协议简单，使得<code>HTTP</code>服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：<code>HTTP</code>允许传输<strong>任意类型的数据对象</strong>。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是<strong>限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接</strong>。采用这种方式可以节省传输时间。</li>
<li>无状态：<strong>HTTP协议是无状态协议</strong>。无状态是指协议对于<strong>事务处理没有记忆能力</strong>。缺少状态意味着如果后续处理需要前面的信息，则它必须<code>重传</code>，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快<h3 id="HTTPS特点"><a href="#HTTPS特点" class="headerlink" title="HTTPS特点"></a>HTTPS特点</h3>相比于http，https可以提供更加优质保密的信息，保证了<strong>用户数据的安全性</strong>，此外https同时也一定程度上保护了服务端，使用恶意攻击和伪装数据的成本大大提高。<h2 id="HTTP协议和HTTPS协议的工作过程"><a href="#HTTP协议和HTTPS协议的工作过程" class="headerlink" title="HTTP协议和HTTPS协议的工作过程"></a>HTTP协议和HTTPS协议的工作过程</h2><h3 id="HTTP协议的工作流程"><a href="#HTTP协议的工作流程" class="headerlink" title="HTTP协议的工作流程"></a>HTTP协议的工作流程</h3>第一步：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接</li>
</ul>
<p>第二步：客户端向服务端发起HTTP请求（例如：POST/login.html http/1.1）</p>
<p>第三步：客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕</p>
<p>第四步：服务器做出应答，表示对于客户端请求的应答，例如：HTTP/1.1 200 OK</p>
<p>第五步：服务器向客户端发送应答头信息</p>
<p>第六步：服务器向客户端发送应答头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端</p>
<p>第七步：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接</p>
<h3 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h3><p><img src="/2020/01/20/HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/HTTPSwork.PNG" alt="HTTPSwork.png"><br>第一步：客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>第二步：Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>第三步：客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p>
<p>第四步：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>第五步：Web服务器利用自己的私钥解密出会话密钥。</p>
<p>第六步：Web服务器利用会话密钥加密与客户端之间的通信。</p>
<h3 id="SSL-TLS握手过程"><a href="#SSL-TLS握手过程" class="headerlink" title="SSL/TLS握手过程"></a>SSL/TLS握手过程</h3><p>现在我们具体关注在SSL连接是怎么样建立的<br><img src="/2020/01/20/HTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%88%86%E6%9E%90/SSL.PNG" alt="SSL.png"><br><strong>Client Hello</strong><br>握手第一步是客户端向服务端发送Client Hello消息。这个消息里包含了一个客户端生成的随机数Random1，客户端支持的加密套件（Support Ciphers）和SSL Version等信息。</p>
<p><strong>Server Hello</strong><br>第二步是服务端想客户端发送Server Hello消息。此时会生成一份随机数Random2，同时这个消息会从Client Hello传来的Support Ciphers里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法。</p>
<p>注意：至此客户端和服务端都拥有了两个随机数（Random1+Random2），这两个随机数会在后续生成对称秘钥时用到。</p>
<p><strong>Certificate</strong><br>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<p><strong>Server Hello Done</strong><br>Server Hello Done通知客户端Server Hello过程结束。</p>
<p><strong>Certificate Verify</strong><br>客户端收到服务端传来的证书后，先从CA验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成随机数Random3，再用服务端公钥非对称加密Random3生成PreMaster Key。</p>
<p>https的服务端必须拥有一个CA认证合法授权的证书，没有这个证书，客户端在访问该服务器时会提醒用户这个网站是不受信任的</p>
<p><strong>Client Key Exchange</strong><br>上一步中客户端根据服务器传来的公钥生成了PreMaster Key，Client Key Exchange就是将这个PreMaster Key传给服务端，服务端再用自己的私钥解出这个PreMaster Key得到客户端生成的Random3。</p>
<p>至此，客户端和服务端都拥有<code>Random1+Random2+Random3</code>，那么两边再根据同样的算法就可以生成一份<strong>秘钥</strong>，握手结束后的应用层数据都是使用这个秘钥进行<strong>对称加密</strong>。</p>
<p>为什么要使用三个随机数？</p>
<p><strong>这是因为SSL/TLS握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baijiahao.baidu.com/s?id=1629455363537331894&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1629455363537331894&amp;wfr=spider&amp;for=pc</a><br><a href="https://delaprada.com/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/#more" target="_blank" rel="noopener">https://delaprada.com/2020/01/16/https-SSL-TLS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/#more</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>关于canvas元素和CSS中的flex属性</title>
    <url>/2020/01/19/%E5%85%B3%E4%BA%8Ecanvas%E5%85%83%E7%B4%A0%E5%92%8CCSS%E4%B8%AD%E7%9A%84flex%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="canvas元素解析"><a href="#canvas元素解析" class="headerlink" title="canvas元素解析"></a>canvas元素解析</h2><h3 id="什么是canvas？"><a href="#什么是canvas？" class="headerlink" title="什么是canvas？"></a>什么是canvas？</h3><p>HTML5 的 <code>canvas</code> 元素使用 JavaScript 在网页上绘制图像。<br>画布是一个矩形区域，您可以控制其每一像素。<br><code>canvas</code> 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法</p>
<h3 id="创建canvas元素"><a href="#创建canvas元素" class="headerlink" title="创建canvas元素"></a>创建canvas元素</h3><p>规定元素的 id、宽度和高度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通过JavaScript来绘制"><a href="#通过JavaScript来绘制" class="headerlink" title="通过JavaScript来绘制"></a>通过JavaScript来绘制</h3><p><code>canvas</code> 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);&#x2F;&#x2F;找到画布</span><br><span class="line">var cxt&#x3D;c.getContext(&quot;2d&quot;);&#x2F;&#x2F;创建context对象，context对象是内建的HTML5对象</span><br><span class="line">cxt.fillStyle&#x3D;&quot;#FF0000&quot;;&#x2F;&#x2F;绘制context对象的颜色</span><br><span class="line">cxt.fillRect(0,0,150,75);&#x2F;&#x2F;绘制形状，左上角坐标为(0,0)，再画布上绘制150*75的矩形</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><code>除了矩形，还可以通过JavaScript绘制线条，圆形，加入图片等等</code><br>把一幅图像放置到画布上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var cxt&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line">var img&#x3D;new Image()</span><br><span class="line">img.src&#x3D;&quot;flower.png&quot;</span><br><span class="line">cxt.drawImage(img,0,0);</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="canvas需要注意的点"><a href="#canvas需要注意的点" class="headerlink" title="canvas需要注意的点"></a>canvas需要注意的点</h3><p><code>&lt;canvas width=&quot;250&quot; height=&quot;250&quot;&gt;&lt;/canvas&gt;</code>有个矩形长20px，高10px,CSS中width：250px  height：500px，请问这个矩形渲染出来的实际面积?<br>画布大小和CSS中设置width：250px  height：500px一致，其width和初始值比例为1:1，height和初始值比例为2:1。<strong>因此渲染出来的矩形的高度也将扩大一倍为20px，</strong>则矩形渲染出来的实际面积20X20=400。</p>
<h2 id="CSS中的flex属性"><a href="#CSS中的flex属性" class="headerlink" title="CSS中的flex属性"></a>CSS中的flex属性</h2><h3 id="flex属性的定义"><a href="#flex属性的定义" class="headerlink" title="flex属性的定义"></a>flex属性的定义</h3><p><code>flex</code> 属性用于设置或检索弹性盒模型对象的子元素如何分配空间。<br><code>flex</code> 属性是<code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code>属性的简写属性。<br>属性值：<br><img src="/2020/01/19/%E5%85%B3%E4%BA%8Ecanvas%E5%85%83%E7%B4%A0%E5%92%8CCSS%E4%B8%AD%E7%9A%84flex%E5%B1%9E%E6%80%A7/flex.PNG" alt="flex.PNG"><br>CSS语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flex: flex-grow flex-shrink flex-basis|auto|initial|inherit;</span><br></pre></td></tr></table></figure>
<h3 id="flex布局的作用"><a href="#flex布局的作用" class="headerlink" title="flex布局的作用"></a>flex布局的作用</h3><p>以前在写导航栏的时候，总是用<code>float</code>或者<code>display：inline-block</code>实现，但是这两种方法都会有各种问题，比如浮动会影响父元素以及兄弟元素的样式，需要<strong>清除浮动</strong>, 现在用flex会很方便，并且是<strong>弹性布局</strong><br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- HTML代码 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"> &lt;li&gt;音乐&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;li&gt;影视&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;li&gt;旅游&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- CSS代码 --&gt;</span><br><span class="line">ul&#123;</span><br><span class="line">  display: flex;         </span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下<br><img src="/2020/01/19/%E5%85%B3%E4%BA%8Ecanvas%E5%85%83%E7%B4%A0%E5%92%8CCSS%E4%B8%AD%E7%9A%84flex%E5%B1%9E%E6%80%A7/flex_layout1.PNG" alt="flex_layout1.PNG"><br>我们只要在HTML代码里面多加两个li元素，导航便弹性变化,不需要改动CSS代码<br><img src="/2020/01/19/%E5%85%B3%E4%BA%8Ecanvas%E5%85%83%E7%B4%A0%E5%92%8CCSS%E4%B8%AD%E7%9A%84flex%E5%B1%9E%E6%80%A7/flex_layout2.PNG" alt="flex_layout2.PNG"></p>
<h3 id="关于flex那三个属性的计算问题"><a href="#关于flex那三个属性的计算问题" class="headerlink" title="关于flex那三个属性的计算问题"></a>关于flex那三个属性的计算问题</h3><p>前面讲到<code>flex</code> 属性是<code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code>属性的简写属性。<br>拿一个栗子方便讲解：<br>下列布局在页面上的宽度比是多少？ <code>答案 2：3</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css</span><br><span class="line">.flex &#123;</span><br><span class="line">display: flex;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">flex: 3 0 50px;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">flex: 2 0 100px;</span><br><span class="line">background: blue;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; html</span><br><span class="line">&lt;div class&#x3D;&quot;flex&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>首先我们知道外层<code>flex</code>被设置为flex布局，然后left层的<code>flex:3 0 50px</code>；意思就是放大3倍，然后<code>flex-basis</code>定为50px，意思就是宽度为50px。<br>同理看right布局，<code>flex: 2 0 100px;</code>意思是放大两倍，<code>flex-basis</code>定为100px，宽度为100px。<br>现在我们外层flex总宽度为200px，减去left的50px，再减去right的100px，剩下50px。剩下的50px按照各自的放大倍数比例去分配空间，left分到50*3/5=30px,right分到20px。所以最后left布局应该是80px，right布局应该是120px。他们的宽度比2：3</p>
<p><code>除此之外，我们要注意的是，flex-basis为0%时，表示在分配多余的空间之前。该项目已经不占据空间了，他的 width已经失效了,这个元素的width为0 ，而最后的width还是要这个元素的width加上分配完全部剩下的按放大比例分配的width。 当flex-basis为auto时，则width取值为这个元素原先设置的width。最后的width算法同上。</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>推荐阅读：<br>          <a href="https://www.cnblogs.com/yiyistar/p/6539485.html" target="_blank" rel="noopener">https://www.cnblogs.com/yiyistar/p/6539485.html</a><br>          <a href="https://www.cnblogs.com/maqunjing/p/3155180.html" target="_blank" rel="noopener">https://www.cnblogs.com/maqunjing/p/3155180.html</a></p>
]]></content>
      <categories>
        <category>CSS</category>
        <category>JavaScript</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中prototype解析</title>
    <url>/2020/01/19/JavaScript%E4%B8%ADprototype%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博客我们讲到关于JavaScript中<code>this</code>的解析，里面涉及到关于JavaScript中<code>prototype</code>的内容，讲的内容比较限定于<code>this</code>，对此专门做一篇完整一点的，只关于<code>prototype</code>的博文<br>而与其相关的还有刷到一道前端笔试题跟其有关的<br><img src="/2020/01/19/JavaScript%E4%B8%ADprototype%E8%A7%A3%E6%9E%90/prototype.PNG" alt="prototype.PNG"></p>
<h2 id="关于prototype"><a href="#关于prototype" class="headerlink" title="关于prototype"></a>关于prototype</h2><p>所有的 JavaScript 对象都会从一个<code>prototype</code>（原型对象）中继承属性和方法：</p>
<ul>
<li>Date 对象从 Date.prototype 继承。</li>
<li>Array 对象从 Array.prototype 继承。</li>
<li>Person 对象从 Person.prototype 继承。  </li>
<li><em>所有 JavaScript 中的对象都是位于原型链顶端的 <code>Object</code> 的实例。*</em>换句话说，prototype原型链最终指向的是<code>object.prototype</code>,而  <code>object.prototype</code>对象的原型其实是一个没有任何属性和方法的<code>null对象</code><br>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。(有点像继承，跟上一篇博文我说的，有点类似JavaScript面向对象的继承)，因此<code>Date</code> 对象, <code>Array</code> 对象, 以及 <code>Person</code> 对象从 <code>Object.prototype</code> 继承。<br>而这道题目中<code>function.prototype</code>的最终指向，而JavaScript中函数其实也是个对象，所以函数对象的<code>prototype</code>最终指向的还是<code>Object</code><h2 id="prototype属性的作用"><a href="#prototype属性的作用" class="headerlink" title="prototype属性的作用"></a>prototype属性的作用</h2><h3 id="构造函数的介绍"><a href="#构造函数的介绍" class="headerlink" title="构造函数的介绍"></a>构造函数的介绍</h3>要讲prototype属性的作用之前还是得先讲一下构造函数。<br>所谓构造函数，就是提供了一个生成对象的模板并描述对象的基本结构的函数。一个构造函数，可以生成多个对象，每个对象都有相同的结构。总的来说，构造函数就是对象的模板，对象就是构造函数的实例。<br>构造函数的特点有：</li>
<li>构造函数的函数名首字母必须大写。</li>
<li>内部使用this对象，来指向将要生成的对象实例。</li>
<li>使用new操作符来调用构造函数，并返回对象实例。<br>看一个简单的例子：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line"> this.name &#x3D; &#39;keith&#39;;</span><br><span class="line">&#125;</span><br><span class="line"> var boy &#x3D; new Person();</span><br><span class="line"> &#x2F;&#x2F;new之后，此时的this指向boy</span><br><span class="line">console.log(boy.name); &#x2F;&#x2F;&#39;keith&#39;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3>所有的实例对象都可以继承构造函数中的属性和方法。但是，同一个对象实例之间，无法共享属性。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name,height)&#123;</span><br><span class="line"> this.name&#x3D;name;</span><br><span class="line"> this.height&#x3D;height;</span><br><span class="line"> this.hobby&#x3D;function()&#123;</span><br><span class="line"> return &#39;watching movies&#39;;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">var boy&#x3D;new Person(&#39;keith&#39;,180);</span><br><span class="line"> var girl&#x3D;new Person(&#39;rascal&#39;,153);</span><br><span class="line"> console.log(boy.name); &#x2F;&#x2F;&#39;keith&#39;</span><br><span class="line"> console.log(girl.name); &#x2F;&#x2F;&#39;rascal&#39;</span><br><span class="line"> console.log(boy.hobby&#x3D;&#x3D;&#x3D;girl.hobby); &#x2F;&#x2F;false 按照我们的理解，男孩和女孩的兴趣应该是一样的，但是结果为false</span><br></pre></td></tr></table></figure>
上面代码中，一个构造函数Person生成了两个对象实例<code>boy</code>和<code>girl</code>，并且有两个属性和一个方法。但是，它们的<code>hobby</code>方法是不一样的。也就是说，每当你使用<code>new</code>来调用构造函数放回一个对象实例的时候，都会new一个<code>hobby</code>方法(两个方法是不一样的)，这既没有必要，又浪费资源，因为所有hobby方法都是同样的行为，完全可以被<strong>两个对象实例共享。</strong>这时候就需要<code>prototype</code>来提供帮助。<h3 id="prototype属性的作用-1"><a href="#prototype属性的作用-1" class="headerlink" title="prototype属性的作用"></a>prototype属性的作用</h3>为了解决构造函数的对象实例之间无法共享属性的缺点，js提供了prototype属性。上面的例子改一下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name,height)&#123;</span><br><span class="line">this.name&#x3D;name;</span><br><span class="line">this.height&#x3D;height;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.hobby&#x3D;function()&#123;</span><br><span class="line">return &#39;watching movies&#39;;</span><br><span class="line">&#125;</span><br><span class="line">var boy&#x3D;new Person(&#39;keith&#39;,180);</span><br><span class="line">var girl&#x3D;new Person(&#39;rascal&#39;,153);</span><br><span class="line">console.log(boy.name); &#x2F;&#x2F;&#39;keith&#39;</span><br><span class="line">console.log(girl.name); &#x2F;&#x2F;&#39;rascal&#39;</span><br><span class="line">console.log(boy.hobby&#x3D;&#x3D;&#x3D;girl.hobby); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
这里把<code>hobby</code>方法放在<code>Person</code>的原型对象的属性里面了，这样你无论<code>new</code>多少个<code>person</code>实例，他们的<code>hobby</code>方法都是继承Person原型的那个<code>hobby</code>方法，都是一样的。<br>但是要记住<strong>原型对象的属性不是对象实例的属性。</strong>对象实例的属性是继承自构造函数定义的属性，因为构造函数内部有一个<code>this</code>关键字来指向将要生成的对象实例。<br>因此当修改了原型对象的hobby方法之后，两个对象实例都发生了变化。这是因为对象实例其实是没有hobby方法，都是读取person原型对象的hobby方法。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boy.hobby&#x3D;function()&#123;</span><br><span class="line"> return &#39;play basketball&#39;;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(boy.hobby()); &#x2F;&#x2F;&#39;play basketball&#39;</span><br><span class="line"> console.log(girl.hobby()); &#x2F;&#x2F;&#39;watching movies&#39;</span><br></pre></td></tr></table></figure>
上面代码中，<strong><code>boy</code>对象实例的hobby方法修改时，就不会在继承原型对象上的hobby方法了</strong>。不过girl仍然会继承原型对象的方法。也就是说当你重写跟原型对象一样(或者便于理解，说成父类)的相同属性或者方法时，就一定按子类重写的那个属性或方法为主，如果没有重写，就继承父类的。<h2 id="原型链-prototype-chains"><a href="#原型链-prototype-chains" class="headerlink" title="原型链(prototype chains)"></a>原型链(prototype chains)</h2>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型对象本身对于对象实例来说也是对象，它也有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。所有一切的对象的原型顶端，都是<code>Object.prototype</code>，即Object构造函数的<code>prototype</code>属性指向的那个对象。<br>当然，<code>Object.prototype对象</code>也有自己的原型对象，那就是没有任何属性和方法的<code>null对象</code>，而<code>null对象</code>没有自己的原型。<br>原型链的特点有：</li>
<li>读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。</li>
<li>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”<code>（overiding）</code>。</li>
<li>一级级向上在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链</li>
</ul>
<h2 id="顺便补充讲一下proto"><a href="#顺便补充讲一下proto" class="headerlink" title="顺便补充讲一下proto"></a>顺便补充讲一下<em>proto</em></h2><p><code>_proto_</code>属性，<strong>用来读取或设置当前对象的<code>prototype对象</code>。</strong>目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; es5 的写法</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  method: function() &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ &#x3D; someOtherObj;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; es6 的写法</span><br><span class="line">var obj &#x3D; Object.create(someOtherObj);</span><br><span class="line">obj.method &#x3D; function() &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>然鹅ES6并没有把它写进去，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替这个<code>_proto_</code>属性。</p>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p>也就是<code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype对象</code>，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 格式</span><br><span class="line">Object.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用法</span><br><span class="line">const o &#x3D; Object.setPrototypeOf(&#123;&#125;, null);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;等价于用_proto_属性</span><br><span class="line">function (obj, proto) &#123;</span><br><span class="line">  obj.__proto__ &#x3D; proto;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一个例子更好的理解<code>Object.setPrototypeOf</code>的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let proto &#x3D; &#123;&#125;;</span><br><span class="line">let obj &#x3D; &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">&#x2F;&#x2F;设置obj的原型时proto</span><br><span class="line">proto.y &#x3D; 20;</span><br><span class="line">proto.z &#x3D; 40;</span><br><span class="line">&#x2F;&#x2F;给proto新增属性，同时obj也会继承</span><br><span class="line">obj.x &#x2F;&#x2F; 10</span><br><span class="line">obj.y &#x2F;&#x2F; 20</span><br><span class="line">obj.z &#x2F;&#x2F; 40</span><br></pre></td></tr></table></figure>
<p>如果第一个参数不是对象，会自动转为对象。但是<strong>由于返回的还是第一个参数，</strong>所以这个操作不会产生任何效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.setPrototypeOf(1, &#123;&#125;) &#x3D;&#x3D;&#x3D; 1 &#x2F;&#x2F; true</span><br><span class="line">Object.setPrototypeOf(&#39;foo&#39;, &#123;&#125;) &#x3D;&#x3D;&#x3D; &#39;foo&#39; &#x2F;&#x2F; true</span><br><span class="line">Object.setPrototypeOf(true, &#123;&#125;) &#x3D;&#x3D;&#x3D; true &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.setPrototypeOf(undefined, &#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; TypeError: Object.setPrototypeOf called on null or undefined</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(null, &#123;&#125;)</span><br><span class="line">&#x2F;&#x2F; TypeError: Object.setPrototypeOf called on null or undefined</span><br></pre></td></tr></table></figure>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Rectangle() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rec &#x3D; new Rectangle();</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(rec) &#x3D;&#x3D;&#x3D; Rectangle.prototype</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(rec, Object.prototype);</span><br><span class="line">Object.getPrototypeOf(rec) &#x3D;&#x3D;&#x3D; Rectangle.prototype</span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>如果参数不是对象，会被自动转为对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 等同于 Object.getPrototypeOf(Number(1))</span><br><span class="line">Object.getPrototypeOf(1)</span><br><span class="line">&#x2F;&#x2F; Number &#123;[[PrimitiveValue]]: 0&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于 Object.getPrototypeOf(String(&#39;foo&#39;))</span><br><span class="line">Object.getPrototypeOf(&#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于 Object.getPrototypeOf(Boolean(true))</span><br><span class="line">Object.getPrototypeOf(true)</span><br><span class="line">&#x2F;&#x2F; Boolean &#123;[[PrimitiveValue]]: false&#125;</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(1) &#x3D;&#x3D;&#x3D; Number.prototype &#x2F;&#x2F; true</span><br><span class="line">Object.getPrototypeOf(&#39;foo&#39;) &#x3D;&#x3D;&#x3D; String.prototype &#x2F;&#x2F; true</span><br><span class="line">Object.getPrototypeOf(true) &#x3D;&#x3D;&#x3D; Boolean.prototype &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.getPrototypeOf(null)</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot convert undefined or null to object</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(undefined)</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot convert undefined or null to object</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考阅读：<a href="https://www.cnblogs.com/douyage/p/8630529.html" target="_blank" rel="noopener">https://www.cnblogs.com/douyage/p/8630529.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript this解析</title>
    <url>/2020/01/17/JavaScriptthis%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想码这篇博文的动力是源于刷了网易2020年正式批的前端笔试题，里面有一道涉及到关于JavaScript this的问题。</p>
<p><img src="/2020/01/17/JavaScriptthis%E8%A7%A3%E6%9E%90/this.png" alt="this.png"> </p>
<p>由于这道题是我瞎蒙的，所以真正的解题思路是什么样的，我想真真正正了解一下。顺便全面地了解JavaScript的this</p>
<h2 id="不同环境中的this含义不一样"><a href="#不同环境中的this含义不一样" class="headerlink" title="不同环境中的this含义不一样"></a>不同环境中的this含义不一样</h2><h3 id="全局中的this"><a href="#全局中的this" class="headerlink" title="全局中的this"></a>全局中的this</h3><h4 id="浏览器环境下"><a href="#浏览器环境下" class="headerlink" title="浏览器环境下"></a>浏览器环境下</h4><p>在浏览器里，在全局范围内，<code>this</code>等价于<code>window</code>对象。用<code>var</code>声明一个变量和给<code>this</code>或者window添加属性是等价的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   console.log(this &#x3D;&#x3D;&#x3D; window) &#x2F;&#x2F;true</span><br><span class="line">   </span><br><span class="line">   var a &#x3D; 3;</span><br><span class="line">   console.log(this.a, window.a)&#x2F;&#x2F;3  3</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p><code>说明：在浏览器中window对象同时也是全局对象</code></p>
<h4 id="node环境中"><a href="#node环境中" class="headerlink" title="node环境中"></a>node环境中</h4><p>在<code>node</code>环境里，在全局范围内，如果你用<code>REPL</code>(通过执行一个js文件来运行你的代码)执行一个脚本文件，用<code>var</code>声明一个变量并不会和在浏览器里面一样将这个变量添加给<code>this</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.js 文件在node环境中执行</span><br><span class="line"></span><br><span class="line">var foo &#x3D; &quot;bar&quot;;</span><br><span class="line">console.log(this.foo);&#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>
<p>但是如果你不是用<code>REPL</code>执行脚本文件，而是直接执行代码，结果和在浏览器里面是一样的(神坑)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var foo &#x3D; &quot;bar&quot;;</span><br><span class="line">&gt; this.foo</span><br><span class="line">bar</span><br><span class="line">&gt; global.foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>在<code>node</code>环境里，用REPL运行脚本文件的时候，如果在声明变量的时候没有使用<code>var</code>或者<code>let</code>，这个变量会自动添加到<code>global</code>对象，但是不会自动添加给<code>this</code>对象。如果是直接执行代码，则会同时添加给<code>global</code>和<code>this</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.js 文件在node环境中执行</span><br><span class="line"></span><br><span class="line"> foo &#x3D; &quot;bar&quot;;</span><br><span class="line"> console.log(this.foo);&#x2F;&#x2F;undefined</span><br><span class="line"> console.log(global.foo);&#x2F;&#x2F;bar</span><br></pre></td></tr></table></figure>
<h3 id="函数-function-中的this"><a href="#函数-function-中的this" class="headerlink" title="函数(function)中的this"></a>函数(function)中的this</h3><p>如果不是用new调用，在函数里面使用this都是指代全局范围的this。无论是浏览器环境还是node环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">testa()</span><br><span class="line">function testa()&#123;</span><br><span class="line">     testb()</span><br><span class="line">    function testb()&#123;</span><br><span class="line">        console.log(this &#x3D;&#x3D;&#x3D; window)&#x2F;&#x2F;true</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;在node环境下</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">index.js 文件在node环境中执行</span><br><span class="line"></span><br><span class="line">foo &#x3D; &quot;bar&quot;;</span><br><span class="line"></span><br><span class="line">function testThis () &#123;</span><br><span class="line">  this.foo &#x3D; &quot;foo&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(global.foo);&#x2F;&#x2F;bar</span><br><span class="line">testThis();</span><br><span class="line">console.log(global.foo);&#x2F;&#x2F;foo</span><br></pre></td></tr></table></figure>
<p>如果你在调用函数的时候在前面使用了new，this就会变成一个新的值，和global的this脱离干系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">      foo &#x3D; &quot;bar&quot;;</span><br><span class="line">  </span><br><span class="line">      function testThis() &#123;</span><br><span class="line">        this.foo &#x3D; &quot;foo&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      console.log(this.foo); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line">      new testThis();</span><br><span class="line">     console.log(this.foo); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line"> </span><br><span class="line">     console.log(new testThis().foo); &#x2F;&#x2F;logs &quot;foo&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>如果想把<code>this</code>的值从一个环境传到另一个环境，就要用到<code>call</code>或者<code>apply</code>的方法。也就是说<code>call</code>和<code>apply</code>都能改变函数调用者即(<code>this</code>)的走向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 将一个对象作为call和apply的第一个参数，this会被绑定到这个对象。</span><br><span class="line">var obj &#x3D; &#123;a: &#39;Custom&#39;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个属性是在global对象定义的。</span><br><span class="line">var a &#x3D; &#39;Global&#39;;</span><br><span class="line"></span><br><span class="line">function whatsThis(arg) &#123;</span><br><span class="line">  return this.a;  &#x2F;&#x2F; this的值取决于函数的调用方式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">whatsThis();          &#x2F;&#x2F; &#39;Global&#39;</span><br><span class="line">whatsThis.call(obj);  &#x2F;&#x2F; &#39;Custom&#39;</span><br><span class="line">whatsThis.apply(obj); &#x2F;&#x2F; &#39;Custom&#39;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="然鹅js的call和apply有什么不同呢？"><a href="#然鹅js的call和apply有什么不同呢？" class="headerlink" title="然鹅js的call和apply有什么不同呢？"></a>然鹅js的call和apply有什么不同呢？</h4><p>首先看一下这两个函数的原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.call(newObj, arg1, arg2, ...);</span><br><span class="line">obj.apply(newObj, [arg1, arg2, ...]);</span><br></pre></td></tr></table></figure>
<p>上面的都是把<code>obj</code>的<code>this</code>指向了<code>newObj</code>，这时<code>newObj</code>就继承了obj的属性和方法。<strong>两者区别是接收的参数不同</strong>，第一个参数都是函数运行的作用域<code>（this）</code> ,也就是让<code>this</code>指向这个参数 ,但是如果传递给 <code>this</code> 的值不是一个对象，JavaScript 会尝试使用内部 <code>ToObject</code>操作将其转换为对象。因此，如果传递的值是一个原始值比如 <code>7</code>或 <code>‘foo’</code>，那么就会使用相关构造函数将它转换为对象，所以原始值 <code>7</code>会被转换为对象，像 new Number(7) 这样，而字符串 <code>‘foo’</code>转化成 new String(‘foo’)<br><code>apply</code>第二个参数接受的是数组参数，如果没有提供<code>argArray</code>和<code>newObj</code>任何一个参数，那么<code>Global对象</code>将用作<code>newObj</code>。<br><code>call</code>接受的是连续参数，如果没有提供<code>newObj</code>参数，那么<code>Global对象</code>被用于<code>newObj</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(c,d)&#123;</span><br><span class="line">    return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s &#x3D; &#123;a:1, b:2&#125;;</span><br><span class="line">console.log(add.call(s,3,4)); &#x2F;&#x2F; 1+2+3+4 &#x3D; 10</span><br><span class="line">console.log(add.apply(s,[5,6])); &#x2F;&#x2F; 1+2+5+6 &#x3D; 14</span><br></pre></td></tr></table></figure>
<h4 id="除了call和apply之外的bind"><a href="#除了call和apply之外的bind" class="headerlink" title="除了call和apply之外的bind"></a>除了call和apply之外的bind</h4><p>ECMAScript 5 引入了 <code>Function.prototype.bind</code>。调用<code>f.bind(someObject)</code>会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，<code>this</code>将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。也就是说bind只生效一次，生效之后，永远将<code>this</code>绑定在第一个参数对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">function f()&#123;</span><br><span class="line">  return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g &#x3D; f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g()); &#x2F;&#x2F; azerty</span><br><span class="line"></span><br><span class="line">var h &#x3D; g.bind(&#123;a:&#39;yoo&#39;&#125;); &#x2F;&#x2F; bind只生效一次！</span><br><span class="line">console.log(h()); &#x2F;&#x2F; azerty</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123;a:37, f:f, g:g, h:h&#125;;</span><br><span class="line">console.log(o.f(), o.g(), o.h()); &#x2F;&#x2F; 37, azerty, azerty</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="prototype中的this"><a href="#prototype中的this" class="headerlink" title="prototype中的this"></a>prototype中的this</h3><p><strong>你创建的每一个函数都是函数对象</strong>，他们会自动获取<strong>一个特殊的属性<code>prototype</code>，</strong>你可以给这个属性赋值。当你用<code>new</code>的方式调用一个函数的时候，你就能通过<code>this</code>访问你给<code>prototype</code>赋的值了。而<code>prototype</code>属性的值可以是一个值也可以是一个函数。<br>当你使用<code>new</code>为你的函数创建多个实例的时候，这些实例会共享你给<code>prototype</code>设定的值。对于下面的例子，当你调用<code>this.foo</code>的时候，都会返回相同的值，除非你在某个实例里面重写了自己的<code>this.foo</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"> function Thing() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Thing.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">  Thing.prototype.logFoo &#x3D; function () &#123;</span><br><span class="line">      console.log(this.foo);</span><br><span class="line">  &#125;</span><br><span class="line">  Thing.prototype.setFoo &#x3D; function (newFoo) &#123;</span><br><span class="line">      this.foo &#x3D; newFoo;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> var thing1 &#x3D; new Thing();</span><br><span class="line"> var thing2 &#x3D; new Thing();</span><br><span class="line"> </span><br><span class="line"> thing1.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line"> thing2.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line"> </span><br><span class="line"> thing1.setFoo(&quot;foo&quot;);</span><br><span class="line"> thing1.logFoo(); &#x2F;&#x2F;logs &quot;foo&quot;;</span><br><span class="line"> thing2.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;;</span><br><span class="line"> </span><br><span class="line"> thing2.foo &#x3D; &quot;foobar&quot;;</span><br><span class="line"> thing1.logFoo(); &#x2F;&#x2F;logs &quot;foo&quot;;</span><br><span class="line"> thing2.logFoo(); &#x2F;&#x2F;logs &quot;foobar&quot;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>但是记住当你给函数实例对象的属性<code>foo</code>赋值时候，实惠改变<code>this</code>的指向，但是函数对象<code>prototype.foo</code>还是原来那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">function Thing() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Thing.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">  Thing.prototype.logFoo &#x3D; function () &#123;</span><br><span class="line">      console.log(this.foo, Thing.prototype.foo);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  var thing &#x3D; new Thing();</span><br><span class="line">  thing.foo &#x3D; &quot;foo&quot;;</span><br><span class="line">  thing.logFoo(); &#x2F;&#x2F;logs &quot;foo bar&quot;;</span><br><span class="line">  delete thing.foo; &#x2F;&#x2F;函数对象的属性可以删除</span><br><span class="line"> thing.logFoo(); &#x2F;&#x2F;logs &quot;bar bar&quot;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="而如果将bind-call-apply和prototype联系起来会怎么样"><a href="#而如果将bind-call-apply和prototype联系起来会怎么样" class="headerlink" title="而如果将bind, call, apply和prototype联系起来会怎么样"></a>而如果将bind, call, apply和prototype联系起来会怎么样</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  function Thing() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Thing.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">   </span><br><span class="line">  function logFoo(aStr) &#123;</span><br><span class="line">      console.log(aStr, this.foo);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;这里 logFoo是一个新的函数对象，并不是Thing的prototype里面的属性 </span><br><span class="line"> var thing &#x3D; new Thing();</span><br><span class="line"> logFoo.bind(thing)(&quot;using bind&quot;); &#x2F;&#x2F;logs &quot;using bind bar&quot;</span><br><span class="line"> logFoo.apply(thing, [&quot;using apply&quot;]); &#x2F;&#x2F;logs &quot;using apply bar&quot;</span><br><span class="line"> logFoo.call(thing, &quot;using call&quot;); &#x2F;&#x2F;logs &quot;using call bar&quot;</span><br><span class="line"> logFoo(&quot;using nothing&quot;); &#x2F;&#x2F;logs &quot;using nothing undefined&quot;  undefined是因为此时logFoo里面的this指向的是window，而全局的foo并没有定义</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>这种prototype的方式，被称为原型链，有点像JavaScript中面向对象中的继承方式。函数对象的prototype属性就像是函数对象继承来的一样。而prototype属性也刚好有值，有函数。<br>但是有种情况需要特别注意一下，虽然说是很想继承关系，但是任何给用于构建原型链的函数的<code>this</code>的赋值的语句都会隐藏原型链上游的相同的属性。也就是说，如果子类已经声明相同属性foo的值了，要以子类的值为主，隐藏父类的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  function Thing1() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Thing1.prototype.foo &#x3D; &quot;bar&quot;;</span><br><span class="line">  </span><br><span class="line">  function Thing2() &#123;</span><br><span class="line">      this.foo &#x3D; &quot;foo&quot;;&#x2F;&#x2F;像这种已经声明了的，以这个为老大</span><br><span class="line">  &#125;</span><br><span class="line">  Thing2.prototype &#x3D; new Thing1();</span><br><span class="line">  </span><br><span class="line"> function Thing3() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> Thing3.prototype &#x3D; new Thing2();</span><br><span class="line"> </span><br><span class="line"> var thing &#x3D; new Thing3();</span><br><span class="line"> console.log(thing.foo); &#x2F;&#x2F;logs &quot;foo&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="对象-object-中的this"><a href="#对象-object-中的this" class="headerlink" title="对象(object)中的this"></a>对象(object)中的this</h3><p>在一个对象的一个函数里，你可以通过<code>this</code>来引用这个对象的其他属性。这个用<code>new</code>来新建一个实例是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"> var obj &#x3D; &#123;</span><br><span class="line">     foo: &quot;bar&quot;,</span><br><span class="line">     logFoo: function () &#123;</span><br><span class="line">         console.log(this.foo);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;; </span><br><span class="line"> obj.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>没有使用new，没有使用<code>Object.create</code>，也没有使用函数调用创建一个对象。你也可以将对象当作一个实例将函数绑定到上面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"> var obj &#x3D; &#123;</span><br><span class="line">     foo: &quot;bar&quot;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> function logFoo() &#123;</span><br><span class="line">     console.log(this.foo);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> logFoo.apply(obj); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>当你用这种方式使用<code>this</code>的时候，并不会越出当前的对象。只有有相同直接父元素的属性才能通过<code>this</code>共享变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  var obj &#x3D; &#123;</span><br><span class="line">      foo: &quot;bar&quot;,</span><br><span class="line">      deeper: &#123;</span><br><span class="line">          logFoo: function () &#123;</span><br><span class="line">              console.log(this.foo);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"> obj.deeper.logFoo(); &#x2F;&#x2F;logs undefined</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>但是你可以直接通过对象引用你需要的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	var obj &#x3D; &#123;</span><br><span class="line">	    foo: &quot;bar&quot;,</span><br><span class="line">	    deeper: &#123;</span><br><span class="line">	        logFoo: function () &#123;</span><br><span class="line">	            console.log(obj.foo);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	obj.deeper.logFoo(); &#x2F;&#x2F;logs &quot;bar&quot;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="最后是箭头函数下的this"><a href="#最后是箭头函数下的this" class="headerlink" title="最后是箭头函数下的this"></a>最后是箭头函数下的this</h3><p>箭头函数不会创建自己的this，它<strong>只会从自己的作用域链的上一层继承this。</strong>上一层找不到再去window找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">	return (a)&#x3D;&gt;&#123;</span><br><span class="line">		console.log(this.a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj1&#x3D;&#123;</span><br><span class="line">	a:2</span><br><span class="line">&#125;;</span><br><span class="line">var obj2&#x3D;&#123;</span><br><span class="line">	a:3</span><br><span class="line">&#125;;</span><br><span class="line">var bar&#x3D;foo.call(obj1);</span><br><span class="line">bar.call(obj2);  &#x2F;&#x2F;2,不是3！</span><br></pre></td></tr></table></figure>
<p><code>foo()</code>内部创建的箭头函数会捕获调用时<code>foo()</code>的<code>this</code>。由于<code>foo()</code>的<code>this</code>绑定到<code>obj1</code>，所以<code>bar</code>（引用箭头函数）的<code>this</code>也会绑定到<code>obj1</code>，箭头函数的绑定无法被修改。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基本知识</title>
    <url>/2020/01/17/JavaScript%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JavaScript是一种运行在浏览器中的解释型的编程语言。在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。</p>
<h3 id="JavaScript和ES6的区别"><a href="#JavaScript和ES6的区别" class="headerlink" title="JavaScript和ES6的区别"></a>JavaScript和ES6的区别</h3><p>ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。ES6适应更复杂的应用；实现代码库之间的共享。目前只有chrome和firefox两个浏览器对ES6比较友好。</p>
<h2 id="JavaScript快速入门"><a href="#JavaScript快速入门" class="headerlink" title="JavaScript快速入门"></a>JavaScript快速入门</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>1.JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中<br>2.第二种方法是把JavaScript代码放到一个单独的.js文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件,在这个.js文件中编写代码，更容易维护。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>{...}</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。但是我们自己编写代码的时候还有养成加<code>;</code>的习惯，避免因为引擎自动加引号，导致语义出错，而运行结果不一致的</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123; &#x2F;&#x2F; 整数123</span><br><span class="line">0.456; &#x2F;&#x2F; 浮点数0.456</span><br><span class="line">1.2345e3; &#x2F;&#x2F; 科学计数法表示1.2345x1000，等同于1234.5</span><br><span class="line">-99; &#x2F;&#x2F; 负数</span><br><span class="line">NaN; &#x2F;&#x2F; NaN表示Not a Number，当无法计算结果时用NaN表示</span><br><span class="line">Infinity; &#x2F;&#x2F; Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></pre></td></tr></table></figure>
<p>Number可以直接做四则运算，规则和数学一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + 2; &#x2F;&#x2F; 3</span><br><span class="line">(1 + 2) * 5 &#x2F; 2; &#x2F;&#x2F; 7.5</span><br><span class="line">2 &#x2F; 0; &#x2F;&#x2F; Infinity</span><br><span class="line">0 &#x2F; 0; &#x2F;&#x2F; NaN</span><br><span class="line">10 % 3; &#x2F;&#x2F; 1  % 表示求余运算</span><br><span class="line">10.5 % 3; &#x2F;&#x2F; 1.5</span><br></pre></td></tr></table></figure>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>字符串是用单引号或双引号括起来的任意文本,如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符,如果字符串内部既包含<code>&#39;</code>,又包含<code>&quot;</code>怎么办，可以用转义字符<code>\</code>标识，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;I\&#39;m \&quot;OK\&quot;!&#39;;</span><br></pre></td></tr></table></figure>
<p>表示的字符串内容是: <code>I&#39;m &quot;OK&quot;!</code></p>
<h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>获取字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Hello world!&#39;;</span><br><span class="line">s.length; &#x2F;&#x2F;12</span><br></pre></td></tr></table></figure>
<p>获取字符串指定位置的字符，使用类似Array的下标操作，索引号从0开始：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Hello world!&#39;;</span><br><span class="line">s[0]; &#x2F;&#x2F;&#39;H&#39;</span><br><span class="line">s[6]; &#x2F;&#x2F;&#39; &#39;</span><br><span class="line">s[12]; &#x2F;&#x2F;undefined,超出范围不会报错，一律返回undefined</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有错误，但是也没有任何效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Test&#39;;</span><br><span class="line">s[0] &#x3D; &#39;X&#39;;</span><br><span class="line">alert(s); &#x2F;&#x2F; s仍然为&#39;Test&#39;</span><br></pre></td></tr></table></figure>
<p><code>toUpperCase()</code>把一个字符串全部变大写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Hello&#39;;</span><br><span class="line">s.toUpperCase(); &#x2F;&#x2F; 返回&#39;HELLO&#39;</span><br></pre></td></tr></table></figure>
<p><code>toLowerCase()</code>把一个字符串全部变小写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;Hello&#39;;</span><br><span class="line">var lower &#x3D; s.toLowerCase(); &#x2F;&#x2F; 返回&#39;hello&#39;并赋值给变量lower</span><br><span class="line">lower; &#x2F;&#x2F; &#39;hello&#39;</span><br></pre></td></tr></table></figure>
<p><code>indexOf()</code>会搜索指定字符串中出现的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello, world&#39;;</span><br><span class="line">s.indexOf(&#39;world&#39;); &#x2F;&#x2F; 返回7</span><br><span class="line">s.indexOf(&#39;World&#39;); &#x2F;&#x2F; 没有找到指定的子串，返回-1</span><br></pre></td></tr></table></figure>
<p><code>substring()</code>返回指定索引区间的子串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; &#39;hello, world&#39;</span><br><span class="line">s.substring(0, 5); &#x2F;&#x2F; 从索引0开始到5（不包括5），返回&#39;hello&#39;</span><br><span class="line">s.substring(7); &#x2F;&#x2F; 从索引7开始到结束，返回&#39;world&#39;</span><br></pre></td></tr></table></figure>
<p>ES6新增了子串的识别方法：</p>
<ul>
<li>includes()：返回布尔值，判断是否找到参数字符串。</li>
<li>startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。  </li>
</ul>
<p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let string &#x3D; &quot;apple,banana,orange&quot;;</span><br><span class="line">string.includes(&quot;banana&quot;);     &#x2F;&#x2F; true</span><br><span class="line">string.startsWith(&quot;apple&quot;);    &#x2F;&#x2F; true</span><br><span class="line">string.endsWith(&quot;apple&quot;);      &#x2F;&#x2F; false</span><br><span class="line">string.startsWith(&quot;banana&quot;,6)  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>除此之外还有字符串补全的方法：</p>
<ul>
<li>padStart：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</li>
<li>padEnd：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;h&quot;.padStart(5,&quot;o&quot;));  &#x2F;&#x2F; &quot;ooooh&quot;</span><br><span class="line">console.log(&quot;h&quot;.padEnd(5,&quot;o&quot;));    &#x2F;&#x2F; &quot;hoooo&quot;</span><br><span class="line">console.log(&quot;h&quot;.padStart(5));      &#x2F;&#x2F; &quot;    h&quot;</span><br></pre></td></tr></table></figure>
如果指定的长度小于或等于原字符串的长度，则返回原字符串:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;hello&quot;.padStart(5,&quot;A&quot;));  &#x2F;&#x2F; &quot;hello&quot;</span><br></pre></td></tr></table></figure>
如果原字符串加上补全的字符串长度大于指定长度，则截去超出位数的字符串：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;hello&quot;.padEnd(10,&quot;,world!&quot;));  &#x2F;&#x2F; &quot;hello,worl&quot;</span><br></pre></td></tr></table></figure>
常用于补全位数:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&quot;123&quot;.padStart(10,&quot;0&quot;));  &#x2F;&#x2F; &quot;0000000123&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>模板字符串相当于加强版的字符串，用反引号`,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。  </p>
<p>普通字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let string &#x3D; &#96;Hello&#39;\n&#39;world&#96;;</span><br><span class="line">console.log(string); </span><br><span class="line">&#x2F;&#x2F; &quot;Hello&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;world&quot;</span><br></pre></td></tr></table></figure>
<p>ES6支持多行字符串,省去了加<code>\n</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let string1 &#x3D;  &#96;Hey,</span><br><span class="line">can you stop angry now?&#96;;</span><br><span class="line">console.log(string1);</span><br><span class="line">&#x2F;&#x2F; Hey,</span><br><span class="line">&#x2F;&#x2F; can you stop angry now?</span><br></pre></td></tr></table></figure>
<p>之前要把多个字符串连接起来，需要用<code>+</code>号连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;小明&#39;;</span><br><span class="line">var age &#x3D; 20;</span><br><span class="line">var message &#x3D; &#39;你好, &#39; + name + &#39;, 你今年&#39; + age + &#39;岁了!&#39;;</span><br><span class="line">alert(message);   &#x2F;&#x2F; 你好小明，你今年20岁了</span><br></pre></td></tr></table></figure>
<p>但是ES6的模板字符串，<strong>支持在字符串中加入变量和表达式</strong><br>变量名写在<code>${}</code>中，<code>${}</code>还可以放入JavaScript 表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let name &#x3D; &quot;Mike&quot;;</span><br><span class="line">let age &#x3D; 27;</span><br><span class="line">let info &#x3D; &#96;My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.&#96;</span><br><span class="line">console.log(info);</span><br><span class="line">&#x2F;&#x2F; My Name is Mike,I am 28 years old next year.</span><br></pre></td></tr></table></figure>
<p>字符串中调用函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  return &quot;have fun!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">let string2&#x3D; &#96;Game start,$&#123;f()&#125;&#96;;</span><br><span class="line">console.log(string2);  &#x2F;&#x2F; Game start,have fun!</span><br></pre></td></tr></table></figure>
<p><strong><code>注意要点:模板字符串中的换行和空格都是会被保留的</code></strong></p>
<h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>true</code>、<code>false</code>两种值，要么是<code>true</code>，要么是<code>false</code>，可以直接用<code>true</code>、<code>false</code>表示布尔值，也可以通过布尔运算计算出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true; &#x2F;&#x2F; 这是一个true值</span><br><span class="line">false; &#x2F;&#x2F; 这是一个false值</span><br><span class="line">2 &gt; 1; &#x2F;&#x2F; 这是一个true值</span><br><span class="line">2 &gt;&#x3D; 3; &#x2F;&#x2F; 这是一个false值</span><br></pre></td></tr></table></figure>
<p>在JavaScript在设计时，有两种比较运算符：  </p>
<ul>
<li>第一种是<code>==</code>比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；  </li>
<li>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。<br>由于JavaScript这个设计缺陷，不要使用<code>==</code>比较，始终坚持使用<code>===</code>比较。<br>另一个例外是<code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isNaN(NaN); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
而需要注意的是浮点数的比较：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &#x2F; 3 &#x3D;&#x3D;&#x3D; (1 - 2 &#x2F; 3); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.abs(1 &#x2F; 3 - (1 - 2 &#x2F; 3)) &lt; 0.0000001; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h4 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h4>null 表示一个”空”的值，它和 <code>0</code>和空字符串<code>&#39;&#39;</code>,<code>0</code>表示一个数值，<code>&#39;&#39;</code>表示长度为0的字符串，而null表示为”空”。<br>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。然鹅区分的意义不是很大，大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3.14, &#39;Hello&#39;, null, true];</span><br></pre></td></tr></table></figure>
另一种创建数组的方法是通过<code>Array()</code>函数实现的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Array(1, 2, 3); &#x2F;&#x2F; 创建了数组[1, 2, 3]</span><br></pre></td></tr></table></figure>
然鹅，出于对代码的可读性考虑，建议直接使用<code>[]</code><br>数组的值可以用索引来访问，索引的起始值是0：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3.14, &#39;Hello&#39;, null, true];</span><br><span class="line">arr[0]; &#x2F;&#x2F; 返回索引为0的元素，即1</span><br><span class="line">arr[5]; &#x2F;&#x2F; 返回索引为5的元素，即true</span><br><span class="line">arr[6]; &#x2F;&#x2F; 索引超出了范围，返回undefined</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>indexOf</strong><br>与String类似，<code>Array</code>也可以通过<code>indexOf()</code>来搜索一个指定的元素的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [10, 20, &#39;30&#39;, &#39;xyz&#39;];</span><br><span class="line">arr.indexOf(10); &#x2F;&#x2F; 元素10的索引为0</span><br><span class="line">arr.indexOf(20); &#x2F;&#x2F; 元素20的索引为1</span><br><span class="line">arr.indexOf(30); &#x2F;&#x2F; 元素30没有找到，返回-1</span><br><span class="line">arr.indexOf(&#39;30&#39;); &#x2F;&#x2F; 元素&#39;30&#39;的索引为2</span><br></pre></td></tr></table></figure>

<p><strong>slice</strong><br><code>slice()</code>就是对应String的<code>substring()</code>版本，它截取<code>Array</code>的部分元素，然后返回一个新的<code>Array</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;];</span><br><span class="line">arr.slice(0, 3); &#x2F;&#x2F; 从索引0开始，到索引3结束，但不包括索引3: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br><span class="line">arr.slice(3); &#x2F;&#x2F; 从索引3开始到结束: [&#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;]</span><br></pre></td></tr></table></figure>
<p>如果不给<code>slice()</code>指定参数，默认是从头截到尾，我们也可以用这个方法来复制一个数组  </p>
<p><strong>push和pop</strong>  </p>
<p><code>push()</code>向<code>Array</code>的末尾添加若干元素，<code>pop()</code>则把<code>Array</code>的最后一个元素删除掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2];</span><br><span class="line">arr.push(&#39;A&#39;, &#39;B&#39;); &#x2F;&#x2F; 返回Array新的长度: 4</span><br><span class="line">arr; &#x2F;&#x2F; [1, 2, &#39;A&#39;, &#39;B&#39;]</span><br><span class="line">arr.pop(); &#x2F;&#x2F; pop()返回&#39;B&#39;</span><br><span class="line">arr; &#x2F;&#x2F; [1, 2, &#39;A&#39;]</span><br><span class="line">arr.pop(); arr.pop(); arr.pop(); &#x2F;&#x2F; 连续pop 3次</span><br><span class="line">arr; &#x2F;&#x2F; []</span><br><span class="line">arr.pop(); &#x2F;&#x2F; 空数组继续pop不会报错，而是返回undefined</span><br><span class="line">arr; &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>
<p><strong>unshift和shift</strong><br>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [1, 2];</span><br><span class="line">arr.unshift(&#39;A&#39;, &#39;B&#39;); &#x2F;&#x2F; 返回Array新的长度: 4</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, 1, 2]</span><br><span class="line">arr.shift(); &#x2F;&#x2F; &#39;A&#39;</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;B&#39;, 1, 2]</span><br><span class="line">arr.shift(); arr.shift(); arr.shift(); &#x2F;&#x2F; 连续shift 3次</span><br><span class="line">arr; &#x2F;&#x2F; []</span><br><span class="line">arr.shift(); &#x2F;&#x2F; 空数组继续shift不会报错，而是返回undefined</span><br><span class="line">arr; &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p><strong>reverse</strong><br><code>reverse()</code>把整个<code>Array</code>的元素给掉个个，也就是反转:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];</span><br><span class="line">arr.reverse(); </span><br><span class="line">arr; &#x2F;&#x2F; [&#39;three&#39;, &#39;two&#39;, &#39;one&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>splice</strong><br><code>splice()</code>方法是修改<code>Array</code>的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];</span><br><span class="line">&#x2F;&#x2F; 从索引2开始删除3个元素,然后再添加两个元素:</span><br><span class="line">arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只删除,不添加:</span><br><span class="line">arr.splice(2, 2); &#x2F;&#x2F; [&#39;Google&#39;, &#39;Facebook&#39;]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]</span><br><span class="line">&#x2F;&#x2F; 只添加,不删除:</span><br><span class="line">arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); &#x2F;&#x2F; 返回[],因为没有删除任何元素</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</span><br></pre></td></tr></table></figure>

<p><strong>concat</strong><br> <code>concat()</code>方法把当前的<code>Array</code>和另一个<code>Array</code>连接起来，并返回一个新的<code>Array</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">var added &#x3D; arr.concat([1, 2, 3]);</span><br><span class="line">added; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3]</span><br><span class="line">arr; &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br></pre></td></tr></table></figure>
<p>请注意 <code>concat()</code>方法并没有修改原来的<code>Array</code>,只是返回一个新的<code>Array</code><br>实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">arr.concat(1, 2, [3, 4]); &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p><strong>join</strong><br><code>join()</code>方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后<strong>返回连接后的字符串</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var arr &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">arr.concat(1, 2, [3, 4]); &#x2F;&#x2F; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, 1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">var arr &#x3D; [&#39;小明&#39;, &#39;小红&#39;, &#39;大军&#39;, &#39;阿黄&#39;];</span><br><span class="line">console.log(&#39;欢迎&#39;+arr.join(&#39;,&#39;)); &#x2F;&#x2F;欢迎小明,小红,大军,阿黄</span><br></pre></td></tr></table></figure>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &#39;Bob&#39;,</span><br><span class="line">    age: 20,</span><br><span class="line">    tags: [&#39;js&#39;, &#39;web&#39;, &#39;mobile&#39;],</span><br><span class="line">    city: &#39;Beijing&#39;,</span><br><span class="line">    hasCar: true,</span><br><span class="line">    zipcode: null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要访问到对象的属性，我们只需要用<code>对象名.属性名</code>的方式。<br>由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; undefined</span><br><span class="line">xiaoming.age &#x3D; 18; &#x2F;&#x2F; 新增一个age属性</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; 18</span><br><span class="line">delete xiaoming.age; &#x2F;&#x2F; 删除age属性</span><br><span class="line">xiaoming.age; &#x2F;&#x2F; undefined</span><br><span class="line">delete xiaoming[&#39;name&#39;]; &#x2F;&#x2F; 删除name属性</span><br><span class="line">xiaoming.name; &#x2F;&#x2F; undefined</span><br><span class="line">delete xiaoming.school; &#x2F;&#x2F; 删除一个不存在的school属性也不会报错</span><br></pre></td></tr></table></figure>
<p>如果我们要检测<code>xiaoming</code>是否拥有某一属性，可以用<code>in</code>操作符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;,</span><br><span class="line">    birth: 1990,</span><br><span class="line">    school: &#39;No.1 Middle School&#39;,</span><br><span class="line">    height: 1.70,</span><br><span class="line">    weight: 65,</span><br><span class="line">    score: null</span><br><span class="line">&#125;;</span><br><span class="line">&#39;name&#39; in xiaoming; &#x2F;&#x2F; true</span><br><span class="line">&#39;grade&#39; in xiaoming; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>但是<code>in</code>判断一个属性是否存在，这个属性可能是这个对象继承得到的，并非自己有的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;toString&#39; in xiaoming; &#x2F;&#x2F; true toString是每个object对象都有的属性</span><br></pre></td></tr></table></figure>
<p>所以要判断一个属性是否是对象自身拥有的，而不是继承得到的，可以用<code>hasOwnProperty()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xiaoming &#x3D; &#123;</span><br><span class="line">    name: &#39;小明&#39;</span><br><span class="line">&#125;;</span><br><span class="line">xiaoming.hasOwnProperty(&#39;name&#39;); &#x2F;&#x2F; true</span><br><span class="line">xiaoming.hasOwnProperty(&#39;toString&#39;); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、<code>$</code>和<code>_</code>的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如<code>if</code>、<code>while</code>等。申明一个变量用<code>var</code>语句，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a; &#x2F;&#x2F; 申明了变量a，此时a的值为undefined</span><br><span class="line">var $b &#x3D; 1; &#x2F;&#x2F; 申明了变量$b，同时给$b赋值，此时$b的值为1</span><br><span class="line">var s_007 &#x3D; &#39;007&#39;; &#x2F;&#x2F; s_007是一个字符串</span><br><span class="line">var Answer &#x3D; true; &#x2F;&#x2F; Answer是一个布尔值true</span><br><span class="line">var t &#x3D; null; &#x2F;&#x2F; t的值是null</span><br></pre></td></tr></table></figure>
<p>在JavaScript中，使用等号=对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，<strong>但是要注意只能用<code>var</code>申明一次</strong>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 123; &#x2F;&#x2F; a的值是整数123</span><br><span class="line">a &#x3D; &#39;ABC&#39;; &#x2F;&#x2F; a变为字符串</span><br></pre></td></tr></table></figure>
<p>这种变量本身类型不固定的语言称之为动态语言，与之相对应的是静态语言，静态语言在定义变量的时候必须指定变量类型，如果赋值的时候，类型不匹配，就会报错，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a &#x3D; 123; &#x2F;&#x2F; a是整数类型变量，类型用int申明</span><br><span class="line">a &#x3D; &quot;ABC&quot;; &#x2F;&#x2F; 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure>
<p>与静态语言相比，动态语言更灵活就是这样的原因。</p>
<h4 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h4><p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用<code>var</code>申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过<code>var</code>申明就被使用，那么该变量就自动被申明为<strong>全局变量</strong>：(这是一个设计缺陷)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 10; &#x2F;&#x2F; i现在是全局变量</span><br></pre></td></tr></table></figure>
<p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，<strong>强制通过<code>var</code>申明变量</strong>，未使用<code>var</code>申明变量就使用的，将导致运行错误。<br>启用strict模式的方法是在JavaScript代码的第一行写上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p><code>for</code>循环的一个变体是<code>for ... in</code>循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">    name: &#39;Jack&#39;,</span><br><span class="line">    age: 20,</span><br><span class="line">    city: &#39;Beijing&#39;</span><br><span class="line">&#125;;</span><br><span class="line">for (var key in o) &#123;</span><br><span class="line">    if (o.hasOwnProperty(key)) &#123; &#x2F;&#x2F;过滤掉非继承得来的属性</span><br><span class="line">        console.log(key); &#x2F;&#x2F; &#39;name&#39;, &#39;age&#39;, &#39;city&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Array</code>也是对象，而它的每个元素的索引被视为对象的属性，因此，<code>for ... in</code>循环可以直接循环出<code>Array</code>的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">    console.log(i); &#x2F;&#x2F; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;</span><br><span class="line">    console.log(a[i]); &#x2F;&#x2F; &#39;A&#39;, &#39;B&#39;, &#39;C&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>请注意，<code>for ... in</code>对<code>Array</code>的循环得到的是<code>String</code>而不是<code>Number</code>。</strong></p>
<h3 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h3><p><code>Map</code>和<code>Set</code>是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><code>Map</code>是一组键值对的结构，具有极快的查找速度。用JavaScript写一个Map如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]);</span><br><span class="line">m.get(&#39;Michael&#39;); &#x2F;&#x2F; 95</span><br></pre></td></tr></table></figure>
<p>初始化<code>Map</code>需要一个二维数组，或者直接初始化一个空<code>Map</code>。<code>Map</code>具有以下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map(); &#x2F;&#x2F; 空Map</span><br><span class="line">m.set(&#39;Adam&#39;, 67); &#x2F;&#x2F; 添加新的key-value</span><br><span class="line">m.set(&#39;Bob&#39;, 59);</span><br><span class="line">m.has(&#39;Adam&#39;); &#x2F;&#x2F; 是否存在key &#39;Adam&#39;: true</span><br><span class="line">m.get(&#39;Adam&#39;); &#x2F;&#x2F; 67</span><br><span class="line">m.delete(&#39;Adam&#39;); &#x2F;&#x2F; 删除key &#39;Adam&#39;</span><br><span class="line">m.get(&#39;Adam&#39;); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map();</span><br><span class="line">m.set(&#39;Adam&#39;, 67);</span><br><span class="line">m.set(&#39;Adam&#39;, 88);</span><br><span class="line">m.get(&#39;Adam&#39;); &#x2F;&#x2F; 88</span><br></pre></td></tr></table></figure>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p><code>Set</code>和<code>Map</code>类似，也是一组<code>key</code>的集合，但不存储<code>value</code>。由于<code>key</code>不能重复，所以，在<code>Set</code>中，没有重复的<code>key</code>。<br>要创建一个<code>Set</code>，需要提供一个<code>Array</code>作为输入，或者直接创建一个空<code>Set</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s1 &#x3D; new Set(); &#x2F;&#x2F; 空Set</span><br><span class="line">var s2 &#x3D; new Set([1, 2, 3]); &#x2F;&#x2F; 含1, 2, 3</span><br></pre></td></tr></table></figure>
<p>重复元素在<code>Set</code>中自动被过滤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set([1, 2, 3, 3, &#39;3&#39;]);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3, &quot;3&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>注意数字<code>3</code>和字符串<code>&#39;3&#39;</code>是不同的元素。<br>通过<code>add(key)</code>方法可以添加元素到<code>Set</code>中，可以重复添加，但不会有效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">s.add(4);</span><br><span class="line">s; &#x2F;&#x2F; 仍然是 Set &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>delete(key)</code>方法可以删除元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set([1, 2, 3]);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2, 3&#125;</span><br><span class="line">s.delete(3);</span><br><span class="line">s; &#x2F;&#x2F; Set &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<h3 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h3><p>遍历<code>Array</code>可以采用下标循环，遍历<code>Map</code>和<code>Set</code>就无法使用下标。为了统一集合类型，ES6标准引入了新的<code>iterable</code>类型，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型。<br>具有<code>iterable</code>类型的集合可以通过新的<code>for ... of</code>循环来遍历。<br><code>for...of</code> 是 ES6 新引入的循环，用于替代 <code>for..in</code> 和 <code>forEach()</code> ，并且支持新的迭代协议。它可用于迭代常规的数据类型，如 <code>Array</code> 、 <code>String</code> 、 <code>Map</code> 和 <code>Set</code> 等等。<br>用<code>for ... of</code>循环遍历集合，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">var s &#x3D; new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);</span><br><span class="line">var m &#x3D; new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);</span><br><span class="line">for (var x of a) &#123; &#x2F;&#x2F; 遍历Array</span><br><span class="line">    console.log(x); &#x2F;&#x2F; A \n B \n C</span><br><span class="line">&#125;</span><br><span class="line">for (var x of s) &#123; &#x2F;&#x2F; 遍历Set</span><br><span class="line">    console.log(x); &#x2F;&#x2F;A \n B \n C</span><br><span class="line">&#125;</span><br><span class="line">for (var x of m) &#123; &#x2F;&#x2F; 遍历Map</span><br><span class="line">    console.log(x[0] + &#39;&#x3D;&#39; + x[1]);</span><br><span class="line">&#125;&#x2F;&#x2F; 1&#x3D;x  \n 2&#x3D;y  \n 3&#x3D;z</span><br></pre></td></tr></table></figure>
<p><code>for ... of</code>循环和<code>for ... in</code>循环有何区别？<br><code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个<code>Array</code>数组实际上也是一个对象，它的<strong>每个元素的索引被视为一个属性</strong>。<br>当我们手动给<code>Array</code>对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">a.name &#x3D; &#39;Hello&#39;;</span><br><span class="line">for (var x in a) &#123;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; &#39;0&#39;,\n &#39;1&#39;,\n &#39;2&#39;, &#39;name&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for ... in</code>循环将把<code>name</code>包括在内，但<code>Array</code>的<code>length</code>属性却不包括在内。<br><code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">a.name &#x3D; &#39;Hello&#39;;</span><br><span class="line">for (var x of a) &#123;</span><br><span class="line">    console.log(x); &#x2F;&#x2F; &#39;A&#39;,\n &#39;B&#39;,\n &#39;C&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">a.forEach(function (element, index, array) &#123;</span><br><span class="line">    &#x2F;&#x2F; element: 指向当前元素的值</span><br><span class="line">    &#x2F;&#x2F; index: 指向当前索引</span><br><span class="line">    &#x2F;&#x2F; array: 指向Array对象本身</span><br><span class="line">    console.log(element + &#39;, index &#x3D; &#39; + index);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;A, index &#x3D; 0</span><br><span class="line">&#x2F;&#x2F;B, index &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;C, index &#x3D; 2</span><br></pre></td></tr></table></figure>
<p><code>Set</code>与<code>Array</code>类似，但<code>Set</code>没有索引，因此回调函数的前两个参数都是元素本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]);</span><br><span class="line">s.forEach(function (element, sameElement, set) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Map</code>的回调函数参数依次为value、key和map本身：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; new Map([[1, &#39;x&#39;], [2, &#39;y&#39;], [3, &#39;z&#39;]]);</span><br><span class="line">m.forEach(function (value, key, map) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得<code>Array</code>的<code>element</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];</span><br><span class="line">a.forEach(function (element) &#123;</span><br><span class="line">    console.log(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/w3cnote/es6-tutorial.html" target="_blank" rel="noopener">ES6教程</a><br>基本数据类型和引用数据类型的区别：<a href="https://www.cnblogs.com/c2016c/articles/9328725.html" target="_blank" rel="noopener">https://www.cnblogs.com/c2016c/articles/9328725.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo categories和tags页面不显示解决办法</title>
    <url>/2020/01/12/hexo%20categories%E5%92%8Ctags%E9%A1%B5%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h2 id="解决hexo-categories和tags页面不显示解决办法"><a href="#解决hexo-categories和tags页面不显示解决办法" class="headerlink" title="解决hexo categories和tags页面不显示解决办法"></a>解决hexo categories和tags页面不显示解决办法</h2><h3 id="第一步-需要新建tags和categories页面"><a href="#第一步-需要新建tags和categories页面" class="headerlink" title="第一步 需要新建tags和categories页面"></a>第一步 需要新建tags和categories页面</h3><p>在终端powershell下，确保此时是在hexo目录下，命令行输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags //新建tags页面</span><br></pre></td></tr></table></figure>
<p>然后会在hexo下的source目录看到tags文件夹，在index.md里输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-01-10 16:14:33</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">layout: <span class="string">"tags"</span>   <span class="comment">#增加tags的布局</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后再用同样的方法，新建一个categories</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories //新建categories页面</span><br></pre></td></tr></table></figure>
<p>然后配置categories 文件夹下的index.md</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-01-10 16:15:43</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">layout: <span class="string">"categories"</span>    <span class="comment">#增加categories的布局</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="第二步-给自己的帖子新加配置-增加tags和categories"><a href="#第二步-给自己的帖子新加配置-增加tags和categories" class="headerlink" title="第二步 给自己的帖子新加配置,增加tags和categories"></a>第二步 给自己的帖子新加配置,增加tags和categories</h3><p>例如我自己的一篇博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo categories和tags页面不显示解决办法</span><br><span class="line">date: 2020-01-12 17:22:40</span><br><span class="line">tags: 前端</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>但是就这样部署到github上是，访问自己的域名服务器，打开分类界面和标签界面都是404</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>打开theme目录下的主题配置文件_config.yml,按ctrl-f，搜索menu:，然后把/后面的空格去掉（刚开始的时候默认后面是加了空格所以导致的点击页面出现的404）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">   <span class="comment">#这/后面的空格得去掉，否则点击访问标签页和分类页的时候会404报错</span></span><br><span class="line">  home: /|| home <span class="comment">#首页</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br></pre></td></tr></table></figure>
<h2 id="给自己的post中的代码块增加一键复制功能"><a href="#给自己的post中的代码块增加一键复制功能" class="headerlink" title="给自己的post中的代码块增加一键复制功能"></a>给自己的post中的代码块增加一键复制功能</h2><h3 id="第一步-下载clipboard-js"><a href="#第一步-下载clipboard-js" class="headerlink" title="第一步 下载clipboard.js"></a>第一步 下载clipboard.js</h3><p>下载第三方插件<a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js" target="_blank" rel="noopener">clipboard.js</a>，打开之后，右键另存为，保存文件再theme/next/source/js/src目录下</p>
<h3 id="第二步-clipboard-js的使用"><a href="#第二步-clipboard-js的使用" class="headerlink" title="第二步 clipboard.js的使用"></a>第二步 clipboard.js的使用</h3><p>也是在theme/next/source/js/src目录下，创建 clipboard-use.js，添加内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*页面载入完成后，创建复制按钮*/</span><br><span class="line">!<span class="keyword">function</span> (e, t, a) &#123; </span><br><span class="line">  /* code */</span><br><span class="line">  var initCopyCode = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var copyHtml = <span class="string">''</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;span&gt;复制&lt;/span&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">    $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">    new ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">        target: <span class="keyword">function</span>(trigger) &#123;</span><br><span class="line">            <span class="built_in">return</span> trigger.nextElementSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure>
<p>然后再theme/next/source/css/_custom/custom.styl 样式中添加如下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//代码块复制按钮</span><br><span class="line">.highlight&#123;</span><br><span class="line">  //方便copy代码按钮（btn-copy）的定位</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">    background-color: <span class="comment">#eee;</span></span><br><span class="line">    background-image: linear-gradient(<span class="comment">#fcfcfc,#eee);</span></span><br><span class="line">    border: 1px solid <span class="comment">#d5d5d5;</span></span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    -webkit-user-select: none;</span><br><span class="line">    -moz-user-select: none;</span><br><span class="line">    -ms-user-select: none;</span><br><span class="line">    user-select: none;</span><br><span class="line">    -webkit-appearance: none;</span><br><span class="line">    font-size: 13px;</span><br><span class="line">    font-weight: 700;</span><br><span class="line">    line-height: 20px;</span><br><span class="line">    color: <span class="comment">#333;</span></span><br><span class="line">    -webkit-transition: opacity .3s ease-in-out;</span><br><span class="line">    -o-transition: opacity .3s ease-in-out;</span><br><span class="line">    transition: opacity .3s ease-in-out;</span><br><span class="line">    padding: 2px 6px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 5px;</span><br><span class="line">    top: 5px;</span><br><span class="line">    opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">.btn-copy span &#123;</span><br><span class="line">    margin-left: 5px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight:hover .btn-copy&#123;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三步-引用"><a href="#第三步-引用" class="headerlink" title="第三步 引用"></a>第三步 引用</h3><p>在 theme/next/layout/_layout.swig文件中引用(/body)结束标签之前添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 代码块复制功能 --&gt;</span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard.min.js"</span>&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span> src=<span class="string">"/js/src/clipboard-use.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="第四步-运行"><a href="#第四步-运行" class="headerlink" title="第四步 运行"></a>第四步 运行</h3><p>重新 执行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean //清理之前的文件</span><br><span class="line">hexo g //生成</span><br><span class="line">hexo s //跑在本地</span><br></pre></td></tr></table></figure>
<p>打开本地localhost:4000，看复制功能是否可以正常实现。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>采用gitpages和hexo建立自己的个人博客</title>
    <url>/2019/12/27/%E9%87%87%E7%94%A8gitpages%E5%92%8Chexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从开始搭建到完成，断断续续，毕竟自己也是照着别人的文章和官方文档再做，结果变成了搭建完，先优化主题，最后才开始写这篇博客。这其中还是有些坑需要记录一下</p>
<h2 id="第一步-准备工作"><a href="#第一步-准备工作" class="headerlink" title="第一步 准备工作"></a>第一步 准备工作</h2><p>首先确保自己的node.js已经安装好，而且环境变量配置好，有自己个人的github账户。<br>接着在github上新建一个repository，命名为：你的github名称.github.io(下面是我的仓库名称)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yinjiangqaq.github.io</span><br></pre></td></tr></table></figure>

<h2 id="第二步-安装hexo"><a href="#第二步-安装hexo" class="headerlink" title="第二步 安装hexo"></a>第二步 安装hexo</h2><p>hexo其实就是一个博客框架，方便我们建站的一个框架。官网也有安装教程<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></p>
<h3 id="step1："><a href="#step1：" class="headerlink" title="step1："></a>step1：</h3><p>Windows系统的话，可以不在系统盘，可以选择D盘，然后鼠标右键git bash，输入两个安装指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> npm install hexo-cli -g   //用于全局安装hexo</span><br><span class="line">npm install hexo-deployer-git --save   //用于安装hexo部署到git page的deployer</span><br></pre></td></tr></table></figure>
<h3 id="step2：-新建一个hexo文件夹"><a href="#step2：-新建一个hexo文件夹" class="headerlink" title="step2： 新建一个hexo文件夹"></a>step2： 新建一个hexo文件夹</h3><p>在D盘新建一个名为hexo的文件夹，然后再次鼠标右键git bash，输入两个指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init  //安装 hexo相关的包</span><br><span class="line">npm install   //安装node_modules和所有package.json里的包</span><br></pre></td></tr></table></figure>
<p>执行这两个指令完成之后，你会看到你的hexo文件夹多了一些文件，这时候如果你想看本地效果的话，可以执行如下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate  //自动将md文件生成静态html，css文件</span><br><span class="line">hexo server  //启动本地hexo服务器（localhost:4000）</span><br></pre></td></tr></table></figure>
<p>然后打开浏览器访问localhost:4000，便可以看到自己建立博客页面了</p>
<h2 id="第三步-了解hexo文件夹中-config-yml文件"><a href="#第三步-了解hexo文件夹中-config-yml文件" class="headerlink" title="第三步 了解hexo文件夹中_config.yml文件"></a>第三步 了解hexo文件夹中_config.yml文件</h2><p>hexo文件夹中比较重要的文件是：_config.yml，这是一个全局配置文件。</p>
<h3 id="step1：-1"><a href="#step1：-1" class="headerlink" title="step1："></a>step1：</h3><p>执行命令，安装deploy.git插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h3 id="step2："><a href="#step2：" class="headerlink" title="step2："></a>step2：</h3><p>打开这个文件，修改一下下面这部分(在配置文件的最后)，让自己的本地项目和远程仓库通过 git  建立连接部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">   <span class="built_in">type</span>: git</span><br><span class="line">   repository: https://github.com/yinjiangqaq/yinjiangqaq.github.io.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure>
<h3 id="step3："><a href="#step3：" class="headerlink" title="step3："></a>step3：</h3><p>配置提交github认证方式<br>执行指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>直接提交到远程你自己之前创建的github仓库，如果没有认证github和本地的关系，会提示你输入用户名和密码，输入完成之后，就会发现除了在.gitignore中出现的默认不推上去的文件之后，其他文件都推到了远程的github仓库</p>
<h2 id="第五步-添加域名"><a href="#第五步-添加域名" class="headerlink" title="第五步 添加域名"></a>第五步 添加域名</h2><p>阿里云中买一个.com的域名(域名价格纯看你的自己想起的名字，反正我的不知不觉就贵了，还享受不到优惠….)<br>这其中省略了你要注册阿里云账号，实名认证之类的步骤</p>
<h3 id="step1-cmd-ping-一下-github-io，获得真是ip地址"><a href="#step1-cmd-ping-一下-github-io，获得真是ip地址" class="headerlink" title="step1 cmd ping 一下 github.io，获得真是ip地址"></a>step1 cmd ping 一下 github.io，获得真是ip地址</h3><p><img src="/2019/12/27/%E9%87%87%E7%94%A8gitpages%E5%92%8Chexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ping.png" alt="ping.png"> </p>
<h3 id="step2：-1"><a href="#step2：-1" class="headerlink" title="step2："></a>step2：</h3><p>然后再域名操作栏点击解析，添加记录<br><img src="/2019/12/27/%E9%87%87%E7%94%A8gitpages%E5%92%8Chexo%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/jiexi.png" alt="jiexi.png"><br>记得需要添加两个记录，只添加www不知道为啥显示不出来</p>
<h3 id="step3"><a href="#step3" class="headerlink" title="step3:"></a>step3:</h3><p>去hexo文件夹的source目录下新建一个名为CNAME的文件，添加文件内容为你刚才购买的域名，不要添加www，内容添加如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yinjiangqaq.com</span><br></pre></td></tr></table></figure>
<h3 id="step4："><a href="#step4：" class="headerlink" title="step4："></a>step4：</h3><p>然后部署,power shell输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  //清除上次的缓存</span><br><span class="line">hexo generate //生成</span><br><span class="line">hexo deploy //部署</span><br></pre></td></tr></table></figure>
<p>(每次做出大一点的更改都建议部署一次)</p>
<h3 id="step5"><a href="#step5" class="headerlink" title="step5:"></a>step5:</h3><p>如果之前注册域名的时候，有进行过实名认证，那部署成功之后，打开浏览器输入你的域名，便可以看到你的个人博客了</p>
<h2 id="关于主题优化"><a href="#关于主题优化" class="headerlink" title="关于主题优化"></a>关于主题优化</h2><p>推荐一些已经很完善的博客，我也是借鉴其中的：<br><a href="https://io-oi.me/tech/hexo-next-optimization/#%E5%BF%85%E8%AF%BB-%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2" target="_blank" rel="noopener">hexo深度优化</a><br><a href="https://blog.csdn.net/zgcr654321/article/details/86751765" target="_blank" rel="noopener">hexo主题个性化设置</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
